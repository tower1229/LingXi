# 灵犀 2.0 重构方案

## 概述

本文档描述灵犀 workflow 从 1.0 到 2.0 的完整重构方案，包括流程架构重构和质量资产化机制优化。

## 重构目标

### 核心目标

1. **提升灵活性**：废弃单入口设计，改为多入口 Commands，支持优秀开发者直接切入任意阶段
2. **流程解耦**：所有环节可跳过，实现真正的可伸缩工作流
3. **Req 升级**：将 req 文档升级为"造物计划"（设计+产品+技术方案概览）
4. **经验管理优化**：统一经验捕获机制，优化经验注入和匹配策略

### 设计原则

- **心有灵犀**：Req 作为造物计划有助于沉淀设计思路，经验管理优化提升复用效率
- **AI Native**：-
- **称心如意**：多入口灵活，无生命周期限制，优秀开发者可直接切入，提高灵活性

## 一、流程架构重构

### 1.1 命令体系（多入口，手动指定编号）

#### 命令列表

```markdown
/req <描述>                    # 创建造物计划（产出：001.req.<标题>.md）
/req-review 001                # 审查 req 文档（可选，可多次）
/plan 001                      # 生成任务规划（产出：001.plan.<标题>.md + 001.testcase.<标题>.md）
/build 001                     # 执行构建（编写测试脚本+执行单元测试+文档同步）
/review 001                    # 审查交付（产出：001.review.<标题>.md，包含测试执行+多维度审查）
```

#### 命令特性

- **除req外所有命令必须手动指定任务编号**（001, 002, ...）
- **无生命周期管理，无状态路由**
- **每个命令独立执行，不依赖前一阶段完成**
- **允许任务停留在任意阶段**（不强制状态）

#### 架构优势

- **优秀开发者优先**：按需选择命令，直接命令零等待，符合"称心如意"
- **新手友好**：命令语义清晰，降低学习成本
- **不向后兼容**：与2.0不兼容的设计全部移除，无需兼容

### 1.2 Req：造物计划（设计+产品+技术方案概览）

#### 定位

Req 是整个流程的核心，高质量的 req 文档是保证任务最终效果的前提。Req 必须超越普通 PRD 文档的范畴，除了需求提纯和放大之外，还必须定好核心技术方案或技术决策。这不是一份传统意义上产品经理向技术团队提出的需求说明，而是一个顶尖创造者脑海中迸发的集设计灵感、产品构思、实现途径于一体的造物计划。

#### 内容要求

- **设计灵感**：产品构思、用户体验设计
- **产品功能**：功能需求、交互流程
- **技术方案概览**：技术选型、架构思路、关键技术点（**不含实现细节**）

#### 文档结构

```markdown
# 001.req.<标题>.md

## 设计构思
- 产品愿景、用户价值、体验设计

## 功能需求
- 核心功能列表
- 交互流程
- 边界条件

## 技术方案概览
- 技术选型（框架/库/工具）
- 架构思路（分层、模块划分）
- 关键技术点（核心算法/设计模式）
- **技术方案不包含实现细节**（具体代码、文件路径、函数签名）
- 依赖关系

## 验收标准
- 功能验收清单
- 性能指标
- 质量标准
```

#### 文件命名约定

- 格式：`001.req.<标题>.md`（标题 10 字以内）

### 1.3 Req-Review：审查 req 文档

#### 定位

对 req 文档展开 review，用于辅助提升 req 文档的质量。该步骤可省略，也可以多次执行，完全取决于使用者。

#### 审查维度

- **需求完整性**：功能描述是否完整、边界是否清晰
- **技术可行性**：技术选型是否可行、架构是否合理
- **可测试性**：需求是否可验证、验收标准是否明确
- **可实现性**：方案是否可实现、依赖是否明确

#### 执行方式

- 用户手动执行：`/req-review 001`
- 不产出文件，仅输出审查结果和建议

### 1.4 Plan：任务规划（测试用例文档 + 文档检测）

#### 定位

基于 req 文档中的需求做进一步的任务规划，通过澄清细节问题，规划具体的执行步骤等，辅助提高任务执行质量。

#### 产出文件

1. **任务规划文档**：`001.plan.<标题>.md`
2. **测试用例文档**：`001.testcase.<标题>.md`

#### 产出内容

1. **任务拆解**（在 plan 文档中）：
   - 功能需求 → 任务列表
   - 依赖关系
   - 执行顺序

2. **测试用例文档**（独立文件 `001.testcase.<标题>.md`）：
   - 基于 req 的功能需求编写测试用例
   - 测试场景、测试数据、预期结果
   - 不包含测试脚本（脚本在 build 阶段编写）

3. **文档检测**（需同步的文档）：
   - 检测项目中现有的技术方案文档、设计文档
   - 识别可能受本次改动影响的文档
   - 在 plan 中列出需同步的文档列表，作为任务的一部分

#### 测试框架检测与安装

**多层检测策略**：

1. 检查 `package.json` 的 `devDependencies`（jest, vitest, mocha, jasmine 等）
2. 检查项目根目录的测试配置文件（`jest.config.js`, `vitest.config.ts`, `mocha.opts` 等）
3. 检查测试目录结构（`tests/`, `__tests__/`, `test/`, `spec/` 等）
4. 检查测试文件模式（`*.test.js`, `*.spec.ts`, `*.test.tsx` 等）

**检测结果处理**：

- 如果检测到现有框架：记录框架类型和配置，在 plan 中说明将使用该框架
- 如果未检测到框架：
  - 检查依赖冲突：检查 `package.json` 是否有冲突依赖
  - 安装 vitest：`yarn add -D vitest` 或 `npm install -D vitest`
  - 创建配置文件：`vitest.config.ts`（按最佳实践）
  - 创建测试目录：`tests/unit/`, `tests/integration/`
  - 更新 `package.json` 的 `scripts.test`
  - 验证安装：执行 `yarn test` 或 `npm test` 验证框架是否正常工作

**冲突处理**：

- 如果检测到依赖冲突：提示用户，不自动安装，在 plan 中标记需要手动处理

#### 文档命名约定

- Plan 文档：`001.plan.<标题>.md`（标题 10 字以内）
- 测试用例文档：`001.testcase.<标题>.md`（标题 10 字以内）

#### 特性

- 该步骤可跳过，仅复杂任务建议在 build 之前执行规划
- 取决于使用者对任务复杂度以及 agent 的执行能力的判断

### 1.5 Build：执行构建（编写测试脚本 + 单元测试 + 文档同步）

#### 定位

用于按 req 文档和可选的 plan 文档执行任务。该步骤虽然理论上不可跳过，但是创造者可以选择不调用 build 命令而自行基于 req 文档和可选的 plan 文档进行开发工作，因此从流程上将该步骤仍然可以跳过。

#### 执行内容

1. **代码实现**：
   - 按 req 的技术方案实现功能
   - 按 plan 的任务清单执行开发任务

2. **编写测试脚本**（引用测试用例文档）：
   - 读取 `001.testcase.<标题>.md`
   - 基于测试用例文档编写测试脚本
   - 遵循项目测试框架（plan 中检测到或已安装的框架）
   - 按模块组织：模块完成后编写并执行对应测试

3. **执行单元测试**：
   - 模块完成后执行单元测试
   - 记录测试执行结果（通过/失败）
   - 测试失败时提供修复建议

4. **文档同步**（plan 中的任务）：
   - 读取 plan 中的文档同步任务清单
   - 基于代码变更自动更新相关文档：
     - 扫描代码注释、类型定义
     - 提取接口信息、模块结构
     - 更新文档对应章节
   - 同步完成后标记任务完成

#### 降级方案

如果测试框架无法执行（环境问题、依赖问题等）：
- 输出手动测试清单（基于 plan 的测试用例文档）
- 提供测试步骤和预期结果
- 标记需要手动验证

如果文档同步无法自动执行（格式不支持、结构复杂等）：
- 输出文档更新清单（需要手动更新的文档和章节）
- 提供更新建议和内容要点
- 标记需要手动同步

### 1.6 Review：审查交付（测试执行 + 多维度审查）

#### 定位

Review 实际上是除了 req 之外第二重要的环节，因为工作流的最终目的就是交付，而 review 就是判定产出是否达到交付标准的环节。

#### 执行内容

1. **测试用例文档审查**：
   - 读取 `001.testcase.<标题>.md`
   - 基于 req 审查测试用例文档
   - 检查覆盖完整性、准确性
   - 如不完整或不合格，补充或修改测试用例文档

2. **测试执行**：
   - 执行单元测试（基于 build 编写的测试脚本）
   - 执行集成测试（如有）
   - 记录测试执行结果

3. **多维度审查**：
   - 功能审查：是否符合 req 要求
   - 代码质量：可维护性、可读性
   - 测试覆盖：是否完整（对照测试用例文档）
   - 文档一致性：代码与文档是否一致（检查 build 阶段同步的文档）

#### 测试执行逻辑

- 使用项目中检测到的测试框架
- 执行命令：`yarn test` 或 `npm test`（由项目配置决定）
- 解析测试输出：提取通过/失败/跳过的测试数量
- 失败处理：列出失败用例，提供修复建议

#### 降级方案

如果测试框架无法执行（环境问题、依赖问题等）：
- 输出手动测试清单（基于 plan 的测试用例文档）
- 提供测试步骤和预期结果
- 标记需要手动验证

#### 产出文档

- `001.review.<标题>.md`（审查总结报告，**不存档**）

### 1.7 流程解耦特性

#### 废弃任务生命周期设计

- **彻底废弃任务生命周期设计**，所有环节命令需要手动指定任务编号
- **所有环节可跳过**：除了 req 之外，其他环节都可以跳过
- **不强制状态**：允许任务停留在任意阶段

#### 文件命名约定

所有产出文档统一命名格式：

- Req：`001.req.<标题>.md`
- Plan：`001.plan.<标题>.md`
- Testcase：`001.testcase.<标题>.md`
- Review：`001.review.<标题>.md`（不存档）

#### 文档关系图

```
001.req.<标题>.md
  ↓
  ├─→ 001.plan.<标题>.md（任务规划，引用测试用例文档）
  │     ↓
  │     └─→ 001.testcase.<标题>.md（测试用例文档，独立文件）
  │           ↓
  │           └─→ build 阶段编写测试脚本
  │                 ↓
  │                 └─→ review 阶段审查和执行测试
  │
  └─→ 001.req.<标题>.md（review 阶段对照审查）
```

## 二、质量资产化机制优化

### 2.1 经验注入机制改进

#### 2.1.1 调整 experience-index 激活条件

**原机制**：
- 激活时机：`/flow` 进入 req/plan/work/review/archive 任一阶段前自动激活
- 匹配依据：基于当前场景（需求描述/阶段/涉及模块）做关键词 + 语义匹配 Trigger

**新机制**：
```markdown
---
name: experience-index
description: 此 Skill 在执行 /req、/plan 001、/build 001、/review 001 等命令时自动激活，按 Trigger 匹配 .workflow/context/experience/INDEX.md 的 active 经验并主动提醒风险与指针。
---
```

#### 2.1.2 上下文获取逻辑

在激活 experience-index 时，自动获取上下文：

1. **从命令参数推断任务编号和阶段**：
   - `/plan 001` → 阶段：plan，任务编号：001
   - `/build 001` → 阶段：build，任务编号：001
   - `/review 001` → 阶段：review，任务编号：001

2. **读取对应的 req 文件**：
   - 扫描 `.workflow/requirements/in-progress/` 目录
   - 匹配 `001.req.*.md` 文件
   - 读取 req 文件内容作为匹配上下文

3. **基于 req 内容 + 当前阶段进行经验匹配**：
   - 提取 req 中的关键词（技术选型、功能描述、架构思路等）
   - 结合当前阶段（plan/build/review）进行 Trigger 匹配
   - 输出匹配的经验（风险级别 + 指针）

#### 2.1.3 输出规则

- **无匹配时**：完全静默，不输出任何内容
- **有匹配时**：仅输出关键信息（风险级别 + 指针），省略冗长的结构化格式
- 输出格式示例：
  ```
  ⚠️ 高风险：XXX（参考 EXP-001.md）
  ```

### 2.2 经验捕获机制改进（抽取为 Skill）

#### 2.2.1 创建统一的 experience-capture Skill

**原机制**：
- 捕获方式：各阶段 Skill 中通过 EXP-CANDIDATE 注释捕获
- 触发场景：req/plan/work/review 各阶段定义的经验候选触发场景

**新机制**：
```markdown
---
name: experience-capture
description: 此 Skill 在执行 /req、/plan 001、/build 001、/review 001 等命令时自动激活，自动检测当前阶段和任务编号，提供统一的 EXP-CANDIDATE 捕获逻辑。
---
```

#### 2.2.2 阶段和任务编号检测逻辑

Skills 可以通过以下方式获取上下文：

1. **从对话历史推断**：
   - 检测用户最近输入的命令（`/plan 001`、`/build 001` 等）
   - 提取命令名（plan/build/review）和参数（001）

2. **从文件系统推断**：
   - 扫描 `.workflow/requirements/in-progress/` 目录
   - 检测最近修改的文件（`001.req.*.md`、`001.plan.*.md` 等）
   - 通过文件命名模式推断任务编号和阶段

3. **从文件存在性推断阶段**：
   - 如果存在 `001.req.*.md` 且不存在 `001.plan.*.md` → req 阶段
   - 如果存在 `001.plan.*.md` 且不存在 `001.build.*.md` → plan 阶段
   - 如果存在 `001.build.*.md` → build 阶段

#### 2.2.3 统一的 EXP-CANDIDATE 捕获逻辑

**捕获流程**：

1. **自动检测当前阶段和任务编号**
2. **加载对应阶段的触发场景**（从 references 目录按需加载）
3. **监控对话，捕获经验候选**（HTML 注释包裹）

**输出格式**：

```html
<!-- EXP-CANDIDATE
{
  "taskId": "001",
  "stage": "plan",
  "trigger": "当任务 T2 依赖从A改为B",
  "decision": "任务/验收/测试策略的取舍",
  "alternatives": ["原方案A（放弃，因为...）"],
  "signal": "判断依据/风险信号",
  "solution": "新的任务拆解/验收/测试策略",
  "verify": "后续如何验证该决策",
  "pointers": ["path/to/plan-file 或相关模块"],
  "reqFile": ".workflow/requirements/in-progress/001.req.<标题>.md",
  "notes": "可选补充"
}
-->
```

**关键字段**：
- `taskId`：任务编号（001, 002, ...）
- `stage`：当前阶段（req/plan/build/review）
- `reqFile`：关联的 req 文件路径（用于后续匹配和追溯）

#### 2.2.4 各阶段触发场景（references）

创建 `references/` 目录，存放各阶段的触发场景：

- `references/req-triggers.md`：req 阶段的触发场景列表
- `references/plan-triggers.md`：plan 阶段的触发场景列表
- `references/build-triggers.md`：build 阶段的触发场景列表
- `references/review-triggers.md`：review 阶段的触发场景列表

每个文件包含该阶段的触发场景定义和典型信号。

#### 2.2.5 文件结构

```
.cursor/skills/
├── experience-capture/（新建）
│   ├── SKILL.md
│   └── references/
│       ├── req-triggers.md
│       ├── plan-triggers.md
│       ├── build-triggers.md
│       └── review-triggers.md
```

### 2.3 经验沉淀机制改进

#### 2.3.1 保持用户主动触发

- 各阶段执行过程中通过 experience-capture 捕获经验候选
- 经验候选自动收集到 `.workflow/context/session/pending-compounding-candidates.json`
- 阶段完成后（或用户主动）提示可沉淀的经验候选

#### 2.3.2 优化沉淀体验

1. **阶段完成提示**：
   - 各阶段完成后，自动展示待沉淀的经验候选列表
   - 提供编号选择（如 `1,3`）快速沉淀

2. **沉淀时机**：
   - 用户主动触发：输入编号（如 `1,3`）或 `/remember`
   - 自动提示：阶段完成后提示可沉淀的经验候选

3. **沉淀流程**：
   - 调用 `candidate-evaluator` 评估候选
   - 展示候选及评估结果
   - 用户选择要沉淀的候选
   - 调用 `experience-curator` 进行冲突检测和治理
   - 用户选择存储目标（经验库/规则库）
   - 写入对应位置

### 2.4 经验匹配优化

#### 2.4.1 多维度匹配策略

在 experience-index 中，基于以下维度进行匹配：

1. **任务编号 + 阶段**：
   - 如果经验候选的 `taskId` 和 `stage` 匹配，优先返回

2. **req 内容匹配**：
   - 提取 req 文件中的关键词（技术选型、功能描述、架构思路等）
   - 与经验的 `Trigger` 进行关键词 + 语义匹配

3. **阶段匹配**：
   - 优先返回与当前阶段相关的经验（如 plan 阶段优先返回 plan 相关经验）

4. **跨任务经验复用**：
   - 基于 `Trigger` 关键词和语义匹配，支持跨任务经验复用
   - 如果当前任务与历史任务的 Trigger 相似，返回相关经验

#### 2.4.2 匹配优先级

1. **高优先级**：任务编号 + 阶段 + Trigger 完全匹配
2. **中优先级**：阶段 + Trigger 匹配（跨任务复用）
3. **低优先级**：仅 Trigger 关键词匹配

#### 2.4.3 经验关联优化

在 EXP-CANDIDATE 中增加关联字段：
- `taskId`：任务编号（001, 002, ...）
- `reqFile`：关联的 req 文件路径
- `stage`：当前阶段

支持双重关联：
- 通过任务编号关联（快速查找）
- 通过 req 文件路径关联（精确追溯）

## 三、架构对比

### 3.1 命令体系对比

| 维度 | 1.0（单入口） | 2.0（多入口） |
|------|--------------|--------------|
| 入口 | `/flow` 统一入口 | `/req`, `/plan 001`, `/build 001` 等独立命令 |
| 状态管理 | flow-router 自动状态判断 | 无状态管理，手动指定任务编号 |
| 灵活性 | 必须按流程顺序执行 | 所有环节可跳过，按需执行 |
| 目标用户 | 新手友好 | 优秀开发者优先 |

### 3.2 流程解耦对比

| 维度 | 1.0 | 2.0 |
|------|-----|-----|
| 生命周期 | 完整生命周期管理 | 废弃生命周期，允许停留在任意阶段 |
| 环节依赖 | 前一环节完成才能进入下一环节 | 所有环节独立，可跳过 |
| 状态追踪 | 通过 INDEX.md 追踪状态 | 通过文件存在性推断（可选） |

### 3.3 经验管理对比

| 维度 | 1.0 | 2.0 |
|------|-----|-----|
| 经验注入 | 依赖 `/flow` 统一入口 | 支持多入口命令自动激活 |
| 经验捕获 | 各阶段 Skill 中重复定义 | 统一的 experience-capture Skill |
| 经验匹配 | 基于阶段和需求描述 | 多维度匹配（任务编号+阶段+req内容+Trigger） |

## 四、实施计划

### 4.1 阶段 1：流程架构重构

1. **创建新命令**（`.cursor/commands/`）：
   - `req.md`：创建造物计划
   - `req-review.md`：审查 req 文档
   - `plan.md`：生成任务规划
   - `build.md`：执行构建
   - `review.md`：审查交付

2. **迁移逻辑**：
   - 从各阶段 Skill 中提取执行逻辑到对应 Command
   - 保留辅助 Skills（plan-manager, index-manager 等）

3. **废弃 flow-router**：
   - 标记 flow-router 为 deprecated（可选保留作为智能路由）

### 4.2 阶段 2：经验管理优化

1. **调整 experience-index**：
   - 更新激活条件，支持多入口命令
   - 实现上下文获取逻辑

2. **创建 experience-capture**：
   - 创建统一的经验捕获 Skill
   - 实现阶段和任务编号自动检测
   - 创建各阶段触发场景文件（references）

3. **优化经验匹配**：
   - 实现多维度匹配策略
   - 优化经验关联机制

### 4.3 阶段 3：测试与验证

1. **功能测试**：
   - 测试各命令独立执行
   - 测试流程解耦（跳过环节）
   - 测试经验注入和捕获

2. **兼容性测试**：
   - 确保现有经验库正常工作
   - 确保现有 req/plan 文档可正常读取

3. **性能测试**：
   - 测试经验匹配性能
   - 测试文件系统推断性能

## 五、风险评估与应对

### 5.1 状态管理缺失

**风险**：删除 flow-router 后，如何判断任务当前状态？

**应对**：
- 通过文件存在性推断（`001.req.*.md` 存在→req 完成）
- 提供可选的轻量状态文件（`.workflow/requirements/in-progress/.001.req.xxx.status`）
- 不强制状态，允许任务停留在任意阶段

### 5.2 经验注入遗漏

**风险**：多入口可能导致某些命令未激活经验注入

**应对**：
- 调整 experience-index 激活条件，支持所有命令
- 通过文件系统推断确保上下文完整

### 5.3 经验捕获准确性

**风险**：阶段和任务编号检测可能不准确

**应对**：
- 多层检测策略（对话历史 + 文件系统 + 文件存在性）
- 优先级策略：优先使用最可靠的信息源

### 5.4 向后兼容性

**风险**：现有工作流可能依赖 flow-router

**应对**：
- 保留 flow-router 作为可选智能路由（标记为 deprecated）
- 提供迁移指南，帮助用户迁移到新命令

## 六、价值对齐评估

| 维度 | 评估 |
|------|------|
| **心有灵犀** | ✅ Req 作为造物计划有助于沉淀设计思路，经验管理优化提升复用效率 |
| **AI Native** | ✅ 流程解耦尊重创造者选择，不过度约束 AI |
| **称心如意** | ✅ 多入口灵活，优秀开发者可直接切入，降低认知负担 |

## 七、总结

灵犀 2.0 重构方案通过流程架构重构和质量资产化机制优化，实现了以下目标：

1. **提升灵活性**：多入口设计，支持优秀开发者直接切入任意阶段
2. **流程解耦**：所有环节可跳过，实现真正的可伸缩工作流
3. **Req 升级**：将 req 文档升级为"造物计划"，提升文档质量
4. **经验管理优化**：统一经验捕获机制，优化经验注入和匹配策略

该方案符合灵犀的核心价值指引（心有灵犀、AI Native、称心如意），为创造者提供了更灵活、更高效的 AI 辅助工作流。
