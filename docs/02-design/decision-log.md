# 关键设计决策记录

## 概述

本文档记录 cursor-workflow 项目中的关键设计决策，包括决策背景、选择理由和影响评估。

## 决策列表

### D1: 为什么选择 Skills-first 设计

**决策时间**：项目初期

**背景**：
- Cursor Nightly 提供了 Agent Skills 能力
- 需要将高质量提示词、模板、检查清单组织起来
- 需要在可维护性和灵活性之间找到平衡

**选择**：采用 Skills-first 设计，将能力下沉到 Skills

**理由**：
- **可维护性**：Skills 独立维护，易于更新和扩展
- **可复用性**：Skills 可在不同场景复用
- **可测试性**：Skills 可以独立测试和验证
- **可组合性**：Skills 可以组合使用，形成复杂工作流

**替代方案**：
- 硬编码在主命令中：难以维护，无法复用
- 分散在多个文件：难以管理，容易遗漏

**影响**：
- 提高了系统的可维护性和可扩展性
- 降低了新功能的开发成本
- 需要维护 Skills 的版本和兼容性

**参考**：[设计理念：Skills-first 设计](../01-concepts/philosophy.md#5-skills-first-设计)

---

### D2: 为什么移除 after-agent-response hook

**决策时间**：2026-01-12

**背景**：
- 最初使用 `after-agent-response` hook 来抽取复利候选
- Cursor 提供了 Subagents 能力，可以更好地处理经验收集

**选择**：移除 `after-agent-response` hook，改用 Subagents 机制

**理由**：
- **更好的隔离**：Subagents 提供上下文隔离，减少主对话干扰
- **更清晰的职责**：experience-collector 专门负责收集，职责单一
- **更灵活的触发**：Subagents 可以在检测到 EXP-CANDIDATE 时自动触发
- **更符合架构**：与 Skills-first 设计一致

**替代方案**：
- 保留 hook 作为兜底：增加了系统复杂度
- 只使用 hook：无法利用 Subagents 的优势

**影响**：
- 简化了系统架构
- 提高了经验收集的可靠性
- 需要确保 Subagents 正确配置

**参考**：
- [架构概览：Subagents Layer](../01-concepts/architecture-overview.md#3-subagents-layer子代理层)
- [知识沉淀机制：即时捕获](../02-design/knowledge-compounding.md#即时捕获机制)

---

### D3: 为什么 compound → archive

**决策时间**：2026-01-12

**背景**：
- 最初设计中有 `compound` 阶段，负责经验沉淀
- 经验沉淀应该分散到各个流程节点，而不是集中在一个阶段

**选择**：将 `compound` 重命名为 `archive`，调整职责为仅归档

**理由**：
- **职责分离**：归档和经验沉淀是不同的职责
- **即时捕获**：经验应该在各个阶段即时捕获，而不是等到最后
- **更清晰的语义**：`archive` 更准确地描述了阶段的职责
- **符合设计理念**：即时捕获，分层处理

**替代方案**：
- 保留 compound 阶段：职责不清晰，容易混淆
- 移除归档阶段：无法管理已完成的需求

**影响**：
- 明确了阶段职责
- 提高了经验捕获的及时性
- 需要更新所有相关文档和代码

**参考**：
- [工作流生命周期：archive 阶段](../02-design/workflow-lifecycle.md#archive归档)
- [知识沉淀机制：即时捕获](../02-design/knowledge-compounding.md#即时捕获机制)

---

### D4: 为什么术语优化（落盘 → 写入，第一现场 → 即时捕获）

**决策时间**：2026-01-12

**背景**：
- 原有术语"落盘"和"第一现场"可能不够清晰
- 需要确保术语对 AI 友好，避免歧义

**选择**：
- "落盘" → "写入"
- "第一现场" → "即时捕获"

**理由**：
- **更清晰的语义**："写入"比"落盘"更直接，AI 更容易理解
- **更准确的描述**："即时捕获"比"第一现场"更准确地描述了机制
- **AI 友好**：使用更标准的术语，减少 AI 理解歧义
- **一致性**：与系统其他部分的术语保持一致

**替代方案**：
- 保留原有术语：可能造成理解困难
- 使用其他术语：可能不够准确

**影响**：
- 提高了文档的可读性
- 减少了 AI 理解的歧义
- 需要更新所有相关文档和代码

**参考**：
- [核心原则：即时捕获，分层处理](../01-concepts/key-principles.md#4-即时捕获分层处理)

---

### D5: 为什么采用 Confirm-only Knowledge Capture

**决策时间**：项目初期

**背景**：
- 需要确保知识库的质量
- 需要避免低质量信息污染知识库

**选择**：采用确认式知识捕获，未收到明确确认前不得写入长期知识库

**理由**：
- **质量控制**：避免低质量信息污染知识库
- **责任归属**：关键决策需要人的明确授权
- **上下文理解**：人比 AI 更理解项目的长期目标和约束
- **可追溯性**：所有写入都有明确的确认记录

**替代方案**：
- 自动写入：可能导致低质量信息进入知识库
- 完全手动：可能遗漏有价值的经验

**影响**：
- 提高了知识库的质量
- 增加了用户的操作步骤
- 需要设计良好的确认机制

**参考**：
- [核心原则：Confirm-only Knowledge Capture](../01-concepts/key-principles.md#3-confirm-only-knowledge-capture确认式知识捕获)
- [知识沉淀机制：确认沉淀流程](../02-design/knowledge-compounding.md#确认沉淀流程)

---

### D6: 为什么采用 Single Entrypoint

**决策时间**：项目初期

**背景**：
- 需要简化用户操作
- 需要统一系统入口

**选择**：只使用 `/flow` 一个入口驱动整个工作流

**理由**：
- **降低认知负担**：用户不需要记忆多个命令
- **统一体验**：所有操作都通过同一个入口，体验一致
- **简化路由**：系统内部统一处理路由，而不是分散到多个命令
- **易于扩展**：新增功能只需扩展 `/flow` 的参数解析

**替代方案**：
- 多个命令：增加用户学习成本
- 分散入口：难以统一管理

**影响**：
- 提高了系统的易用性
- 简化了系统架构
- 需要设计良好的参数解析机制

**参考**：
- [核心原则：Single Entrypoint](../01-concepts/key-principles.md#1-single-entrypoint单入口)
- [flow 命令实现](../03-implementation/commands/flow-command.md)

---

### D7: 为什么采用 Human Gates

**决策时间**：项目初期

**背景**：
- 需要保证过程可控
- 需要避免 AI 自动推进导致偏离预期

**选择**：关键决策点必须有人工确认，不能自动推进

**理由**：
- **过程可控**：避免 AI 自动推进导致偏离预期
- **质量保证**：关键决策需要人的判断
- **可观测性**：每个阶段切换都是明确的，便于追踪
- **可回退性**：支持阶段回退，便于纠偏

**替代方案**：
- 全自动推进：可能导致偏离预期
- 完全手动：可能降低效率

**影响**：
- 提高了过程的可控性
- 增加了用户的操作步骤
- 需要设计良好的确认机制

**参考**：
- [核心原则：Human Gates](../01-concepts/key-principles.md#2-human-gates人工闸门)
- [工作流生命周期：推进协议](../02-design/workflow-lifecycle.md#推进协议)

---

## 决策记录规范

### 记录格式

每个决策应包含：

1. **决策编号**：D1, D2, ...
2. **决策时间**：YYYY-MM-DD
3. **背景**：为什么需要这个决策
4. **选择**：最终选择是什么
5. **理由**：为什么选择这个方案
6. **替代方案**：考虑过的其他方案
7. **影响**：决策的影响和后果
8. **参考**：相关文档链接

### 更新原则

- 重大设计变更必须记录
- 决策变更需要说明原因
- 定期回顾和更新决策记录

## 总结

这些关键设计决策共同构成了 cursor-workflow 的设计基础，确保了系统的：

- **可控性**：Human Gates 和 Confirm-only Knowledge Capture
- **可维护性**：Skills-first 设计和 Single Entrypoint
- **可扩展性**：清晰的架构和职责分离
- **可理解性**：清晰的术语和文档

任何对这些决策的变更都需要：

1. 明确理由
2. 影响评估
3. 文档更新
4. 决策记录
