# 009.iteration-plan.工作流TDD迭代方案

| 属性 | 值 |
| --- | --- |
| 版本 | 1.0 |
| 状态 | 草稿 |
| 创建日期 | 2026-02-28 |
| 主题 | Req 中心化 + TDD 验证闭环 |

---

## 1. 背景与目标

当前灵犀流程已具备 `req -> plan -> build -> review` 主链路与 TDD 相关约束，但在“每条需求的验证方式显式化”“证据追踪一致性”“testcase 生成逻辑复用”上仍有优化空间。

本迭代目标：

1. 保持 `req` 作为任务事实来源（SSoT），但不引入“冻结状态”硬门禁。
2. 强化每条需求的验收标准结构，使 TDD 思路可执行、可追踪。
3. 明确 testcase 文档在 `plan` 阶段产出，并抽出可复用能力供 `build/review` 复用。
4. 将 `review` 明确为交付验收审计，而非需求再设计阶段。

---

## 2. 设计原则（最终版）

1. **Req 中心化**：任务文档承载需求定义、可行性判断、方案方向、验收标准。
2. **无冻结状态字段**：不引入“Approved/Locked”状态；是否进入下游由用户决定。
3. **实施不重定义需求**：`plan/build/review` 不新增需求范围，不改任务目标。
4. **验证优先**：每条需求必须声明验证方式与证据形式。
5. **TDD 按适用性执行**：可测逻辑走自动化优先；不适合自动化的需求必须给出可执行手工或 rubric 验证。

---

## 3. 更新后的流程职责

### 3.1 Req（定义与可验证设计）

`/req` 负责产出“可实施”的任务文档，至少包含：

1. 功能目标与边界（含非目标）。
2. 技术方向与可行性结论（架构层级）。
3. 每条需求的验收标准与验证方式。

注意：不要求在 req 阶段写测试代码，但必须写可测试规格。

### 3.2 Review-req（设计质量共审）

`/review-req` 负责审查 req 质量，不写实现细节。重点：

1. 验收标准是否可执行、可判定。
2. 验证方式是否覆盖全部需求。
3. 架构方案与约束是否足够支撑实施。

### 3.3 Plan（细化执行与 testcase 产出）

`/plan` 负责：

1. 需求到任务拆解（T）。
2. 需求到测试用例映射（F -> TC）。
3. 产出 `*.testcase.*.md`（主产出环节）。

### 3.4 Build（按规格实施与取证）

`/build` 负责：

1. 按 req/plan/testcase 实施，不重定义需求。
2. 对可测单元执行“先测再实现”循环。
3. 对手工/rubric 验证项输出可执行清单与证据占位。

### 3.5 Review（独立验收审计）

`/review` 负责：

1. 基于 req 的验收标准做独立复核。
2. 按需求编号给出 Pass/Fail 与证据。
3. 输出缺口清单并回退至 build 修复。

---

## 4. 验收标准细化方案（TDD 友好）

在 req 的“功能需求”表中新增并强制填写以下列：

| 字段 | 说明 |
| --- | --- |
| 需求编号 | F1/F2/... |
| 需求描述 | 业务行为描述 |
| 实现方案 | 关键文件 + 实现模式（指针级） |
| 验收标准 | Given-When-Then 或等价结构化描述 |
| 验证方式 | `unit` / `integration` / `e2e` / `manual` / `rubric` |
| 边界/异常 | 至少 1-2 条 |
| 证据形式 | 测试日志 / Browser 记录 / 手工记录 / 评审打分 |
| 优先级 | 必须/应该/可选 |

### 4.1 TDD 最佳实践在 req 层的落地

1. **行为先于实现**：验收标准写行为，不写函数内部细节。
2. **可判定**：每条标准可二值判断（通过/不通过）。
3. **边界显式**：至少覆盖空输入、异常输入或失败路径之一。
4. **证据前置**：在 req 阶段就定义“通过后要看到什么证据”。
5. **映射追踪**：后续 plan 必须把每条 F 映射到 TC。

### 4.2 非自动化任务的验证约定

对 UX、设计质量、文档质量等不适合脚本断言的需求：

1. 使用 `manual` 或 `rubric` 验证方式。
2. 提供可执行步骤 + 预期结果 + 评分维度。
3. review 阶段按同一 rubric 复核，避免主观漂移。

---

## 5. testcase 文档产出与复用设计

### 5.1 产出环节

1. **主产出仍在 plan**：`/plan` 生成 `*.testcase.*.md`。
2. **build 兜底补齐**：若用户跳过 plan，`/build` 可先生成最小 testcase 再实施。

### 5.2 抽取可复用 Skill：`testcase-designer`

建议新增 `testcase-designer`，由 `plan/build/review` 复用同一规则：

1. 输入：req 文档（可选 plan 文档）。
2. 输出：结构化 testcase 文档（单元/集成/E2E/手工验证区块）。
3. 核心约束：
   - 必须覆盖所有 `验证方式 != 无` 的需求。
   - 每个 TC 必须关联至少一个 F 编号。
   - 对 `manual/rubric` 自动生成执行步骤与记录模板。

### 5.3 复用关系

1. `plan-executor`：调用 `testcase-designer` 生成完整 testcase。
2. `build-executor`：读取 testcase；缺失时调用 `testcase-designer` 生成最小版。
3. `review-executor`：按相同映射规则做覆盖审计，避免口径不一致。

---

## 6. 规则变更清单（按组件）

### 6.1 req-executor 与模板

更新：

1. `.cursor/skills/req-executor/SKILL.md`
2. `.cursor/skills/req-executor/references/req-doc-template-full.md`
3. `.cursor/skills/req-executor/references/req-doc-template-simple.md`

改动要点：

1. 强制每条 F 填写验证方式/验收标准/证据形式。
2. 在质量自检中加入“是否覆盖全部需求验证方式”。
3. 明确不引入冻结状态，是否进入下游由用户决定。

### 6.2 review-req-executor

更新：

1. `.cursor/skills/review-req-executor/SKILL.md`

改动要点：

1. 新增检查项：每条 F 是否有验证方式与可判定验收标准。
2. 新增检查项：manual/rubric 项是否有可执行验证步骤。
3. 输出中增加“实施准备度”结论（可继续 plan/build，但不做硬阻断）。

### 6.3 plan-executor

更新：

1. `.cursor/skills/plan-executor/SKILL.md`
2. `.cursor/skills/plan-executor/references/testcase-doc-template.md`
3. `.cursor/skills/plan-executor/references/plan-doc-template.md`

改动要点：

1. 强制生成 `F -> T -> TC` 追踪关系。
2. testcase 模板增加“来源需求编号 Fx”字段。
3. 统一使用 `testcase-designer` 产出 testcase。

### 6.4 build-executor

更新：

1. `.cursor/skills/build-executor/SKILL.md`

改动要点：

1. 保持 TDD 循环用于 `unit/integration` 可测单元。
2. 对 `e2e` 优先使用 Browser 自动化冒烟或完整流程。
3. 对 `manual/rubric` 生成执行清单与证据占位。
4. 缺少 testcase 时调用 `testcase-designer` 先补齐最小 testcase。

### 6.5 review-executor 与报告模板

更新：

1. `.cursor/skills/review-executor/SKILL.md`
2. `.cursor/skills/review-executor/references/review-report-template.md`

改动要点：

1. 明确 review 定位为“独立验收审计”。
2. 审计结果按需求编号输出：`F1/F2/... -> Pass/Fail -> 证据`。
3. 不在 review 阶段新增需求或改范围。

### 6.6 新增 skill

新增：

1. `.cursor/skills/testcase-designer/SKILL.md`
2. `.cursor/skills/testcase-designer/references/testcase-doc-template.md`（可复用现有模板后迭代）

---

## 7. 分阶段落地计划

### Phase 1（最小可用）

1. 先改 req 模板与 req/review-req 规则。
2. 目标：每条需求具备验证方式与验收标准。

### Phase 2（一致性增强）

1. 改 plan/testcase 模板，加入 `F -> TC` 映射。
2. 目标：验证链路可追踪。

### Phase 3（能力复用）

1. 抽出 `testcase-designer` 并接入 plan/build/review。
2. 目标：消除多处规则漂移。

### Phase 4（审计收口）

1. 改 review 报告模板为“按需求编号验收”。
2. 目标：交付结论可审计、可追责。

---

## 8. 验收标准（本迭代）

1. req 文档中每条 F 都有验证方式与证据形式。
2. plan 产出的 testcase 能覆盖所有 F（含 manual/rubric）。
3. build 输出可追踪证据，不再仅给口头“已通过”。
4. review 报告可按 F 编号给出 Pass/Fail 与证据引用。
5. 全流程不引入“需求冻结状态”硬门禁。

---

## 9. 结论

该方案在不改变你核心理念（req 中心化、实施不质疑需求、用户自行决定进入下游）的前提下，补齐了 TDD 与验证闭环的关键缺口。核心增量不是增加流程环节，而是统一“可验证规格”和“证据追踪”。
