# 品味识别与沉淀 — 迭代大纲

| 属性 | 值 |
| --- | --- |
| 版本 | 1.0 |
| 状态 | 草稿（待边讨论边细化） |
| 创建日期 | 2026-02-24 |
| 关联任务 | 008.req.记忆升维治理 |
| 文档用途 | 与 008 配合的上游设计：定义「品味」、识别模式与沉淀策略，供后续对照细化 |

**变更说明（TasteKey 已移除）**：TasteKey 设计已从系统中彻底删除。「不再问」逻辑改为 memory-retrieve 统一检索：拟提问前调用 `/memory-retrieve <决策点描述>`，其中决策点描述由 Agent 用自然语言构建；若检索到相关记忆且能覆盖当前选择，则不再问、直接按该记忆行为。检索依赖 Title、When to load 及 notes 正文，不再使用精确键匹配。详见 memory-retrieve SKILL 及各环节 taste-sniff-rules。

---

## 1. 背景与问题定位

### 1.1 与 008 任务的关系

| 层次 | 008 任务负责 | 本大纲负责（008 上游） |
| --- | --- | --- |
| 范围 | 记忆**写成之后**：何时写细节/原则、质量门槛、生命周期治理 | 记忆**从哪来**：什么是品味、如何从对话/行为中识别并产出候选记忆 |
| 输入 | 已有「候选记忆」 | 用户与 agent 的对话、行为、选择 |
| 输出 | 写/不写、L0/L1、Active/Local/Archive | 结构化的「品味」表达 → 作为 008 的输入 |

结论：008 解决「写什么形态、如何治理」；本大纲解决「什么是品味、如何识别并形成可写入的候选」。二者衔接后，才能完整检验「用户品味的有效提取」。

### 1.2 当前缺口

- 灵犀记忆库在**技术流程**上已跑通（检索、写入、治理管线存在）。
- **用户「品味」的有效提取**尚未经过系统性定义与有效性检验。
- 首要问题：如何定义「品味」、如何定义一套「品味识别模式」，从而从用户与 agent 的对话中有效提取品味。

### 1.3 本次重构任务范围

本迭代大纲所涉重构包含以下部分，均属同一任务：

| 部分 | 内容 | 文档位置 |
| --- | --- | --- |
| 品味识别与沉淀管线 | 三大触发点、payload 规范、所有写入先经品味识别、lingxi-memory 只接受 payload | §4.4、§5、§6 |
| 品味 payload 规范 | scene, principles, choice, evidence, source, confidence, apply | §6.4 |
| payload → note 映射 | 从 payload 生成 note 各字段的规则（含 Title、Scope、Supersedes） | §6.5 |
| 「不再问」逻辑 | 已改为 memory-retrieve 统一检索（TasteKey 已移除） | 见变更说明、memory-retrieve |
| **Note 结构优化** | 补齐缺口、去冗余、消歧义，使 note 与 INDEX 对齐、映射规则可执行 | §6.6、memory-note-template |

---

## 2. 品味的定义（工作定义）

### 2.1 核心表述

**品味**：在**给定场景**下，在一组**可能适用甚至冲突的原则**中，用户（或开发者）**实际采用的选择与权衡**（含显式理由或可从行为推断的理由）。

- 优秀开发经验多已被总结为原则（如 DRY、KISS、YAGNI、SoC）。
- 原则的**适用场景、范围**不同，有时**互相冲突**（如「先简单」vs「预留扩展」）。
- **在具体场景下选哪条原则、如何权衡**，即开发者的开发「品味」。

### 2.2 品味的三要素（可操作结构）

| 要素 | 说明 | 示例 |
| --- | --- | --- |
| **场景** | 决策发生的上下文、约束、阶段 | 方案设计阶段、文档引用方式、命名风格 |
| **可选/冲突的原则** | 该场景下可用的候选原则或策略 | KISS vs 可扩展性、短引用 vs 完整路径 |
| **选择与权衡** | 实际采纳的策略及（显式或隐式）理由 | 优先短引用、避免暴露实现路径 |

「品味识别」的目标：从对话/行为中抽取出上述三要素，形成可写入记忆的结构化表述。

### 2.3 与 008 的 L0/L1 对应

- 识别出的**具体选择**（如「这次选了 A」）→ 可对应 **L0 事实层**。
- 识别出的**可复用策略/原则**（如「在 X 类场景下优先 A」）→ 可对应 **L1 原则层**。
- 008 的评分卡与升维规则再对这些候选做「写/不写、单层/双层」的判定。

---

## 3. 相邻知识框架（借鉴与启发）

以下框架用于支撑「品味」的建模与识别，**无现成「品味识别模式」标准答案**，可组合为设计参考：

| 框架 | 要点 | 对灵犀的启发 |
| --- | --- | --- |
| **设计理性（Design Rationale）** | 记录决策、选项、取舍与理由 | 品味可视为「个人化的设计理性」，用「决策+理由+上下文」做结构化 |
| **隐性知识（Tacit Knowledge）** | 专家直觉难以言传，需在行为中显性化 | 从用户接受/拒绝/改写等行为反推原则偏好，即隐性品味的显性化 |
| **设计品味（Design Taste）** | 在约束下做质量/审美判断，含「何时打破规则」 | 品味 = 原则在情境下的运用与例外，而不仅是「知不知道原则」 |
| **Code Review / Linter 例外** | 何时关规则、为何例外 | 「例外 + 理由」是原则-场景-选择的可观测信号 |
| **情境认知（Situated Cognition）** | 知识绑在情境，迁移依赖情境相似度 | 品味建模为「原则 + 场景」组合，检索时匹配情境 |

---

## 4. 双通道策略：如何收集品味

采用两条互补通道，既做**显式收集**（选择题），也做**隐式识别**（品味提取）。

### 4.1 通道一：专用「品味识别」Skill（隐式识别）

| 项目 | 内容 |
| --- | --- |
| **定位** | 从**自由对话与行为**中识别品味，产出 §6.4 品味 payload，封装复杂识别逻辑 |
| **输入** | 按触发点不同：本轮用户输入、/remember 指定范围、/init 确认后的草稿等（见 §4.4） |
| **输出** | 有可沉淀时产出且仅产出 §6.4 的 7 字段 payload；无可沉淀时静默（不调用 lingxi-memory） |
| **难点** | 用户常不显式说「我选的是 KISS」，需从改法、评论、拒绝理由中推断 |
| **触发点** | 见 §4.4；输出 schema 已定稿（§6.4） |

### 4.2 通道二：各环节中的「品味选择题」（显式收集）

| 项目 | 内容 |
| --- | --- |
| **思路** | 在开发流程各环节的 skills 中，在**真实决策点**嵌入轻量「选择题」；用户选择即沉淀偏好，**已沉淀过的偏好不再询问** |
| **优点** | 显式、高置信；按需出现、不重复打扰；选项自然绑定场景，便于写 L0/L1 |
| **原则** | 仅当 agent 确实要在若干原则/方案间做选择，且**当前无记忆可依**时，才弹出选择 |
| **状态** | 待细化：选择点清单、选项与原则的映射、记忆键设计、与各 skill 的嵌入方式 |

### 4.3 双通道分工

| 通道 | 主要作用 | 输出特点 |
| --- | --- | --- |
| **品味提取 Skill** | 处理用户主动表达或行为中体现的偏好 | 非结构化 → 结构化，需推断，置信度依赖模型与规则 |
| **环节选择题** | 在真实决策点主动询问，一次选择即一条高置信偏好 | 结构化、可解释，直接对应「场景 + 原则 + 选择」 |

二者共同填充「用户品味画像」，记忆写入后统一走 008 的升维与生命周期治理。

### 4.4 品味识别 skills 的三大触发点（定稿）

所有写入记忆的路径必须先经品味识别；品味识别由以下三种方式触发，产出统一为 §6.4 payload，再由主 Agent 用该 payload 调用 lingxi-memory。

| 触发点 | 谁触发 | 品味识别输入 | payload.source | payload.confidence 约定 |
| --- | --- | --- | --- | --- |
| **1. Session 注入约定** | 主 Agent 每轮按 session 约定调用 | 本轮用户自由输入；可选最近 1～2 轮对话片段。仅当存在用户自由输入时才调用。 | `auto` | 由品味识别根据证据强度判定 low/medium/high |
| **2. /remember command** | 用户执行 /remember 后，主 Agent 显式调用 | 当前轮用户输入，或用户指定的「要记住的内容/对话范围」 | `remember` | 通常为 medium 或 high；用户明确指定原文时可设 high |
| **3. /init command** | init command 在用户确认写入记忆时，委托主 Agent 或直接调用 | /init 流程中用户确认后的草稿（类型化收集结果、目标/非目标、用户与流程、风险、发布方式等）；可按「一条记忆一个 payload」拆成多条 | `init` | 用户已确认的草稿建议 high；未完全确认的项可 medium |

**约定**：

- Session 注入文案（如 `session-init.mjs` 的 PRECIPITATE_CONTEXT）中明确：每轮在回答前先执行 memory-retrieve，再**按约定调用品味识别 skills**；若品味识别产出 payload，用该 payload 调用 lingxi-memory，禁止用原始对话片段直接调 lingxi-memory。
- /remember、/init 的 Command/Skill 文档中明确：写入前**必须先调用品味识别 skills**，将当前输入（或 init 草稿）转为 §6.4 payload 后，再调用 lingxi-memory。
- 品味识别 skills 的 SKILL.md 中说明：可在三种触发场景下被调用，输入形态见上表，输出统一为 §6.4。

---

## 5. 整体设计结构（改造后）

改造后的记忆沉淀管线如下，session 注入约定驱动每轮流程，品味识别与 lingxi-memory 分工明确。

### 5.1 端到端流程

```
session 注入约定（每轮）
    │
    ▼
每轮用户输入后：先执行 /memory-retrieve，再按约定调用「品味识别 skills」
    │
    ├── /remember：先经品味识别 skills 产出 payload，再调用 lingxi-memory
    ├── /init 写入记忆：用户确认草稿后，先经品味识别 skills 将草稿转为 payload（可多条），再调用 lingxi-memory
    │
    ▼
品味识别 skills：判断本轮是否存在可沉淀偏好
    │
    ├── 无 ──► 静默，不调用 lingxi-memory
    │
    └── 有 ──► 产出品味 payload（§6.4 规范）
                    │
                    ▼
             主 Agent 使用该 payload 显式调用 lingxi-memory（mode=auto 或 remember）
                    │
                    ▼
             lingxi-memory：校验 → 由 payload 映射生成 note 字段（缺则补全）→ 治理（近邻 TopK）
                    │
                    ▼
             门控（有条件必选）：
               · merge / replace → 必须 ask-questions 门控，不得静默
               · new → 高可靠性可静默写入，低可靠性必须 ask-questions 门控
                    │
                    ▼
             写入 notes + INDEX，并追加记忆审计
```

### 5.2 门控规则说明

- **非「可选门控」**：merge/replace 始终必须经用户确认；new 仅在「高可靠性」时可静默，其余须门控。
- 约定写入文档时需与 `.cursor/agents/lingxi-memory.md` 中「用户门控格式」「new 路径可靠性分流」保持一致。

### 5.3 Session 注入约定的改造要点

- **当前**：约定要求主 Agent 自行判断「是否可沉淀」并自行构造结构化 input 后调用 lingxi-memory。
- **改造后**：约定改为「每轮（及 /remember 时）先调用品味识别 skills；若 skills 发现可沉淀偏好，使用其输出的结构化 payload 调用 lingxi-memory」。
- 具体文案与注入位置（如 `session-init.mjs` 中的 PRECIPITATE_CONTEXT）在实现阶段细化。

---

## 6. lingxi-memory 与品味识别 skills 的责任边界

责任边界决定谁负责「从对话里认品味」、谁负责「从候选到落库」，并驱动二者之间的**参数格式**设计。

### 6.1 品味识别 skills 的责任（上游）

| 责任 | 说明 |
| --- | --- |
| **判断是否可沉淀** | 基于本轮用户自由输入（及可选的本轮对话片段），判断是否出现可沉淀的偏好/约束/取舍；不依赖 command 模板、系统注入、工具输出作为依据。 |
| **提炼证据与主张** | 从用户原文或行为中抽取 scene、principles、choice，以及可选的 evidence（一句原文）；产出 §6.4 的 7 字段 payload。 |
| **产出品味 payload** | 输出必须符合 **品味 payload 规范**（§6.4）：scene, principles, choice, evidence, source, confidence, apply；主 Agent 用该 payload 直接调用 lingxi-memory。 |
| **不负责** | 不做治理（merge/replace/veto/new）、不做门控、不读写记忆库文件；不解释「为何与某条已有记忆冲突」。 |

**输出形态**：有可沉淀时产出且仅产出 §6.4 定义的 7 字段 payload；无可沉淀时静默不调用 lingxi-memory。

### 6.2 lingxi-memory 的责任（下游）

| 责任 | 说明 |
| --- | --- |
| **输入校验** | 仅接受 §6.4 品味 payload；必填字段缺失或非法时拒收并返回原因。 |
| **映射与补全** | 由 payload（scene, principles, choice, evidence, apply）生成 note 字段（title, whenToLoad, oneLiner, decision, signals, Audience/Portability 等）；缺项时仅对缺失部分做只读上下文补全，不产候选。 |
| **治理** | 对 memory/notes/ 做语义近邻 TopK，决策 merge / replace / veto / new。 |
| **门控** | merge/replace 必走 questions；new 按 payload.confidence 分流：high 可静默，medium/low 必 questions。 |
| **写入与审计** | 直接读写 notes 与 INDEX，并追加记忆审计行。 |
| **不负责** | 不产候选、不从原始对话做品味识别；假定上游始终提供 §6.4 payload。 |

### 6.3 边界小结与对参数设计的影响

| 维度 | 品味识别 skills | lingxi-memory |
| --- | --- | --- |
| **输入** | 本轮用户输入、可选对话片段、/remember 或选择题的上下文 | §6.4 品味 payload（唯一合法 input） |
| **输出** | §6.4 payload，或「无可沉淀」 | 一句回传主对话；内部映射、治理、门控、写文件 |
| **谁决定「写不写」** | 只决定「有没有可沉淀」并产出 payload；不决定最终是否落库 | 治理 + 门控（含 confidence）后决定是否写入、合并或替换 |
| **参数格式** | 输出 = §6.4 定义的 7 字段（scene, principles, choice, evidence, source, confidence, apply） | 仅接受 §6.4 payload，据此映射生成 note，不兼容旧 input 结构 |

**后续设计要点**：品味识别与 lingxi-memory 之间采用统一的**品味 payload 规范**（见下 §6.4）；lingxi-memory 仅接受该 payload，不再产候选，只做校验 → 映射 → 治理 → 门控 → 写入。

### 6.4 品味 payload 规范（最终版）

所有写入路径必须先经品味识别；品味识别产出的**唯一合法**形态即下述 payload。lingxi-memory 只接受此结构，据此生成 note 字段并进入治理，不产候选。

#### 6.4.1 字段定义

| 字段 | 类型 | 必选 | 说明 |
| --- | --- | --- | --- |
| `scene` | string | 是 | 场景（何时/何类情境），可具体可抽象；下游据此生成 whenToLoad、L0/L1 的「场景」或「场景族」。 |
| `principles` | string[] | 是 | 原则或选项，通常 1～2 项；与 choice 共同表达「在哪些候选中做了选择」。 |
| `choice` | string | 是 | 实际选择，须与 principles 中某一项一致或等价表述。 |
| `evidence` | string | 否 | 一句用户原文或引用，用于可验证性及 L0 事实层；无则省略。 |
| `source` | enum | 是 | `auto` \| `remember` \| `choice`，写入路径，供审计与分流。 |
| `confidence` | enum | 是 | `low` \| `medium` \| `high`，供门控：high 可静默 new，medium/low 须 questions。 |
| `apply` | enum | 否 | `personal` \| `project` \| `team`，适用范围；缺省时下游可推断或默认 project。team = 团队级、可跨项目共享。 |

#### 6.4.2 示例

```json
{
  "scene": "文档中引用 Skill 时",
  "principles": ["短引用", "完整路径"],
  "choice": "短引用",
  "evidence": "不要写完整路径",
  "source": "auto",
  "confidence": "high",
  "apply": "team"
}
```

#### 6.4.3 与 008 L0/L1 的对应

- **L0（实例事实）**：由 `scene`（具体场景）+ `choice` + `evidence` 生成；evidence 为可验证依据。
- **L1（可复用原则）**：由 `scene`（场景族）+ `principles` + `choice` 生成「优先 X、避免 Y」类表述。
- 同一 payload 可支撑 L0、L1 或双层；具体写哪一层由下游按 008 评分卡决定，payload 不增加 layer 字段。

#### 6.4.4 与灵犀记忆库「团队/跨项目」的对应

- `apply` 映射到 note 的 Audience / Portability / Scope：
  - `personal` → 个人，不共享或本机；
  - `project` → 本项目（project-only）；
  - `team` → 团队级、可跨项目共享（audience=team, portability=cross-project）。

#### 6.4.5 门控

- merge/replace：一律 questions，与 confidence 无关。
- new：`confidence === "high"` 可静默写入；`medium` / `low` 必须 questions。

### 6.5 payload → note 的映射规则（定稿）

lingxi-memory 收到 §6.4 payload 后，**仅**做字段映射与缺失补全，不产候选。以下为从 payload 到 memory-note-template 各部分的生成规则。

#### 6.5.1 Meta

| note 字段 | 来源 | 规则 |
| --- | --- | --- |
| Id | lingxi-memory 生成 | MEM-&lt;id&gt;，唯一 |
| Title | payload.scene + choice | 短标题，与 INDEX Title 一致；公式：`[scene] 下优先 [choice]` 或等价缩写（如「文档引用：短引用」） |
| Kind | 规则 | payload.source=init 且为类型化草稿 → `decision` 或 init command 附录 init-checklists 约定；choice 为原则名且 scene 泛化 → `principle`；其余默认 `decision`，按内容可选 heuristic/pattern |
| Status | 固定 | 新建为 `active`；生命周期治理见 008 |
| Strength | 规则 | payload.source=init 且用户已确认 → `validated`；用户表述含「必须」「一定」类 → `enforced`；其余默认 `validated` |
| Scope | 规则（由 apply 主导） | payload.apply=team → `broad`；apply=project 或 personal 默认 `medium`；scene 极窄（单文件/单次）→ `narrow` |
| Audience | payload.apply | `personal`/`project`/`team` 直接写入 |
| Portability | payload.apply | personal/project → project-only；team → cross-project |
| Source | payload.source | `auto`/`remember`/`init` 直接写入 |
| Tags | 可选 | 由 scene/choice 抽自由关键词 |
| Supersedes | 治理时填写 | 新建时留空；merge/replace 时填被取代的 MEM-xxx，与 INDEX 同步 |
| CreatedAt/UpdatedAt/Session | lingxi-memory | 写入时生成 |

#### 6.5.2 When to load

- **规则**：由 `payload.scene` 生成 1～3 条自然语言，描述**何时加载**（情境），与 One-liner 分工：此处偏「何时」，One-liner 偏「做什么」。
- **示例**：scene 为「文档中引用 Skill 时」→ When to load 为「在文档或 SKILL 中引用某能力时」「编写或评审引用表述时」。避免与 One-liner 同句重复。

#### 6.5.3 One-liner (for injection)

- **规则**：在 `scene` 下优先/采用 `choice`；若有拒绝类，可写成「在 scene 下避免 X」或「优先 choice」。偏**具体做什么/不做什么**，不与 When to load 同义重复。
- **公式**：`在 [scene] 下优先 [choice]` 或 `在 [scene] 下避免 [principles 中非 choice 的一项]`；反例类用 Counter-signals 或 One-liner 表达禁止。

#### 6.5.4 Context / Decision

| note 字段 | 来源 | 规则 |
| --- | --- | --- |
| Decision | payload.principles + choice | 当时在判断什么：在 principles 之间做选择，采纳了 choice。 |
| Signals | 可选补全 | 可观测信号分叉；缺则可由 scene 推断或留空。 |
| Alternatives | payload.principles | 拒绝了哪些：principles 中除 choice 外的项。 |
| Counter-signals | 可选 | 何时不适用；可由 evidence 或 scene 边界推断。 |

#### 6.5.5 Pointers

- 若有 payload.evidence 且可对应到文件/模块，可写一句简短指针；否则可留空或由上下文补全时补。

#### 6.5.6 L0/L1 书写形态（008 层）

- **L0（实例事实）**：用 `scene`（具体化）+ `choice` + `evidence` 生成一句「在 [具体场景] 下发生了 [选择/操作]，[证据]」。
- **L1（可复用原则）**：用 `scene`（场景族）+ `principles` + `choice` 生成「在 [场景族] 中优先 [choice]，避免 [反策略]」。
- 是否写 L0、L1 或双层由 008 评分卡在治理/升维阶段决定；本映射仅保证 payload 含足够信息即可生成二者。

### 6.6 Note 结构优化（本次重构一部分）

为消除缺口、冗余与歧义，将 **note 结构优化** 纳入本次重构，与品味 payload、映射规则、记忆键一并落地。模板与 INDEX 的变更以 `.cursor/.lingxi/memory/references/memory-note-template.md` 为 SSoT；映射规则见 §6.5。

#### 6.6.1 已解决的缺口

| 问题 | 处理 |
| --- | --- |
| **Title 未定义** | 在 template Meta 与 §6.5.1 中增加 **Title**；约定由 payload.scene + choice 生成短标题，与 INDEX Title 列一致。 |
| **Supersedes 仅 INDEX 有** | 在 template Meta 增加可选 **Supersedes**；merge/replace 时由 lingxi-memory 填写被取代的 MEM-xxx，与 INDEX 同步。 |
| **TasteKey 已移除** | 原 TasteKey 设计已删除；检索依赖 Title、When to load 及 notes 正文。 |

#### 6.6.2 已消除的冗余与歧义

| 问题 | 处理 |
| --- | --- |
| **Scope 与 apply 重叠** | Scope 改为由 **apply 主导**的规则：team→broad，project/personal 默认 medium，scene 极窄→narrow；与 Audience/Portability 分工明确。 |
| **When to load 与 One-liner 都含 scene** | 在 template 与 §6.5.2/6.5.3 中约定**表述分工**：When to load 偏「何时加载」，One-liner 偏「做什么/不做什么」，避免同句重复。 |
| **Tags** | 自由关键词，用于检索与筛选。 |
| **Kind/Strength/Scope 纯推断** | 在 §6.5.1 中改为**可执行规则**（source/apply/用户表述），减少不一致。 |

#### 6.6.3 模板与 INDEX 的同步

- **template**：已增加 Title、Supersedes；Status 含 local/archive（生命周期）；结构约定见 template 顶部。TasteKey 已移除。
- **INDEX**：表头需与 template Meta 对齐，至少包含 Id, Kind, **Title**, When to load, Status, Strength, Scope, Supersedes, CreatedAt, UpdatedAt, Source, Session, File。实现时按 memory-system 与 lingxi-memory 的 INDEX 约定更新。

#### 6.6.4 实施责任

- 更新 **memory-note-template.md**：已完成（见本仓库该文件）。
- 更新 **lingxi-memory** 与 **INDEX 读写逻辑**：写入/更新 note 与 INDEX 时按新 Meta 字段（Title、Supersedes）执行；治理时填写 Supersedes。TasteKey 已移除。
- **memory-retrieve**：检索使用 Title、When to load 及 notes 正文做语义+关键词混合检索；嗅探场景可传入 Agent 构建的决策点描述。

---

## 7. 环节品味嗅探与记忆键

以下为情境驱动的品味嗅探规则；**非固定触发点**，以各环节内**是否出现规则所描述的情境**为准。TasteKey 已移除，「不再问」改为 memory-retrieve 统一检索。

### 7.1 品味嗅探规则（T2 定稿）

- **定位**：不在流程中设固定「第几步弹哪道题」；而是在各环节内，当**相邻知识框架中的一种或多种待决策场景**出现时，视为可嗅探品味的时机，必要时用 ask-questions 向用户提问并根据反馈提取品味。
- **落地方式**：在各环节 Skill 的 **references** 中增加一份**本环节专用的品味嗅探规则**（如 `taste-sniff-rules.md` 或合并进现有 ref），罗列：本环节当出现哪些情况时可主动提问、问什么、如何从用户反馈提取品味。
- **可命名的原则或策略**：各条嗅探规则中应**提前确定**该情境下**可命名的原则或策略**（即 payload.principles 的候选集、payload.choice 的取值空间）；用户表述或 questions 选项再映射到这些预定义项，以稳定产出 §6.4 payload 并便于 L1 升维。原则/策略名称由各环节在规则文件中 per-rule 定义，不依赖事后推断。
- **问题性质**：以**设计理念、取舍理由、例外规则、设计品味**等为主；**不**以「如何引用 skills」等执行细节作为默认提问。仅当用户**已表达为可复用规则**时（如引用方式、表述风格），才尝试提取，不作为固定选择点。
- **不再问**：拟提问前调用 memory-retrieve，传入 Agent 构建的决策点描述；若命中相关记忆则不再问（见 §7.2）。

#### 7.1.1 规则文件内容结构

各环节的品味嗅探规则建议至少包含：

| 要素 | 说明 |
| --- | --- |
| **情境描述** | 本环节可能出现、且值得抽品味的**情境/信号**（自然语言或简短 checklist），便于 agent 做语义匹配。 |
| **可命名的原则/策略** | 该条规则下**预定义**的 principles 候选（如「体验优先」「成本可控」）及 choice 取值（或选项文案与 principle 的对应）；用户表述/选项映射到这些预定义项后填 payload。 |
| **是否提问** | 该情境下「静默从对话抽」还是「主动用 ask-questions 问」（如用户选了非推荐项 → 主动问理由）。 |
| **问什么** | 若提问，questions 的意图与措辞（如「请简短说明您选择该方案的主要考虑」）；选项宜与上述可命名原则/策略对齐。 |
| **如何提取** | 从用户回答或本轮对话中映射到预定义 principles/choice，填 payload（scene/principles/choice/evidence）。 |

#### 7.1.2 各环节嗅探规则示例（示意）

以下为按**相邻知识框架**归纳的待决策场景示例；具体条目由各环节 references 维护，此处仅作结构参考。

| 环节 | 规则文件位置（示意） | 情境类型 | 可命名的原则/策略（示例） | 何时考虑提问 | 提问/提取意图 |
| --- | --- | --- | --- | --- | --- |
| req | req-executor/references/ | 用户明显重体验、轻实现成本 | principles：体验优先 / 成本可控；choice 取其一或用户表述映射 | 需求/约束中出现「体验优先」「可多花成本」等信号 | 确认设计理念；映射到预定义 principles/choice 后沉淀 |
| req | 同上 | 用户强调复用、抽象、组件化 | principles：复用优先 / 先实现再抽象；choice 取其一 | 需求中出现「抽公共」「避免重复」「组件化」等 | 确认倾向；映射到预定义项后沉淀 |
| plan | plan-executor/references/ | 用户在多个方案中选了非推荐项 | 由用户理由归纳为 principles 与 choice；规则中预定义常见维度（如可维护性/性能/工期） | Agent 给出推荐 A，用户明确选 B | 用 questions 问选择理由；从理由映射到预定义或归纳 principles/choice、evidence |
| plan | 同上 | 方案在简单实现 vs 扩展性之间取舍 | principles：先简单实现 / 预留扩展点；choice 取其一 | 讨论中出现「先简单」或「预留扩展」等 | 可问倾向或从对话抽；映射到预定义项后沉淀 |
| build | build-executor/references/ | 实现/重构中强调复用或抽象 | 同 req 复用/组件化情境的 principles；可与 req 对齐 | 用户要求抽组件、提公共逻辑等 | 映射到预定义 principles/choice 后沉淀 |
| build | 同上 | 用户做了与常规规范不一致的写法 | principles：遵守规范 / 例外有据；choice + 例外条件（counter-signals） | 用户坚持某种写法或绕过某条规范 | 问原因或例外条件；映射到预定义项或例外规则 |
| review | review-executor/references/ | 用户对某条问题做了例外处理 | principles：必须修复 / 接受风险/例外；choice + 适用边界 | 不修、接受风险或特殊处理 | 问例外理由与边界；映射到预定义项后沉淀为例外规则 |
| review | 同上 | 用户给出明确的风格/规则类建议 | 由用户表述归纳为可命名原则（如「布局先考虑可访问性」）；规则中可预列常见设计维度 | 如「这类情况都建议…」「布局应…」 | 归纳或映射到预定义 principles/choice 后沉淀设计品味 |
| 通用/文档 | 按需 | 用户将引用方式/表述风格表达为可复用规则 | 预定义如：短引用 / 完整路径；仅当用户已明确为规则时使用 | 仅当用户已明确为规则时 | 抽则映射到预定义项后沉淀；**不作为默认固定提问** |

### 7.2 「不再问」逻辑（TasteKey 已移除）

**变更**：TasteKey 设计已从系统中彻底删除。「不再问」改为 memory-retrieve 统一检索。

- **不再问**：拟提问前调用 `/memory-retrieve <决策点描述>`，其中决策点描述由 Agent 用自然语言构建（如「在方案对比中，用户更倾向于体验优先还是成本可控？」）；若检索到相关记忆且能覆盖当前选择，则不再问、直接按该记忆行为。
- **检索**：memory-retrieve 对 Title、When to load 及 notes 正文做语义+关键词混合检索；品味跨场景可用，不依赖精确键匹配。

### 7.3 选项与原则的对应（T4 定稿）

- 各环节嗅探规则中**提前确定**该条规则下可命名的原则或策略（principles 候选集、choice 取值或选项与 principle 的对应）；用户表述或 questions 选项**映射到这些预定义项**后填 payload.principles / payload.choice，无需单独维护全局映射表。
- 实施方式：在 §7.1.1 规则文件内容结构中，每条规则包含「可命名的原则/策略」要素；各环节在 references 的品味嗅探规则里 per-rule 定义，见 §7.1.2 表示例。

### 7.4 用户体验与兜底（T6 定稿）

- **跳过**：用户选择「暂不选择 / 跳过」或「交给 agent 决定」时，**按 agent 默认处理方式继续**当前流程；不写记忆，不阻塞任务。
- **重复提问**：**相同问题在本轮对话中不再重复提问**；同一情境类型+原则维度在本轮若已问过（无论用户选具体选项还是跳过），本轮内不再弹第二次。
- 下一轮或新会话中，若再次命中同一情境且仍无记忆，可再次提问（或由品味识别从对话中补全）。

### 7.5 与记忆系统的衔接

- 嗅探后产出的 payload 经品味识别/写入路径交 lingxi-memory 写入，遵循 008：可抽象则写 L1（可选带 L0），经评分卡与生命周期治理；Source=choice 时见 T5 约定（不设单独标签/类型）。

---

## 8. 与 008 的衔接关系

```
对话/行为 ──► [品味提取 Skill] ──┐
                                 ├──► 候选记忆 ──► [008：评分卡 + L0/L1 + 生命周期] ──► 记忆库
环节品味嗅探 ──► [情境命中时提问 + 记忆检索] ──┘
```

- **008**：不定义「什么是品味」，只对**已形成的候选记忆**做质量判定与形态治理。
- **本大纲**：定义品味、双通道产出候选；候选进入 008 流程后，与现有记忆规范一致。
- **有效性检验**：008 的 S5（原则层记忆命中率）等可作为「品味沉淀是否有效」的事后指标；事前依赖本大纲的「品味识别模式」与各环节品味嗅探规则。

---

## 9. 待细化清单（可对照讨论）

| 编号 | 待细化项 | 说明 / 状态 |
| --- | --- | --- |
| T1 | 品味识别 Skill 的触发点与输入 | **已形成方案** §4.4：三触发点（session 注入、/remember、/init），输入见各触发点表格 |
| T2 | 品味嗅探规则 | **已形成方案** §7.1：各环节 references 增加品味嗅探规则（情境描述、是否提问、问什么、如何提取）；非固定触发点、以情境为准；示例表见 §7.1.2；执行细节类（如引用方式）仅当用户已表达为可复用规则时才抽 |
| T3 | 「不再问」逻辑 | **已更新** §7.2：TasteKey 已移除；改为 memory-retrieve 统一检索，拟提问前传入 Agent 构建的决策点描述 |
| T4 | 选项与原则映射表 | **已形成方案** §7.1、§7.3：在各环节嗅探规则中提前确定可命名的原则/策略，per-rule 定义；用户表述/选项映射到预定义项后填 payload |
| T5 | 选择题记忆条目的标签或类型 | **已关闭**：不单独设标签/类型；用 Source=choice 识别，Kind 表内容形态；Tags 仅自由关键词，不与 Source 重复 |
| T6 | 「跳过」与重复询问策略 | **已形成方案** §7.4：跳过则按 agent 默认方式继续、不写记忆；相同问题在本轮对话中不再重复提问 |
| T7 | payload → note 的映射规则 | **已形成方案** §6.5：Meta/When to load/One-liner/Decision 等生成规则，含 Title、Supersedes（TasteKey 已移除） |
| T8 | Note 结构优化 | **已形成方案** §6.6、memory-note-template：补齐 Title/Supersedes，去冗余与歧义，与 INDEX 对齐；属本次重构一部分 |

---

## 10. 变更与修订记录

| 日期 | 版本 | 变更说明 |
| --- | --- | --- |
| 2026-02-24 | 0.1 | 初稿：汇总讨论中的品味定义、双通道策略、设计要点与待细化项 |
| 2026-02-24 | 0.2 | 新增 §5 整体设计结构（改造后）、§6 lingxi-memory 与品味识别 skills 责任边界；门控规则说明；待细化清单增加 T7 |
| 2026-02-24 | 0.3 | 定稿品味 payload 规范（§6.4）：scene, principles, choice, evidence, source, confidence, apply；支撑 L0/L1 与团队/跨项目；lingxi-memory 仅接受该 payload、不产候选；更新流程与责任描述及 T1/T7 |
| 2026-02-24 | 0.4 | 定稿三大触发点（§4.4）、payload→note 映射规则（§6.5）、记忆键设计（§7.2）；待细化清单 T1/T3/T7 标为已形成方案，T3 标注优先落地 |
| 2026-02-24 | 0.5 | Note 结构优化纳入本次重构：template 增加 Title/TasteKey/Supersedes、Status 含 local/archive、结构约定；§6.5 映射规则补全 Title/Scope/Kind/Strength/Supersedes 及表述分工；新增 §1.3 重构范围、§6.6 Note 结构优化；待细化清单 T8 |
| 2026-02-24 | 0.6 | T5 关闭：选择题记忆不设单独标签/类型，统一用 Source=choice + TasteKey + Kind |
| 2026-02-24 | 0.7 | T2 定稿：固定触发点改为各环节品味嗅探规则（§7.1）；情境驱动、references 内规则文件、情境类型+原则维度生成 taste_key；§7.2 与 7.3 同步；执行细节类仅当用户已表达为可复用规则时才抽 |
| 2026-02-24 | 0.8 | T6 定稿 §7.4：跳过按 agent 默认继续、相同问题本轮不重复问 |
| 2026-02-24 | 0.9 | T4 定稿：各环节嗅探规则中提前确定可命名的原则/策略；§7.1、§7.1.1、§7.1.2、§7.3 同步 |
| 2026-02-25 | 1.0 | TasteKey 彻底移除；「不再问」改为 memory-retrieve 统一检索；拟提问前传入 Agent 构建的决策点描述；检索依赖 Title、When to load 及 notes 正文 |
