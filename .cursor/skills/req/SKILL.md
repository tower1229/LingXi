---
name: req
description: 此 Skill 将模糊需求产出为可执行、可验收的 Requirement。当用户通过 /flow <需求描述> 创建新需求，或 /flow REQ-xxx 但 requirement 缺失需补齐时激活，写入 .workflow/requirements/in-progress/REQ-xxx.md 并更新 INDEX。
---

# Req

## Outputs (must write)

- `.workflow/requirements/in-progress/REQ-xxx.md`
- `.workflow/requirements/INDEX.md`

**输出规则（静默成功原则）**：

- 文件写入成功：静默，不输出确认信息（如"已写入 REQ-xxx.md"）
- 文件写入失败：输出错误信息
- 索引更新成功：静默，不输出确认信息

## Instructions

### 1) 项目上下文分析

在理解需求前，先获取项目背景：

- 查看 `package.json`、`README.md` 等，了解技术栈
- 浏览项目目录结构，识别与需求相关的现有模块
- 初步判断技术可行性和需要引入的新依赖

### 2) 需求分析

#### 2.0 需求提纯

在开始类型识别和复杂度评估前，先进行需求提纯：

**2.0.1 结构化澄清**

对于模糊需求，使用 5W1H 框架引导用户表达：

- **What**: 具体要做什么功能/改动
- **Why**: 为什么需要这个功能（业务驱动）
- **Who**: 目标用户是谁
- **Where**: 影响范围在哪里
- **When**: 有无时间/顺序约束
- **How**: 用户期望的交互/体验

**执行方式**：
- 如果需求描述清晰完整，静默跳过此步骤
- 如果需求描述模糊或缺失关键信息，主动提出结构化问题
- 一次性列出所有需要澄清的问题，等待用户回答后再继续

**2.0.2 隐含意图挖掘**

从用户描述中提取未明说的期望：

- 分析用户描述中的关键词和上下文
- 识别可能隐含的功能需求（如"添加按钮"可能隐含"要有点击反馈、要有禁用状态"）
- 识别可能隐含的非功能需求（如性能、安全、可访问性等）

**执行方式**：
- 将识别到的隐含意图以建议形式呈现给用户确认
- 避免过度推断，只提出高置信度的隐含需求

**2.0.3 用户真实意图确认**

在完成结构化澄清和隐含意图挖掘后，总结理解并确认：

- 用简洁的语言总结需求的核心目标
- 明确需求的范围边界
- 确认关键约束和成功标准

**执行方式**：
- 输出需求理解总结
- 询问用户"以上理解是否正确？"
- 等待用户确认后再继续后续分析

**静默原则**：
- 如果需求已经非常清晰（简单功能），可以静默跳过部分提纯步骤
- 但必须确保核心信息（What/Why）已明确

#### 2.1 类型识别

| 类型     | 特征                                | 示例                             |
| -------- | ----------------------------------- | -------------------------------- |
| 纯前端   | 只涉及 UI/交互/前端状态，不涉及后端 | "优化移动端展示"、"添加按钮动画" |
| 纯后端   | 只涉及 API/服务/数据库，不涉及界面  | "优化查询性能"、"调整配额逻辑"   |
| 全栈     | 同时涉及前端和后端                  | "实现用户认证"、"新增分享功能"   |
| 简单功能 | 单一、明确、范围小                  | "修改按钮文案"、"调整错误提示"   |

#### 2.2 复杂度评估

| 复杂度 | 特征                                         |
| ------ | -------------------------------------------- |
| 简单   | 单一功能点，影响范围小，无复杂依赖           |
| 中等   | 涉及多个模块，需要前后端协作，有一定技术难度 |
| 复杂   | 架构级变更，影响全局，依赖多个系统           |

#### 2.3 需求放大

对每个需求都尝试找到最佳实践和最优方案。

**2.3.1 主动外部调研**

对每个需求都尝试找到最佳实践：

- 使用 WebSearch 搜索 "best practice for X 2025/2026"、"X implementation guide"
- 使用 MCP context7 获取框架/库的官方文档和最新API说明
- 识别需求中的关键技术点，主动调研相关领域的主流方案

**调研内容**（req 阶段做广度调研，深度留给 plan）：

- 该领域的主流技术方案
- 常见的实现模式
- 已知的典型坑点
- 最新的最佳实践和趋势

**2.3.2 方案对比**

对于有多种可行方案的需求：

- 列出2-3个主要备选方案
- 对比各方案的优劣（性能、复杂度、维护成本等）
- 基于项目上下文推荐最优方案
- 将对比结果融入"1.3 解决方案概述"或"6.2 关键决策记录"

**2.3.3 最佳实践融入**

将调研到的最佳实践直接融入解决方案：

- 在"1.1 背景"中引用行业最佳实践
- 在"1.3 解决方案概述"中体现推荐方案的理由
- 在"6.1 外部参考"中列出关键参考来源

**输出要求**：

- 不单独写入调研报告，将知识融入需求文档的相应章节
- 复杂需求：在附录中列出关键参考来源和决策对比
- 简单需求：静默融入，不显式标注来源

**静默原则**：

- 如果需求非常简单（如"修改按钮文案"），可以静默跳过外部调研
- 但涉及新技术栈或复杂功能时，必须主动调研

#### 2.4 经验融入

如果 `experience-index` 匹配到相关经验，在"1.1 背景"中引用，或在"2.2 非目标"中体现历史踩坑点。

#### 2.5 经验候选捕获（即时捕获）

当场发生以下情况时，立即输出经验候选（用 HTML 注释包裹，不干扰对话）：

| 触发场景 | 描述 | 典型信号 |
|----------|------|----------|
| **需求固化** | req 文档初次输出完成，提取其中的价值判断 | 文档写入成功（背景/问题/方案/标准中的价值取向） |
| **范围调整** | 用户扩大/缩小/重新划定需求范围 | "只做 A，不做 B"、"先做核心功能" |
| **优先级变更** | 用户调整功能优先级 | "这个可以后做"、"这个必须有" |
| **目标纠正** | 用户纠正对需求目标的理解 | "不是这个意思"、"我要的是..." |
| **方案选择** | 用户在多个解决方案中选择 | "用方案 A"、"不要用 B" |
| **约束添加** | 用户新增技术/业务/时间约束 | "必须兼容 X"、"不能超过 Y" |
| **边界明确** | 用户明确不做什么及理由 | "这个不在范围内，因为..." |
| **验收调整** | 用户调整成功标准或验收条件 | "这样才算完成"、"这个不用验" |
| **风险确认** | AI 发现风险/矛盾，用户确认处置 | "接受这个风险"、"改成这样规避" |
| **语义澄清** | 用户澄清业务术语或概念边界 | "X 的意思是..."、"X 和 Y 的区别是..." |

**需求固化**的提取要点（文档写入后立即执行）：
- **背景（1.1 背景）**：为什么需要这个功能？业务驱动是什么？
- **问题描述（1.2 问题描述）**：什么被认为是问题？痛点识别的价值判断
- **解决方案概述（1.3 解决方案概述）**：为什么选择这个方向？体现的设计原则
- **成功标准（2.3 成功标准）**：什么被认为是成功？价值取向（可读性/稳定性/性能等）
- **非目标（2.2 非目标）**：为什么不做某些事？边界划定的理由

输出格式（结构化，便于后续 subagent 处理）：

<!-- EXP-CANDIDATE
{
  "stage": "req",
  "trigger": "当用户将范围从A调整为B",
  "decision": "需求目标/范围的最终取舍",
  "alternatives": ["保留旧范围（放弃，因为...）"],
  "signal": "判断依据/风险信号",
  "solution": "新的目标/范围/验收标准",
  "verify": "后续如何验证这一调整",
  "pointers": ["path/to/req-file 或其他指针"],
  "notes": "可选补充"
}
-->

### 3) Fail Fast

如果必要信息缺失，一次性列出问题并给出 2-3 个选项，等待用户选择后再写入。

**必要信息**（缺失必须询问）：功能目标、目标用户（前端需求）、核心场景（前端需求）

**重要信息**（模糊建议澄清）：成功标准、优先级、特殊约束

### 4) 信息汇总

在写入前，将收集的信息汇总为可执行决策：

- **需求澄清结论**：目标/范围/成功标准的最终表述
- **关键决策点**（中等+）：备选方案、推荐方案、理由
- **风险与对策**（复杂）：按影响排序，给出缓解措施

### 5) Requirement 写入

#### 5.1 模板选择矩阵

| 类型     | 复杂度 | 包含章节                                 |
| -------- | ------ | ---------------------------------------- |
| 简单功能 | 任意   | 概述、目标、验收清单                     |
| 纯前端   | 简单   | 概述、目标、用户故事、验收清单           |
| 纯前端   | 中等+  | 概述、目标、用户故事、功能需求、验收清单 |
| 纯后端   | 简单   | 概述、目标、用户故事、验收清单           |
| 纯后端   | 中等+  | 概述、目标、用户故事、功能需求、验收清单 |
| 全栈     | 任意   | 完整模板                                 |

**决策规则**：

- 前端需求：不包含 API 规范、数据模型（留给 plan）
- 后端需求：不包含 UI 交互规范（留给 plan）
- req 阶段只定义"做什么"，不定义"怎么做"

#### 5.2 完整模板

```markdown
# <REQ-xxx>: <Title>

| 属性     | 值                        |
| -------- | ------------------------- |
| 版本     | 1.0                       |
| 状态     | 草稿                      |
| 创建日期 | {DATE}                    |
| 需求类型 | [前端/后端/全栈/简单功能] |
| 复杂度   | [简单/中等/复杂]          |

---

## 1. 概述

### 1.1 背景

### 1.2 问题描述

### 1.3 解决方案概述（不含技术实现细节）

---

## 2. 目标与指标

### 2.1 目标

| 编号 | 目标 | 优先级   |
| ---- | ---- | -------- |
| G1   | ...  | 必须实现 |

### 2.2 非目标

> 明确列出"容易被误解为需求范围内，但实际不做"的内容。

### 2.3 成功标准（必须可验证）

| 标准 | 描述 | 验证方式           |
| ---- | ---- | ------------------ |
| ...  | ...  | 测试/脚本/手工步骤 |

---

## 3. 用户故事（至少 1 条）

### US-1: ...

**作为** ...
**我想要** ...
**以便** ...

**验收标准：**

- [ ] ...

---

## 4. 功能需求（中等+复杂度）

| 编号 | 需求描述 | 实现方案 | 验收标准 | 优先级   |
| ---- | -------- | -------- | -------- | -------- |
| F1   | ...      | 关键文件 + 实现模式 | 可验证的标准 | 必须实现 |

**实现方案列内容要求**：
- **关键文件**：需要修改/创建的文件路径（指针优先，如 `src/components/Button.tsx`）
- **实现模式**：推荐的代码组织方式或参考指针（简洁描述，如"使用 React Hook 管理状态"）
- **简洁原则**：指针优先，详细实现细节留给 work 阶段

---

## 5. 验收检查清单

- [ ] ...

---

## 6. 附录（复杂需求）

### 6.1 外部参考

- [参考 1]（来源：xxx）
- [参考 2]（来源：xxx）

### 6.2 关键决策记录

| 决策点 | 备选方案 | 最终选择 | 理由 |
| ------ | -------- | -------- | ---- |
| ...    | A / B    | A        | ...  |
```

#### 5.3 简化模板（简单功能）

```markdown
# <REQ-xxx>: <Title>

| 属性     | 值       |
| -------- | -------- |
| 版本     | 1.0      |
| 创建日期 | {DATE}   |
| 需求类型 | 简单功能 |
| 复杂度   | 简单     |

---

## 1. 概述

### 1.1 背景

### 1.2 问题描述

### 1.3 解决方案概述

---

## 2. 目标

| 编号 | 目标 | 优先级   |
| ---- | ---- | -------- |
| G1   | ...  | 必须实现 |

---

## 3. 验收检查清单

- [ ] ...
```

### 6) 更新索引

遵循 `index-manager` 的指引更新索引：

- Status：`in-progress`
- Current Phase：`req`
- Links：至少包含 requirement 路径

### 7) 阶段完成输出（人工闸门）

阶段完成后输出：

```
需求文档已创建，您可以：

A) 继续修改/补充 需求
B) 进入 plan（复杂任务推荐）
C) 跳过 plan 进入 audit
D) 跳过 plan 直接 work
E) 回退
F) 退出
```

### 8) 可推进判据检查（req → plan/audit/work，用户选择 B/C/D 后执行）

用户选择 B（进入 plan）、C（跳过 plan 进入 audit）或 D（跳过 plan 直接 work）后，检查以下判据：

| 判据                   | 验证方式                |
| ---------------------- | ----------------------- |
| Requirement 文件已写入 | `REQ-xxx.md` 存在且非空 |
| Requirement 内容完整   | 至少包含概述和目标      |
| 关键缺失项=0           | 无"待澄清项"标注        |
| INDEX 已更新           | Status = in-progress    |

**检查逻辑**：

- 满足 → 静默推进（B 进入 plan，C/D 由 flow-router 处理跳转和自动生成轻量 plan）
- 不满足 → 输出检查清单（仅在异常时展示）
