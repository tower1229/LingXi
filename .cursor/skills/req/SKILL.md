---
name: req
description: 此 Skill 将模糊需求产出为可执行、可验收的 Requirement。当用户通过 /flow <需求描述> 创建新需求，或 /flow REQ-xxx 但 requirement 缺失需补齐时激活，写入 .workflow/requirements/in-progress/REQ-xxx.md 并更新 INDEX。
---

# Req

## Outputs (must write)

- `.workflow/requirements/in-progress/REQ-xxx.md`
- `.workflow/requirements/INDEX.md`

**输出规则（静默成功原则）**：
- 文件写入成功：静默，不输出确认信息（如"已写入 REQ-xxx.md"）
- 文件写入失败：输出错误信息
- 索引更新成功：静默，不输出确认信息

## Instructions

### 1) 项目上下文分析

在理解需求前，先获取项目背景：

- 查看 `package.json`、`README.md` 等，了解技术栈
- 浏览项目目录结构，识别与需求相关的现有模块
- 初步判断技术可行性和需要引入的新依赖

### 2) 需求分析

#### 2.1 类型识别

| 类型 | 特征 | 示例 |
|-----|-----|-----|
| 纯前端 | 只涉及 UI/交互/前端状态，不涉及后端 | "优化移动端展示"、"添加按钮动画" |
| 纯后端 | 只涉及 API/服务/数据库，不涉及界面 | "优化查询性能"、"调整配额逻辑" |
| 全栈 | 同时涉及前端和后端 | "实现用户认证"、"新增分享功能" |
| 简单功能 | 单一、明确、范围小 | "修改按钮文案"、"调整错误提示" |

#### 2.2 复杂度评估

| 复杂度 | 特征 |
|-------|-----|
| 简单 | 单一功能点，影响范围小，无复杂依赖 |
| 中等 | 涉及多个模块，需要前后端协作，有一定技术难度 |
| 复杂 | 架构级变更，影响全局，依赖多个系统 |

#### 2.3 外部知识放大（推荐）

识别需求中的关键技术点后，使用 WebSearch 获取外部知识。

**触发条件**（满足任一即触发）：

- 需求涉及当前项目中首次出现的技术栈
- 用户明确要求"调研"、"对比方案"、"最佳实践"
- 复杂度为"中等"或"复杂"

**调研内容**（req 阶段只做广度调研，深度留给 plan）：

- 该领域的主流技术方案
- 常见的实现模式
- 已知的典型坑点

**输出要求**：

- 不单独写入，将背景知识融入"1.1 背景"和"1.3 解决方案概述"
- 复杂需求：在附录中列出关键参考来源

#### 2.4 经验融入

如果 `experience-index` 匹配到相关经验，在"1.1 背景"中引用，或在"2.2 非目标"中体现历史踩坑点。

#### 2.5 经验候选捕获（即时捕获）

当场发生以下情况时，立即输出经验候选（用 HTML 注释包裹，不干扰对话）：

- 用户纠正/重写目标、范围、优先级、验收标准
- 明确了不做的范围（非目标）或新增了关键约束
- 发现需求表述矛盾或潜在风险，并给出澄清
- 选择/放弃某个需求范围或验收标准的理由

输出格式（结构化，便于后续 subagent 处理）：

<!-- EXP-CANDIDATE
{
  "stage": "req",
  "trigger": "当用户将范围从A调整为B",
  "decision": "需求目标/范围的最终取舍",
  "alternatives": ["保留旧范围（放弃，因为...）"],
  "signal": "判断依据/风险信号",
  "solution": "新的目标/范围/验收标准",
  "verify": "后续如何验证这一调整",
  "pointers": ["path/to/req-file 或其他指针"],
  "notes": "可选补充"
}
-->

### 3) Fail Fast

如果必要信息缺失，一次性列出问题并给出 2-3 个选项，等待用户选择后再写入。

**必要信息**（缺失必须询问）：功能目标、目标用户（前端需求）、核心场景（前端需求）

**重要信息**（模糊建议澄清）：成功标准、优先级、特殊约束

### 4) 信息汇总

在写入前，将收集的信息汇总为可执行决策：

- **需求澄清结论**：目标/范围/成功标准的最终表述
- **关键决策点**（中等+）：备选方案、推荐方案、理由
- **风险与对策**（复杂）：按影响排序，给出缓解措施

### 5) Requirement 写入

#### 5.1 模板选择矩阵

| 类型 | 复杂度 | 包含章节 |
|-----|-------|---------|
| 简单功能 | 任意 | 概述、目标、验收清单 |
| 纯前端 | 简单 | 概述、目标、用户故事、验收清单 |
| 纯前端 | 中等+ | 概述、目标、用户故事、功能需求、验收清单 |
| 纯后端 | 简单 | 概述、目标、用户故事、验收清单 |
| 纯后端 | 中等+ | 概述、目标、用户故事、功能需求、验收清单 |
| 全栈 | 任意 | 完整模板 |

**决策规则**：

- 前端需求：不包含 API 规范、数据模型（留给 plan）
- 后端需求：不包含 UI 交互规范（留给 plan）
- req 阶段只定义"做什么"，不定义"怎么做"

#### 5.2 完整模板

```markdown
# <REQ-xxx>: <Title>

| 属性     | 值                        |
| -------- | ------------------------- |
| 版本     | 1.0                       |
| 状态     | 草稿                      |
| 创建日期 | {DATE}                    |
| 需求类型 | [前端/后端/全栈/简单功能] |
| 复杂度   | [简单/中等/复杂]          |

---

## 1. 概述

### 1.1 背景

### 1.2 问题描述

### 1.3 解决方案概述（不含技术实现细节）

---

## 2. 目标与指标

### 2.1 目标

| 编号 | 目标 | 优先级   |
| ---- | ---- | -------- |
| G1   | ...  | 必须实现 |

### 2.2 非目标

> 明确列出"容易被误解为需求范围内，但实际不做"的内容。

### 2.3 成功标准（必须可验证）

| 标准 | 描述 | 验证方式           |
| ---- | ---- | ------------------ |
| ...  | ...  | 测试/脚本/手工步骤 |

---

## 3. 用户故事（至少 1 条）

### US-1: ...

**作为** ...
**我想要** ...
**以便** ...

**验收标准：**

- [ ] ...

---

## 4. 功能需求（中等+复杂度）

| 编号 | 需求描述 | 优先级   |
| ---- | -------- | -------- |
| F1   | ...      | 必须实现 |

---

## 5. 验收检查清单

- [ ] ...

---

## 6. 附录（复杂需求）

### 6.1 外部参考

- [参考 1]（来源：xxx）
- [参考 2]（来源：xxx）

### 6.2 关键决策记录

| 决策点 | 备选方案 | 最终选择 | 理由 |
| ------ | -------- | -------- | ---- |
| ...    | A / B    | A        | ...  |
```

#### 5.3 简化模板（简单功能）

```markdown
# <REQ-xxx>: <Title>

| 属性     | 值       |
| -------- | -------- |
| 版本     | 1.0      |
| 创建日期 | {DATE}   |
| 需求类型 | 简单功能 |
| 复杂度   | 简单     |

---

## 1. 概述

### 1.1 背景

### 1.2 问题描述

### 1.3 解决方案概述

---

## 2. 目标

| 编号 | 目标 | 优先级   |
| ---- | ---- | -------- |
| G1   | ...  | 必须实现 |

---

## 3. 验收检查清单

- [ ] ...
```

### 6) 更新索引

遵循 `index-manager` 的指引更新索引：

- Status：`in-progress`
- Current Phase：`req`
- Links：至少包含 requirement 路径

### 6.5) Trade-off Record（取舍记录，可选）

当出现关键取舍时输出（可转写为 EXP-CANDIDATE）：
- **决策点**：正在做什么决策
- **备选方案**：所有考虑的方案（含被拒绝的）
- **拒绝理由**：为什么拒绝某些方案
- **接受的风险**（可选）：选择当前方案时接受的风险

### 7) 阶段完成输出（人工闸门）

阶段完成后输出：
```
✅ req 完成 → plan | A)补充/修改 B)下一阶段 C)回退 D)退出
```

### 8) 可推进判据检查（req → plan，仅用户选择 B 后执行）

用户选择 B 后，检查以下判据：

| 判据 | 验证方式 |
|------|---------|
| Requirement 文件已写入 | `REQ-xxx.md` 存在且非空 |
| Requirement 内容完整 | 至少包含概述和目标 |
| 关键缺失项=0 | 无"待澄清项"标注 |
| INDEX 已更新 | Status = in-progress |

**检查逻辑**：满足 → 静默推进；不满足 → 输出检查清单，提供选项（强制推进 / 回退 / 补充修改）
