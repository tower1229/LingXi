---
name: review-executor
description: 当执行 /review 命令时自动激活（taskId 可选，省略时使用最新任务），负责多维度审查和交付质量保证。
---

# Review Executor

## Instructions

### 1. 读取输入

- 扫描 `.cursor/.lingxi/requirements/` 目录
- **如果指定 taskId**：使用指定的任务编号
- **如果省略 taskId**：提取所有 `*.req.*.md` 文件的编号，选取最大编号的任务
- 查找相关文件：
  - `<taskId>.req.*.md`（任务文档）
  - `<taskId>.plan.*.md`（如果存在，规划文档）
  - `<taskId>.testcase.*.md`（如果存在，测试用例文档）
- 定位 build 阶段编写的测试脚本文件
- 定位变更代码文件列表

### 2. 审查维度智能启用

基于语义理解，判断哪些审查维度需要启用：

#### 2.1 文档一致性审查（始终启用）

- 所有任务都需要检查代码与文档一致性
- 使用 reviewer skill：`reviewer-doc-consistency`

#### 2.2 安全审查（语义判断启用）

**启用条件判断**：

1. 语义分析 req 文档内容：
   - 检查"功能需求"章节：是否涉及用户输入、认证、权限、敏感数据
   - 检查"API 规范"章节：是否暴露外部接口
   - 检查"技术方案"章节：是否涉及文件操作、数据库操作

2. 语义分析实现代码：
   - 扫描变更代码：是否包含 SQL 操作、用户输入处理、权限检查、文件操作等

3. 启用判断：
   - 如果需求或实现中包含安全相关特征 → 启用安全审查 (skill: `reviewer-security`)
   - 否则 → 跳过安全审查

**AI Native 原则**：依赖 LLM 的语义理解能力，不进行关键词匹配。

#### 2.3 性能审查（语义判断启用）

**启用条件判断**：

1. 语义分析 req 文档内容：
   - 检查"功能需求"章节：是否涉及批量处理、实时响应、高并发、大数据量
   - 检查"成功标准"章节：是否有性能指标（响应时间、吞吐量等）
   - 检查"技术方案"章节：是否涉及性能优化、缓存、异步处理

2. 语义分析实现代码：
   - 扫描变更代码：是否包含循环遍历、数据库查询、缓存操作、异步处理等

3. 启用判断：
   - 如果需求或实现中包含性能敏感特征 → 启用性能审查 (skill: `reviewer-performance`)
   - 否则 → 跳过性能审查

**AI Native 原则**：依赖 LLM 的语义理解能力，综合判断是否需要性能审查。

#### 2.4 E2E 测试审查（语义判断启用）

**启用条件判断**：

1. 语义分析 req 文档内容：
   - 检查"功能需求"章节：是否涉及前端用户交互流程、关键业务流程、多页面交互
   - 检查"技术方案"章节：是否涉及前端页面、路由、表单交互、页面跳转
   - 检查"验收标准"章节：是否有端到端流程验证要求

2. 语义分析实现代码：
   - 扫描变更代码：是否包含 UI 组件、路由配置、表单处理、页面跳转等前端交互代码

3. 启用判断：
   - 如果需求或实现中包含 E2E 测试特征 → 启用 E2E 测试审查 (skill: `reviewer-e2e`)
   - 否则 → 跳过 E2E 测试审查

**AI Native 原则**：依赖 LLM 的语义理解能力，不进行关键词匹配。

#### 2.5 启用决策汇总

记录启用决策结果：

- 文档一致性审查：✅ 启用 (skill)
- 安全审查：✅/❌ (基于语义判断)
- 性能审查：✅/❌ (基于语义判断)
- E2E 测试审查：✅/❌ (基于语义判断)

### 3. 测试用例文档审查

如果存在 `testcase` 文档：

- 读取 `<taskId>.testcase.*.md`
- 基于 req 审查测试用例文档
- 检查覆盖完整性、准确性
- 如不完整或不合格，补充或修改测试用例文档

### 4. 测试脚本质量检查（执行测试前）

- 读取 build 阶段编写的测试脚本文件
- 检查测试脚本的实现质量：
  - **覆盖完整性**：是否覆盖了 req 中的所有功能需求和验收标准
  - **断言准确性**：断言是否正确验证了预期行为，是否验证了关键结果
  - **测试隔离性**：测试之间是否相互独立，是否有外部依赖泄漏
  - **边界条件测试**：是否测试了边界情况、错误处理、异常场景
  - **测试可维护性**：测试代码是否清晰、可读，是否遵循测试最佳实践
  - **测试结构**：是否遵循"一行为一测试"原则，测试命名是否清晰

- **如果发现问题**：
  - 补充缺失的测试场景
  - 修正不准确的断言
  - 修复测试隔离问题
  - 补充边界条件测试
  - 优化测试代码结构

- **只有测试脚本质量合格后，才执行测试**

### 5. 测试执行

- 执行单元测试（基于 build 编写的测试脚本，已通过质量检查）
- 执行集成测试
- 记录测试执行结果（通过/失败/跳过）

**测试执行逻辑**：

- 使用项目中检测到的测试框架
- 执行命令：`yarn test` 或 `npm test`（由项目配置决定）
- 解析测试输出：提取通过/失败/跳过的测试数量
- 失败处理：列出失败用例，提供修复建议

**降级方案**：

如果测试框架无法执行（环境问题、依赖问题等）：

- 输出手动测试清单（基于 plan 的测试用例文档或 req 的验收标准）
- 提供测试步骤和预期结果
- 标记需要手动验证

### 6. 依次执行核心维度（必须执行）

按顺序执行核心维度（必须执行），这些维度与主流程紧密耦合，共享上下文更高效，每个维度发现问题按优先级分级（Blockers/High/Medium/Low）：

#### 6.1 功能审查

检查内容：

- 是否符合 req 要求
- 功能是否完整实现
- 是否存在功能缺陷或需求偏差
- 是否存在回归风险

#### 6.2 测试覆盖审查

检查内容：

- **覆盖完整性**：
  - plan/testcase 中定义的所有可测试行为是否都有对应测试
  - 单元测试是否覆盖正常流程、边界条件、错误处理
  - 集成测试是否覆盖关键交互场景
- **测试质量**（已在步骤 4 检查，此处复核）：
  - 测试是否隔离（无外部依赖泄漏）
  - 测试是否遵循一行为一测试原则
  - 测试断言是否明确、有意义
  - 测试是否可重复执行
- **测试结果**：
  - 所有测试是否通过
  - 是否有被跳过（skip）的测试需要处理
  - 测试运行时间是否合理

**测试覆盖不足视为 High 级别问题**

#### 6.3 架构审查

检查内容：

- 架构设计是否合理
- 模块耦合是否过紧
- 职责划分是否清晰
- 是否符合 req 中的架构思路

#### 6.4 可维护性审查

检查内容：

- 代码可维护性：代码结构是否清晰
- 代码可读性：命名是否清晰、注释是否充分
- 代码可扩展性：是否易于扩展
- 代码规范性：是否遵循项目代码规范

#### 6.5 回归风险审查

检查内容：

- 是否存在破坏现有功能的风险
- 是否影响其他模块
- 是否需要更新相关文档
- 是否需要通知相关团队

**注意**：记忆写入通过**显式调用** lingxi-memory 子代理处理（在提示中使用 `/lingxi-memory` 或自然语言「使用 lingxi-memory 子代理…」）；本 Skill 不包含捕获与写入逻辑。

### 7. 并行执行可选维度（显式调用 reviewer skills）

根据步骤 2 的启用决策，显式调用对应的 reviewer skills：

**说明**：虽然改为 skills，但可以按需并行执行（通过显式调用多个 skills）。reviewer skills 共享 review-executor 的上下文，可以访问 req 文档、代码文件列表等信息。

#### 7.1 文档一致性审查（始终启用）

- 显式调用 `reviewer-doc-consistency` skill 执行文档一致性审查
- 传入参数：req 文档路径、变更代码文件列表、plan/testcase 文档路径（如存在）
- 不阻塞主流程

#### 7.2 安全审查（如语义判断需要）

- 如果步骤 2.2 的语义分析判断需要安全审查：
  - 显式调用 `reviewer-security` skill 执行安全审查
  - 传入参数：req 文档路径、变更代码文件列表、重点关注的安全相关代码片段
  - 不阻塞主流程
- 否则：跳过安全审查

#### 7.3 性能审查（如语义判断需要）

- 如果步骤 2.3 的语义分析判断需要性能审查：
  - 显式调用 `reviewer-performance` skill 执行性能审查
  - 传入参数：req 文档路径、变更代码文件列表、性能相关代码片段
  - 不阻塞主流程
- 否则：跳过性能审查

#### 7.4 E2E 测试审查（如语义判断需要）

- 如果步骤 2.4 的语义分析判断需要 E2E 测试：
  - 显式调用 `reviewer-e2e` skill 执行 E2E 测试审查
  - 传入参数：req 文档路径、testcase 文档路径（如存在）、应用启动配置（端口、启动命令等）
  - 不阻塞主流程
- 否则：跳过 E2E 测试审查

#### 7.5 等待所有 reviewer skills 完成

- 等待所有启用的 reviewer skills 完成执行
- 收集各 reviewer skill 的审查结果
- 如果某个 reviewer skill 调用失败或超时：
  - 记录降级原因
  - 回退到主流程依次执行该维度审查（不影响其他维度）
- 汇总为统一格式（Blockers/High/Medium/Low）

### 8. Review 文档写入

#### Review 文档模板

```markdown
# 001.review.<标题>

## 总结（3-6 行）

[简要总结审查结果：是否通过、主要问题、改进建议]

## 测试覆盖报告

### 测试执行结果

| 类型       | 通过 | 失败 | 跳过 |
| ---------- | ---- | ---- | ---- |
| 单元测试   | X    | 0    | 0    |
| 集成测试   | X    | 0    | 0    |
| 端到端测试 | X    | 0    | 0    |

### 行为覆盖情况

| 行为ID | 行为描述 | 测试状态                    |
| ------ | -------- | --------------------------- |
| B1     | ...      | ✅ 已覆盖                   |
| B2     | ...      | ✅ 已覆盖                   |
| B3     | ...      | ⚠️ 部分覆盖（缺少边界条件） |

### 测试质量评估

- 隔离性：✅ / ⚠️ / ❌
- 可维护性：✅ / ⚠️ / ❌
- 断言质量：✅ / ⚠️ / ❌

## 多维度审查结果

### 1. 功能审查

- Blockers:
- High:
- Medium:
- Low:

### 2. 测试覆盖审查

- Blockers:
- High:
- Medium:
- Low:

### 3. 安全审查

- Blockers:
- High:
- Medium:
- Low:

### 4. 性能审查

- Blockers:
- High:
- Medium:
- Low:

### 5. 架构审查

- Blockers:
- High:
- Medium:
- Low:

### 6. 可维护性审查

- Blockers:
- High:
- Medium:
- Low:

### 7. 回归风险审查

- Blockers:
- High:
- Medium:
- Low:

### 8. 文档一致性审查

- Blockers:
- High:
- Medium:
- Low:

### 9. E2E 测试审查

- Blockers:
- High:
- Medium:
- Low:

**E2E 测试执行结果**：

| 测试场景              | 状态    | 备注                      |
| --------------------- | ------- | ------------------------- |
| E2E-001: 用户登录流程 | ✅ 通过 | -                         |
| E2E-002: 数据提交流程 | ❌ 失败 | 步骤 3 点击提交按钮无响应 |

## 汇总：分级 TODO

### Blockers

[列出必须修复的问题]

### High

[列出高优先级问题]

### Medium

[列出中优先级问题]

### Low

[列出低优先级问题]
```

#### 文档命名约定

- Review 文档：`001.review.<标题>.md`（标题 10 字以内，从 req 文档标题提取）
- **不存档**：review 文档不存档，每次执行会覆盖之前的文档

### 9. 审查结果处理

**优先级分级**：

- 每个维度发现问题按优先级分级（Blockers/High/Medium/Low）
- **测试覆盖不足视为 High 级别问题**
- Blockers 必须修复，High 可修复或明确接受风险
- 审查结论必须明确（通过/需修复/拒绝）

**审查结论**：

- **通过**：所有 Blockers 和 High 已处理，可以交付
- **需修复**：存在 Blockers 或 High 需要处理
- **拒绝**：存在严重问题，需要重大修改

### 10. 下一步建议（有输出时）

**输出时机**：仅当本次回复已有正文输出（如审查报告、分级 TODO 等）时，在末尾追加下一步建议；纯静默成功时不追加。

**质量自检维度**（给出建议前结合审查结论）：审查结论是否为「通过」？是否仍有 Blockers/High 未关闭？

**推荐逻辑**：审查通过 → A = 收尾/关闭任务（推荐），B = `/remember` 沉淀，C = 再跑一遍 review，D = 其他。有 Blockers/High → A = 修复后 `/review`（推荐），B = `/remember` 记问题，C = 暂不修，D = 其他。

**允许动作集合**（选项仅限下列）：修复后再 `/review <taskId>`、收尾/关闭任务、`/remember …`、暂不修/其他。

**输出格式**：标题行「**下一步可尝试（选一项）**」；四项格式「**A) 简短描述（推荐）**」「**B) 简短描述**」「**C) 简短描述**」「**D) 简短描述**」；描述中可含具体命令（如 `/review 001`），命令须来自上列允许集合。

**用户回复 A/B/C/D**：当用户下一轮仅输入 A、B、C 或 D 时，视为选择该选项，执行或引导执行对应命令。

---

## 使用场景

### 场景 1：完整审查流程

用户输入：`/review 001`

执行流程：

1. 读取输入（req、plan、testcase、代码）
2. 审查维度智能启用（语义分析判断）
3. 测试用例文档审查
4. 测试脚本质量检查
5. 测试执行
6. 依次执行核心维度（功能、测试覆盖、架构、可维护性、回归风险）
7. 并行执行可选维度（显式调用 reviewer skills：文档一致性、安全、性能、E2E 测试）
8. Review 文档生成
9. 审查结果处理

### 场景 2：快速审查

用户输入：`/review 001`（简单功能）

执行流程：

1. 读取输入（仅 req、代码）
2. 审查维度智能启用（语义分析判断，可能只启用文档一致性）
3. 测试脚本质量检查（简化）
4. 测试执行
5. 依次执行核心维度（简化版）
6. 并行执行可选维度（根据启用决策）
7. Review 文档生成

---

## 注意事项

1. **记忆写入**：记忆写入通过**显式调用** lingxi-memory 子代理处理（`/lingxi-memory` 或自然语言提及），本 Skill 不包含捕获与写入逻辑
2. **测试质量优先**：测试脚本质量检查必须在测试执行前完成
3. **分级输出**：所有问题按优先级分级（Blockers/High/Medium/Low）
4. **明确结论**：审查结论必须明确（通过/需修复/拒绝）

---

## 与 Commands 的协作

本 Skill 由 `/review` 命令自动激活（taskId 可选），执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。

---

## 参考

- **原 review.md 命令**：`.cursor/commands/review.md`（备份在 `.cursor/commands-backup/review.md`）
- **记忆写入**：`.cursor/agents/lingxi-memory.md`
- **记忆注入**：`.cursor/skills/memory-retrieve/SKILL.md`
