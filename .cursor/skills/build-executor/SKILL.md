---
name: build-executor
description: 当执行 /build 命令时自动激活（taskId 可选，省略时使用最新任务），负责代码实现、测试编写和执行。
---

# Build Executor

## Instructions

### 1. 模式检测（自动）

执行 `/build [taskId]` 时，自动检测执行模式：

1. **确定 taskId**：
   - **如果指定 taskId**：使用指定的任务编号
   - **如果省略 taskId**：扫描 `.cursor/.lingxi/tasks/` 目录，提取所有 `*.req.*.md` 文件的编号，选取最大编号的任务

2. **检测 plan 文件**：
   - 扫描 `.cursor/.lingxi/tasks/` 目录
   - 查找 `<taskId>.plan.*.md` 文件（如 `001.plan.*.md`）

3. **模式判断**：
   - **存在 plan 文件** → Plan-driven 模式
   - **不存在 plan 文件** → Agent-driven 模式

4. **模式提示**：
   - 静默检测，在开始执行时输出当前模式（如："检测到 plan 文档，进入 Plan-driven 模式"）

### 2. Plan-driven 模式执行逻辑（有 plan 时）

#### 2.1 读取输入

- `.cursor/.lingxi/tasks/<taskId>.req.<标题>.md`
- `.cursor/.lingxi/tasks/<taskId>.plan.<标题>.md`
- `.cursor/.lingxi/tasks/<taskId>.testcase.<标题>.md`

#### 2.2 代码实现

- 按 req 的技术方案实现功能
- 按 plan 的任务清单顺序执行开发任务
- 遵循 plan 中的依赖关系和执行顺序
- 若子任务 ≥3 或存在明显依赖，应使用结构化任务列表（步骤列表或 todo），标注依赖后再逐项实现

#### 2.3 编写测试脚本

- 读取 `<taskId>.testcase.<标题>.md`
- 基于测试用例文档编写测试脚本
- 遵循项目测试框架（plan 中检测到的框架）
- 按模块组织：模块完成后编写并执行对应测试

#### 2.4 执行单元测试（循环修复直到全部通过）

- 模块完成后执行单元测试
- 记录测试执行结果（通过/失败）
- **如果测试失败**：
  - 分析失败原因，定位 bug
  - 修复 bug
  - 重新执行单元测试
  - **循环执行**：修复 → 测试 → 修复 → 测试，直到所有单元测试全部通过
- **只有所有单元测试通过后，才继续下一个模块或任务**

#### 2.5 文档同步（plan 中的任务）

- 读取 plan 中的文档同步任务清单
- 基于代码变更自动更新相关文档：
  - 扫描代码注释、类型定义
  - 提取接口信息、模块结构
  - 更新文档对应章节
- 同步完成后标记任务完成

#### 2.6 快速 E2E 冒烟测试（可选）

1. **触发条件判断**（AI Native 语义判断）：
   - 语义分析 req 文档：是否涉及前端用户交互流程、关键业务流程、多页面交互
   - 语义分析实现代码：是否包含 UI 组件、路由配置、表单处理、页面跳转等前端交互代码
   - 如果满足 E2E 测试特征 → 执行快速冒烟测试
   - 否则 → 静默跳过

2. **环境准备**：
   - 检测开发服务器是否在运行（检测常见端口：3000, 3001, 8080, 5173 等）
   - 如未运行，检测项目启动命令（`yarn dev`, `npm start`, `yarn start` 等）并启动
   - 等待服务器就绪（检测端口或健康检查，最多等待 30 秒）
   - 验证 Cursor Agent Browser 工具可用性

3. **测试用例选择**：
   - 如果存在 testcase 文档：读取 testcase 文档中的 E2E 测试用例
   - 如果不存在 testcase 文档：基于 req 文档的验收标准，提取 1-2 个最关键的端到端流程
   - **只执行关键流程**（1-2 个用例），不执行全部 E2E 用例（完整测试留给 review 阶段）

4. **执行冒烟测试**：
   - 使用 `@browser` + 自然语言描述执行测试（与 reviewer-e2e 一致）
   - 将测试用例转换为自然语言 prompt
   - 执行关键流程验证
   - 记录执行结果（通过/失败）

5. **结果处理**：
   - **测试通过**：静默，继续流程
   - **测试失败**：输出失败详情（失败步骤、预期 vs 实际、截图信息），标记为 High 级别问题，建议修复后继续或进入 review 阶段

6. **降级处理**：
   - 浏览器工具不可用：静默跳过，不阻塞流程
   - 服务器无法启动：输出环境配置建议，标记为需要环境准备
   - 工具调用次数限制：记录已完成场景，标记"部分完成"

**设计原则**：
- **可选性**：基于语义判断，不强制所有任务都执行
- **快速性**：只执行关键流程（1-2 个用例），控制执行时间
- **非阻塞性**：失败不阻塞 build 流程，但会标记问题
- **静默成功**：通过时静默，失败时输出详情

### 3. Agent-driven 模式执行逻辑（无 plan 时）

#### 3.1 读取输入

- `.cursor/.lingxi/tasks/<taskId>.req.<标题>.md`（仅）

#### 3.2 任务拆解（Agent 决策）

- 基于 req 的功能需求，Agent 自行拆解为可执行的子任务
- 识别功能模块、依赖关系、执行顺序
- 若子任务 ≥3 或存在明显依赖，应使用结构化任务列表（步骤列表或 todo），标注依赖后再逐项实现
- 动态决策实现路径（在无 plan 的情况下）

#### 3.3 代码实现

- 按 req 的技术方案实现功能
- 按 Agent 拆解的任务顺序执行
- Agent 自行判断实现细节（req 中不含实现细节）

#### 3.4 测试框架检测（Agent 决策）

- 检测项目中现有的测试框架（同 plan 阶段的检测逻辑）：
  - 检查 `package.json` 的 `devDependencies`（jest, vitest, mocha, jasmine 等）
  - 检查项目根目录的测试配置文件（`jest.config.js`, `vitest.config.ts`, `mocha.opts` 等）
  - 检查测试目录结构（`tests/`, `__tests__/`, `test/`, `spec/` 等）
  - 检查测试文件模式（`*.test.js`, `*.spec.ts`, `*.test.tsx` 等）
- 如无框架，Agent 自行决定是否安装 vitest（推荐安装）
- 如安装，执行安装流程（同 plan 阶段）

#### 3.5 编写测试脚本（基于 req 验收标准）

- 基于 req 的验收标准编写测试用例（而非 testcase 文档）
- 覆盖 req 中定义的功能验收清单
- 遵循检测到的测试框架
- 按模块组织：模块完成后编写并执行对应测试

#### 3.6 执行单元测试（循环修复直到全部通过）

- 模块完成后执行单元测试
- 记录测试执行结果（通过/失败）
- **如果测试失败**：
  - 分析失败原因，定位 bug
  - 修复 bug
  - 重新执行单元测试
  - **循环执行**：修复 → 测试 → 修复 → 测试，直到所有单元测试全部通过
- **只有所有单元测试通过后，才继续下一个模块或任务**

#### 3.7 文档同步（Agent 识别）

- Agent 自行识别可能受本次改动影响的文档：
  - 扫描项目目录（`docs/`, `design/`, `architecture/` 等）
  - 基于代码变更识别相关文档
  - 识别技术方案文档、设计文档等
- 基于代码变更自动更新相关文档：
  - 扫描代码注释、类型定义
  - 提取接口信息、模块结构
  - 更新文档对应章节

#### 3.8 快速 E2E 冒烟测试（可选）

1. **触发条件判断**（AI Native 语义判断）：
   - 语义分析 req 文档：是否涉及前端用户交互流程、关键业务流程、多页面交互
   - 语义分析实现代码：是否包含 UI 组件、路由配置、表单处理、页面跳转等前端交互代码
   - 如果满足 E2E 测试特征 → 执行快速冒烟测试
   - 否则 → 静默跳过

2. **环境准备**：
   - 检测开发服务器是否在运行（检测常见端口：3000, 3001, 8080, 5173 等）
   - 如未运行，检测项目启动命令（`yarn dev`, `npm start`, `yarn start` 等）并启动
   - 等待服务器就绪（检测端口或健康检查，最多等待 30 秒）
   - 验证 Cursor Agent Browser 工具可用性

3. **测试用例选择**：
   - 如果存在 testcase 文档：读取 testcase 文档中的 E2E 测试用例
   - 如果不存在 testcase 文档：基于 req 文档的验收标准，提取 1-2 个最关键的端到端流程
   - **只执行关键流程**（1-2 个用例），不执行全部 E2E 用例（完整测试留给 review 阶段）

4. **执行冒烟测试**：
   - 使用 `@browser` + 自然语言描述执行测试（与 reviewer-e2e 一致）
   - 将测试用例转换为自然语言 prompt
   - 执行关键流程验证
   - 记录执行结果（通过/失败）

5. **结果处理**：
   - **测试通过**：静默，继续流程
   - **测试失败**：输出失败详情（失败步骤、预期 vs 实际、截图信息），标记为 High 级别问题，建议修复后继续或进入 review 阶段

6. **降级处理**：
   - 浏览器工具不可用：静默跳过，不阻塞流程
   - 服务器无法启动：输出环境配置建议，标记为需要环境准备
   - 工具调用次数限制：记录已完成场景，标记"部分完成"

**设计原则**：
- **可选性**：基于语义判断，不强制所有任务都执行
- **快速性**：只执行关键流程（1-2 个用例），控制执行时间
- **非阻塞性**：失败不阻塞 build 流程，但会标记问题
- **静默成功**：通过时静默，失败时输出详情

### 4. 降级方案

**Plan-driven 模式降级**：

- 如果测试框架无法执行：输出手动测试清单（基于 testcase 文档）
- 如果文档同步无法执行：输出文档更新清单（基于 plan 清单）

**Agent-driven 模式降级**：

- 如果测试框架无法执行：输出手动测试清单（基于 req 验收标准）
- 如果文档同步无法执行：输出文档更新清单（Agent 识别的文档列表）

### 5. 模式选择建议

| 场景                         | 推荐模式     | 理由                         |
| ---------------------------- | ------------ | ---------------------------- |
| 复杂任务（多模块、多依赖）   | Plan-driven  | 需要明确的任务拆解和依赖管理 |
| 简单任务（单一功能、无依赖） | Agent-driven | Agent 可直接判断和执行       |
| 需要明确的测试策略           | Plan-driven  | 有 testcase 文档指导         |
| 需要文档同步计划             | Plan-driven  | 有明确的文档清单             |
| 快速原型开发                 | Agent-driven | 无需详细规划，快速迭代       |
| 生产环境功能                 | Plan-driven  | 需要更严格的计划和验证       |

### 6. 执行质量保证

两种模式都确保：

1. **功能完整性**：满足 req 中的所有功能需求
2. **验收标准**：通过 req 定义的验收标准
3. **代码质量**：遵循项目代码规范（由记忆库沉淀；通过 sessionStart hook 注入的约定 + `memory-retrieve` 的每轮注入提供相关提醒）
4. **测试覆盖**：确保关键功能有测试覆盖
5. **文档一致性**：代码与相关文档保持一致

### 6.5 下一步建议（有产物时必须输出）

**输出时机**：**只要本步产生了代码或测试变更**（实现了需求或执行了测试，无论通过与否），**必须在当轮回复末尾**输出下一步建议；与是否在回复中贴出实现/测试详情无关。若本步未做任何实现或测试（如仅做了模式检测未落码），可不包含下一步建议。

**必须包含的结构**（在回复末尾）：标题行「**下一步可尝试（选一项）**」+ 四项「**A) …（推荐）**」「**B) …**」「**C) …**」「**D) …**」；给出建议前先做质量自检（见下），根据自检结果决定 A 的推荐内容。

**质量自检维度**（给出建议前先自评当前产出）：是否已按 req/plan 实现？约定测试是否通过？是否有明显未完成项？快速 E2E 冒烟测试是否通过？

**推荐逻辑**：
- 自检通过且冒烟测试通过 → A = `/review` 做交付审查（推荐），B = `/remember` 沉淀，C = 先改代码再 review，D = 其他
- 自检通过但冒烟测试失败 → A = 修复后继续 build（推荐），B = `/review` 做完整审查，C = `/remember` 沉淀问题，D = 其他
- 自检不通过 → A = 先改代码再 review（推荐），B = `/review`，C/D = 其他

**允许动作集合**（选项仅限下列）：`/review <taskId>`、`/remember …` 沉淀、先改代码再 review、其他/跳过。

**输出格式**：标题行「**下一步可尝试（选一项）**」；四项格式「**A) 简短描述（推荐）**」「**B) 简短描述**」「**C) 简短描述**」「**D) 简短描述**」；描述中可含具体命令（如 `/review 001`），命令须来自上列允许集合。

**用户回复 A/B/C/D**：当用户下一轮仅输入 A、B、C 或 D 时，视为选择该选项，执行或引导执行对应命令。

### 7. 测试执行规范

#### 7.1 测试执行时机

| 时机                 | 动作         | 目的         |
| -------------------- | ------------ | ------------ |
| 任务开始前           | 运行现有测试 | 确认基线正常 |
| 每完成一个实现任务后 | 运行相关测试 | 确认实现正确 |
| 进入 review 前       | 运行全部测试 | 确认无回归   |

#### 7.2 测试编写规范

编写单元测试时遵循：

| 原则             | 说明                                                     |
| ---------------- | -------------------------------------------------------- |
| **隔离测试**     | Mock 所有外部依赖（API、数据库、文件系统）               |
| **一行为一测试** | 每个测试只验证一个行为，便于定位问题                     |
| **AAA 模式**     | Arrange（准备数据）→ Act（执行操作）→ Assert（验证结果） |
| **基于规格**     | 只测试 plan/testcase 或 req 中定义的行为，不发明新行为   |

#### 7.3 测试结果记录

**测试通过时**：

- 完全静默，不输出测试结果
- 继续下一个任务

**测试失败时**：

- 输出失败详情，包含失败的测试用例、错误信息、修复建议
- 修复后重新执行测试，循环直到全部通过

**注意**：记忆写入通过**显式调用** lingxi-memory 子代理处理（在提示中使用 `/lingxi-memory` 或自然语言「使用 lingxi-memory 子代理…」）；本 Skill 不包含捕获与写入逻辑。

---

## 使用场景

### 场景 1：Plan-driven 模式

用户输入：`/build 001`（存在 `001.plan.*.md` 文件）

执行流程：

1. 模式检测：检测到 plan 文件，进入 Plan-driven 模式
2. 读取输入（req、plan、testcase）
3. 按 plan 任务清单顺序执行
4. 编写测试脚本（基于 testcase）
5. 执行单元测试（循环修复）
6. 文档同步（基于 plan 清单）
7. 快速 E2E 冒烟测试（可选，基于语义判断）

### 场景 2：Agent-driven 模式

用户输入：`/build 001`（不存在 plan 文件）

执行流程：

1. 模式检测：未检测到 plan 文件，进入 Agent-driven 模式
2. 读取输入（仅 req）
3. Agent 自行拆解任务
4. 代码实现
5. 测试框架检测与安装（如需要）
6. 编写测试脚本（基于 req 验收标准）
7. 执行单元测试（循环修复）
8. 文档同步（Agent 识别）
9. 快速 E2E 冒烟测试（可选，基于语义判断）

---

## 注意事项

1. **记忆写入**：记忆写入通过**显式调用** lingxi-memory 子代理处理（`/lingxi-memory` 或自然语言提及），本 Skill 不包含捕获与写入逻辑
2. **测试循环**：必须循环修复直到所有测试通过，才能继续下一个任务
3. **模式选择**：根据是否存在 plan 文件自动选择模式，无需用户指定
4. **文档同步**：确保代码与文档保持一致

---

## 与 Commands 的协作

本 Skill 由 `/build` 命令自动激活（taskId 可选），执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。

---

## 参考

- **原 build.md 命令**：`.cursor/commands/build.md`（备份在 `.cursor/commands-backup/build.md`）
- **记忆写入**：`.cursor/agents/lingxi-memory.md`
- **记忆注入**：`.cursor/skills/memory-retrieve/SKILL.md`
