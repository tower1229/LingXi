---
name: build-executor
description: 当执行 /build 001 命令时自动激活，负责代码实现、测试编写和执行。
---

# Build Executor

## Instructions

### 1. 模式检测（自动）

执行 `/build <taskId>` 时，自动检测执行模式：

1. **检测 plan 文件**：
   - 扫描 `.cursor/.lingxi/requirements/` 目录
   - 查找 `<taskId>.plan.*.md` 文件（如 `001.plan.*.md`）

2. **模式判断**：
   - **存在 plan 文件** → Plan-driven 模式
   - **不存在 plan 文件** → Agent-driven 模式

3. **模式提示**：
   - 静默检测，在开始执行时输出当前模式（如："检测到 plan 文档，进入 Plan-driven 模式"）

### 2. Plan-driven 模式执行逻辑（有 plan 时）

#### 2.1 读取输入

- `.cursor/.lingxi/requirements/<taskId>.req.<标题>.md`
- `.cursor/.lingxi/requirements/<taskId>.plan.<标题>.md`
- `.cursor/.lingxi/requirements/<taskId>.testcase.<标题>.md`

#### 2.2 代码实现

- 按 req 的技术方案实现功能
- 按 plan 的任务清单顺序执行开发任务
- 遵循 plan 中的依赖关系和执行顺序

#### 2.3 编写测试脚本

- 读取 `<taskId>.testcase.<标题>.md`
- 基于测试用例文档编写测试脚本
- 遵循项目测试框架（plan 中检测到的框架）
- 按模块组织：模块完成后编写并执行对应测试

#### 2.4 执行单元测试（循环修复直到全部通过）

- 模块完成后执行单元测试
- 记录测试执行结果（通过/失败）
- **如果测试失败**：
  - 分析失败原因，定位 bug
  - 修复 bug
  - 重新执行单元测试
  - **循环执行**：修复 → 测试 → 修复 → 测试，直到所有单元测试全部通过
- **只有所有单元测试通过后，才继续下一个模块或任务**

#### 2.5 文档同步（plan 中的任务）

- 读取 plan 中的文档同步任务清单
- 基于代码变更自动更新相关文档：
  - 扫描代码注释、类型定义
  - 提取接口信息、模块结构
  - 更新文档对应章节
- 同步完成后标记任务完成

### 3. Agent-driven 模式执行逻辑（无 plan 时）

#### 3.1 读取输入

- `.cursor/.lingxi/requirements/<taskId>.req.<标题>.md`（仅）

#### 3.2 任务拆解（Agent 决策）

- 基于 req 的功能需求，Agent 自行拆解为可执行的子任务
- 识别功能模块、依赖关系、执行顺序
- 动态决策实现路径（在无 plan 的情况下）

#### 3.3 代码实现

- 按 req 的技术方案实现功能
- 按 Agent 拆解的任务顺序执行
- Agent 自行判断实现细节（req 中不含实现细节）

#### 3.4 测试框架检测（Agent 决策）

- 检测项目中现有的测试框架（同 plan 阶段的检测逻辑）：
  - 检查 `package.json` 的 `devDependencies`（jest, vitest, mocha, jasmine 等）
  - 检查项目根目录的测试配置文件（`jest.config.js`, `vitest.config.ts`, `mocha.opts` 等）
  - 检查测试目录结构（`tests/`, `__tests__/`, `test/`, `spec/` 等）
  - 检查测试文件模式（`*.test.js`, `*.spec.ts`, `*.test.tsx` 等）
- 如无框架，Agent 自行决定是否安装 vitest（推荐安装）
- 如安装，执行安装流程（同 plan 阶段）

#### 3.5 编写测试脚本（基于 req 验收标准）

- 基于 req 的验收标准编写测试用例（而非 testcase 文档）
- 覆盖 req 中定义的功能验收清单
- 遵循检测到的测试框架
- 按模块组织：模块完成后编写并执行对应测试

#### 3.6 执行单元测试（循环修复直到全部通过）

- 模块完成后执行单元测试
- 记录测试执行结果（通过/失败）
- **如果测试失败**：
  - 分析失败原因，定位 bug
  - 修复 bug
  - 重新执行单元测试
  - **循环执行**：修复 → 测试 → 修复 → 测试，直到所有单元测试全部通过
- **只有所有单元测试通过后，才继续下一个模块或任务**

#### 3.7 文档同步（Agent 识别）

- Agent 自行识别可能受本次改动影响的文档：
  - 扫描项目目录（`docs/`, `design/`, `architecture/` 等）
  - 基于代码变更识别相关文档
  - 识别技术方案文档、设计文档等
- 基于代码变更自动更新相关文档：
  - 扫描代码注释、类型定义
  - 提取接口信息、模块结构
  - 更新文档对应章节

### 4. 降级方案

**Plan-driven 模式降级**：

- 如果测试框架无法执行：输出手动测试清单（基于 testcase 文档）
- 如果文档同步无法执行：输出文档更新清单（基于 plan 清单）

**Agent-driven 模式降级**：

- 如果测试框架无法执行：输出手动测试清单（基于 req 验收标准）
- 如果文档同步无法执行：输出文档更新清单（Agent 识别的文档列表）

### 5. 模式选择建议

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 复杂任务（多模块、多依赖） | Plan-driven | 需要明确的任务拆解和依赖管理 |
| 简单任务（单一功能、无依赖） | Agent-driven | Agent 可直接判断和执行 |
| 需要明确的测试策略 | Plan-driven | 有 testcase 文档指导 |
| 需要文档同步计划 | Plan-driven | 有明确的文档清单 |
| 快速原型开发 | Agent-driven | 无需详细规划，快速迭代 |
| 生产环境功能 | Plan-driven | 需要更严格的计划和验证 |

### 6. 执行质量保证

两种模式都确保：

1. **功能完整性**：满足 req 中的所有功能需求
2. **验收标准**：通过 req 定义的验收标准
3. **代码质量**：遵循项目代码规范（由质量资产定义，通过 experience-index 匹配相关标准/经验）
4. **测试覆盖**：确保关键功能有测试覆盖
5. **文档一致性**：代码与相关文档保持一致

### 7. 测试执行规范

#### 7.1 测试执行时机

| 时机                 | 动作         | 目的         |
| -------------------- | ------------ | ------------ |
| 任务开始前           | 运行现有测试 | 确认基线正常 |
| 每完成一个实现任务后 | 运行相关测试 | 确认实现正确 |
| 进入 review 前       | 运行全部测试 | 确认无回归   |

#### 7.2 测试编写规范

编写单元测试时遵循：

| 原则             | 说明                                                     |
| ---------------- | -------------------------------------------------------- |
| **隔离测试**     | Mock 所有外部依赖（API、数据库、文件系统）               |
| **一行为一测试** | 每个测试只验证一个行为，便于定位问题                     |
| **AAA 模式**     | Arrange（准备数据）→ Act（执行操作）→ Assert（验证结果） |
| **基于规格**     | 只测试 plan/testcase 或 req 中定义的行为，不发明新行为   |

#### 7.3 测试结果记录

**测试通过时**：

- 完全静默，不输出测试结果
- 继续下一个任务

**测试失败时**：

- 输出失败详情，包含失败的测试用例、错误信息、修复建议
- 修复后重新执行测试，循环直到全部通过

**注意**：经验捕获由 `experience-capture` Skill 统一处理，本 Skill 不包含经验捕获逻辑。

---

## 使用场景

### 场景 1：Plan-driven 模式

用户输入：`/build 001`（存在 `001.plan.*.md` 文件）

执行流程：
1. 模式检测：检测到 plan 文件，进入 Plan-driven 模式
2. 读取输入（req、plan、testcase）
3. 按 plan 任务清单顺序执行
4. 编写测试脚本（基于 testcase）
5. 执行单元测试（循环修复）
6. 文档同步（基于 plan 清单）

### 场景 2：Agent-driven 模式

用户输入：`/build 001`（不存在 plan 文件）

执行流程：
1. 模式检测：未检测到 plan 文件，进入 Agent-driven 模式
2. 读取输入（仅 req）
3. Agent 自行拆解任务
4. 代码实现
5. 测试框架检测与安装（如需要）
6. 编写测试脚本（基于 req 验收标准）
7. 执行单元测试（循环修复）
8. 文档同步（Agent 识别）

---

## 注意事项

1. **经验捕获**：经验捕获由 `experience-capture` Skill 统一处理，本 Skill 不包含经验捕获逻辑
2. **测试循环**：必须循环修复直到所有测试通过，才能继续下一个任务
3. **模式选择**：根据是否存在 plan 文件自动选择模式，无需用户指定
4. **文档同步**：确保代码与文档保持一致

---

## 与 Commands 的协作

本 Skill 由 `/build 001` 命令自动激活，执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。

---

## 参考

- **原 build.md 命令**：`.cursor/commands/build.md`（备份在 `.cursor/commands-backup/build.md`）
- **经验捕获**：`.cursor/skills/experience-capture/SKILL.md`
- **经验匹配**：`.cursor/skills/experience-index/SKILL.md`
- **服务加载**：`.cursor/skills/service-loader/SKILL.md`
