---
name: build-executor
description: 当执行 /build 命令时自动激活（taskId 可选，省略时使用最新任务），负责代码实现、测试编写和执行。
---

# Build Executor

## 本 Skill 会用到的能力

读 req/plan、读编辑代码；语义搜索实现与测试；Run shell 执行测试；必要时向用户提问。

## Quick Start

- **目标**：按 req（及可选 plan）实现并通过测试。
- 模式检测 → Plan-driven/Req-driven 执行 → 测试循环 → 有产物时输出下一步建议。

## Instructions

### 1. 模式检测（自动）

执行 `/build [taskId]` 时，自动检测执行模式：

1. **确定 taskId**：
   - **如果指定 taskId**：使用指定的任务编号
   - **如果省略 taskId**：扫描 `.cursor/.lingxi/tasks/` 目录，提取所有 `*.req.*.md` 文件的编号，选取最大编号的任务

2. **检测 plan 文件**：
   - 扫描 `.cursor/.lingxi/tasks/` 目录
   - 查找 `<taskId>.plan.*.md` 文件（如 `001.plan.*.md`）

3. **模式判断**：
   - **存在 plan 文件** → Plan-driven 模式
   - **不存在 plan 文件** → Req-driven 模式

### 2. 执行逻辑（统一流程）

模式检测后，按以下顺序执行。仅在有差异的步骤用 **Plan-driven** / **Req-driven** 标注。

#### 2.1 读取输入

- 必读：`.cursor/.lingxi/tasks/<taskId>.req.<标题>.md`
- **Plan-driven**：另读 `<taskId>.plan.<标题>.md`、`<taskId>.testcase.<标题>.md`
- **Req-driven**：若存在 `<taskId>.testcase.*.md` 则一并读取；**若不存在 testcase**，先调用 **testcase-designer** skill（输入：当前 req 文档），生成完整 testcase 并写入 `<taskId>.testcase.<标题>.md`，再进入 2.2。基于 req 即可生成完整 testcase（与 plan 阶段调用 testcase-designer 的产出同构）。若 testcase-designer 不可用，则按 testcase-designer 的模板与约束基于 req 生成完整 testcase 文档后继续。

#### 2.2 任务与单元顺序、测试框架

- **Plan-driven**：任务与执行顺序来自 plan 任务清单；测试框架沿用 plan 阶段检测结果。
- **Req-driven**：Agent 基于 req 拆解为可执行子任务（识别功能模块、依赖关系、执行顺序）；若子任务 ≥3 或存在明显依赖，使用结构化任务列表并标注依赖。**测试框架**：本步检测（检查 `package.json` 的 devDependencies、根目录测试配置、测试目录与文件模式）；如无框架则 Agent 决定是否安装 vitest（推荐安装），安装流程同 plan 阶段。

#### 2.3 先测再实现（TDD）

（共用）**TDD 循环仅用于 req 验证方式为 `unit` 或 `integration` 的可测单元**。对每个此类单元，按以下四步执行，不能通过改测试来通过验收：

1. **仅编写该单元测试**（基于 testcase/req 的输入/输出/边界），不实现该单元逻辑。
2. **运行该单元测试**，确认失败或基线（未实现时应为红）。
3. **只通过修改实现**使该单元测试通过，不修改已写好的测试。
4. 该单元测试全部通过后，再进入下一单元。

使用 TDD 时不为尚不存在的功能编写 mock 实现（与 Cursor 官方 TDD 工作流一致）。

- **Plan-driven**：若 plan 中已按「Txa 编写测试 → Txb 实现」排列，则 Txa 对应步骤 1–2、Txb 对应步骤 3–4；未细分时按模块/文件划分单元并套用上述循环。
- **Req-driven**：测试规格与验收来自 req（及若已生成 testcase 则引用）；不发明未在 req/testcase 中定义的行为。

**验证方式为 `e2e` 的需求**：不在此处写单元测试，优先在 2.6 快速 E2E 冒烟或 review 阶段用 Browser 自动化执行。

**验证方式为 `manual` 或 `rubric` 的需求**：不写自动化测试；产出**可执行清单**（步骤 + 预期结果）与**证据占位**（如「手工记录」「评审打分记录」），在交付前需完成该清单并保留证据（见 2.4 后 manual/rubric 处理）。

#### 2.4 按单元循环：代码实现与测试

（共用）对每个**验证方式为 unit 或 integration** 的可测单元执行「先测再实现」循环：

- **步骤 A**：基于该单元的行为与规格**仅**编写该单元的测试脚本（不实现该单元）。**Plan-driven**：规格来自 `<taskId>.testcase.*.md`。**Req-driven**：规格来自 req 验收标准（及若已生成 testcase）。
- **步骤 B**：运行该单元测试，确认失败或基线（未实现时应为失败）。
- **步骤 C**：实现该单元，不修改已写测试。**Plan-driven**：按 plan 任务描述与 req、plan 的依赖与顺序。**Req-driven**：按 Agent 拆解的任务顺序与 req，Agent 自行判断实现细节。
- **步骤 D**：运行该单元测试，失败则只改实现、循环直到通过；通过后再进入下一单元。

**实现时**：若子任务 ≥3 或存在明显依赖，使用结构化任务列表并标注依赖。**先探索再修改**：对不熟悉模块或目录，先语义搜索或读取关键文件建立理解，再实现或修改代码。

- **循环修复**：步骤 D 中若测试失败，分析原因、只改实现、重新运行，直到该单元全部通过后再继续下一单元。
- **只有当前单元所有测试通过后，才继续下一个单元或任务**。

**manual / rubric 需求**：对 req 中验证方式为 `manual` 或 `rubric` 的 F，不写自动化测试。产出**可执行清单**（从 testcase 或 req 提取：步骤 + 预期结果；rubric 时含评分维度）与**证据占位**（如「手工记录：___」「评审打分：___」），并在本轮或交付前说明：需完成该清单并保留证据供 review 验收。

#### 2.5 文档同步

- **Plan-driven**：读取 plan 中的文档同步任务清单；基于代码变更自动更新相关文档（扫描代码注释与类型定义、提取接口与模块结构、更新文档对应章节）；同步完成后标记任务完成。
- **Req-driven**：Agent 识别可能受影响的文档（扫描 `docs/`、`design/`、`architecture/` 等）；基于代码变更自动更新相关文档（同上）；同步完成后标记任务完成。

#### 2.6 快速 E2E 冒烟测试（可选）

（共用）对 req 验证方式为 **e2e** 的需求，优先在此处或 review 阶段用 **Browser 自动化**（冒烟或完整流程）验证。

1. **触发条件判断**（AI Native 语义判断）：语义分析 req 与实现代码是否涉及前端用户交互、关键业务流程、多页面交互等；满足 E2E 特征则执行，否则静默跳过。
2. **环境准备**：检测开发服务器（常见端口 3000、3001、8080、5173 等）；未运行则检测并执行启动命令（`yarn dev`、`npm start`、`yarn start` 等）；等待就绪（最多 30 秒）；验证 Cursor Agent Browser 可用性。
3. **测试用例选择**：若存在 testcase 文档则读取其中 E2E 用例，否则基于 req 验收标准提取 1–2 个关键流程；只执行关键流程（1–2 个用例），完整 E2E 留给 review 阶段。
4. **执行冒烟测试**：使用 `@browser` + 自然语言描述执行（与 reviewer-e2e 一致）；记录通过/失败。
5. **结果处理**：通过则静默；失败则输出失败详情（失败步骤、预期 vs 实际、截图），标记 High，建议修复后继续或进入 review。
6. **降级处理**：浏览器不可用则静默跳过；服务器无法启动则输出环境建议；工具调用次数限制则记录已完成并标记"部分完成"。

**设计原则**：可选性、快速性、非阻塞性；输出遵循 [workflow-output-principles](.cursor/skills/about-lingxi/references/workflow-output-principles.md)（通过时静默，失败时输出详情）。

### 3. 降级方案

- **测试框架无法执行**：**Plan-driven** 输出手动测试清单（基于 testcase 文档）；**Req-driven** 输出手动测试清单（基于 req 验收标准）。
- **文档同步无法执行**：**Plan-driven** 输出文档更新清单（基于 plan 清单）；**Req-driven** 输出文档更新清单（Agent 识别的文档列表）。

### 4. 模式选择建议

| 场景                         | 推荐模式    | 理由                         |
| ---------------------------- | ----------- | ---------------------------- |
| 复杂任务（多模块、多依赖）   | Plan-driven | 需要明确的任务拆解和依赖管理 |
| 简单任务（单一功能、无依赖） | Req-driven  | Agent 可直接判断和执行       |
| 需要明确的测试策略           | Plan-driven | 有 testcase 文档指导         |
| 需要文档同步计划             | Plan-driven | 有明确的文档清单             |
| 快速原型开发                 | Req-driven  | 无需详细规划，快速迭代       |
| 生产环境功能                 | Plan-driven | 需要更严格的计划和验证       |

### 5. 执行质量保证

两种模式都确保：

1. **功能完整性**：满足 req 中的所有功能需求
2. **验收标准**：通过 req 定义的验收标准
3. **代码质量**：遵循项目代码规范（由记忆库沉淀；通过 sessionStart hook 注入的约定 + `memory-retrieve` 的每轮注入提供相关提醒）
4. **测试覆盖**：确保关键功能有测试覆盖
5. **文档一致性**：代码与相关文档保持一致

### 5.5 下一步建议（有产物时必须输出）

**输出时机**：**只要本步产生了代码或测试变更**（实现了需求或执行了测试，无论通过与否），**必须在当轮回复末尾**输出下一步建议；与是否在回复中展示实现/测试详情无关。若本步未做任何实现或测试（如仅做了模式检测未产生代码变更），可不包含下一步建议。

**必须包含的结构**（在回复末尾）：标题行「**下一步可尝试（选一项）**」+ 四项「**A) …（推荐）**」「**B) …**」「**C) …**」「**D) …**」；给出建议前先做质量自检（见下），根据自检结果决定 A 的推荐内容。

**质量自检维度**（给出建议前先自评当前产出）：是否已按 req/plan 实现？约定测试是否通过？是否有明显未完成项？快速 E2E 冒烟测试是否通过？

**推荐逻辑**：

- 自检通过且冒烟测试通过 → A = `/review` 做交付审查（推荐），B = `/remember` 沉淀，C = 先改代码再 review，D = 其他
- 自检通过但冒烟测试失败 → A = 修复后继续 build（推荐），B = `/review` 做完整审查，C = `/remember` 沉淀问题，D = 其他
- 自检不通过 → A = 先改代码再 review（推荐），B = `/review`，C/D = 其他

**允许动作集合**（选项仅限下列）：`/review <taskId>`、`/remember …` 沉淀、先改代码再 review、其他/跳过。

**输出格式**：标题行「**下一步可尝试（选一项）**」；四项格式「**A) 简短描述（推荐）**」「**B) 简短描述**」「**C) 简短描述**」「**D) 简短描述**」；描述中可含具体命令（如 `/review 001`），命令须来自上列允许集合。

**用户回复 A/B/C/D**：当用户下一轮仅输入 A、B、C 或 D 时，视为选择该选项，执行或引导执行对应命令。

### 6. 测试执行规范

#### 6.1 测试执行时机

| 时机                           | 动作           | 目的                        |
| ------------------------------ | -------------- | --------------------------- |
| 任务开始前                     | 运行现有测试   | 确认基线正常                |
| 为当前单元编写完测试后、实现前 | 运行该单元测试 | 确认失败/基线（先测再实现） |
| 每完成一个实现任务后           | 运行相关测试   | 确认实现正确                |
| 进入 review 前                 | 运行全部测试   | 确认无回归                  |

#### 6.2 测试编写规范

编写单元测试时遵循：

| 原则             | 说明                                                                                                         |
| ---------------- | ------------------------------------------------------------------------------------------------------------ |
| **先测再实现**   | 仅根据 testcase/req 的输入/输出/边界编写，不依赖实现；编写时该单元可未实现，运行时期望失败，再通过实现使通过 |
| **隔离测试**     | Mock 所有外部依赖（API、数据库、文件系统）                                                                   |
| **一行为一测试** | 每个测试只验证一个行为，便于定位问题                                                                         |
| **AAA 模式**     | Arrange（准备数据）→ Act（执行操作）→ Assert（验证结果）                                                     |
| **基于规格**     | 只测试 plan/testcase 或 req 中定义的行为，不发明新行为                                                       |

#### 6.3 测试结果记录

**测试通过时**：

- 完全静默，不输出测试结果
- 继续下一个任务

**测试失败时**：

- 输出失败详情，包含失败的测试用例、错误信息、修复建议
- 修复后重新执行测试，循环直到全部通过

**注意**：记忆写入通过**显式调用** lingxi-memory 子代理处理（在提示中使用 `/lingxi-memory` 或自然语言「使用 lingxi-memory 子代理…」）；本 Skill 不包含捕获与写入逻辑。

---

## 使用场景

统一流程见 **2. 执行逻辑**；以下按模式概括入口与差异。

### 场景 1：Plan-driven 模式

用户输入：`/build 001`（存在 `001.plan.*.md` 文件）

1. 模式检测 → Plan-driven
2. 读取输入（req + plan + testcase）→ 任务与顺序来自 plan → 先测再实现（TDD）→ 按单元循环 → 文档同步（plan 清单）→ 快速 E2E 冒烟（可选）

### 场景 2：Req-driven 模式

用户输入：`/build 001`（不存在 plan 文件）

1. 模式检测 → Req-driven
2. 读取输入（仅 req）→ Agent 拆解任务 + 测试框架检测 → 先测再实现（TDD）→ 按单元循环 → 文档同步（Agent 识别）→ 快速 E2E 冒烟（可选）

---

## 注意事项

1. **记忆写入**：记忆写入通过**显式调用** lingxi-memory 子代理处理（`/lingxi-memory` 或自然语言提及），本 Skill 不包含捕获与写入逻辑
2. **测试循环**：必须循环修复直到所有测试通过，才能继续下一个任务
3. **模式选择**：根据是否存在 plan 文件自动选择模式，无需用户指定
4. **文档同步**：确保代码与文档保持一致

---

## 与 Commands 的协作

本 Skill 由 `/build` 命令自动激活（taskId 可选），执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。
