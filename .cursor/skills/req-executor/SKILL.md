---
name: req-executor
description: 当执行 /req 命令时自动激活，负责需求分析、提纯、放大和任务文档生成。
---

# Req Executor

## Instructions

### 1. 项目上下文分析（执行前）

在理解需求前，先获取项目背景：

- 查看 `package.json`、`README.md` 等，了解技术栈
- 浏览项目目录结构，识别与需求相关的现有模块
- 初步判断技术可行性和需要引入的新依赖

### 2. 任务编号和标题生成

**任务编号生成规则**：

1. 扫描 `.cursor/.lingxi/requirements/` 目录
2. 提取所有 `*.req.*.md` 文件的编号（使用正则 `^(\d{3})\.req\..*\.md$`）
3. 取最大编号 +1，格式化为三位数（001, 002, ...）
4. 如果目录为空或不存在，从 001 开始
5. 编号上限为 999，超出时提示用户归档旧任务

**标题生成规则**：

- 从需求描述中提取核心关键词作为标题
- 标题限制：最多 10 个中文字符或 20 个英文字符
- 超出时自动截断并添加省略号
- 特殊字符自动替换为下划线（`/\:*?"<>|` → `_`）

### 3. 需求提纯（核心环节）

在开始类型识别和复杂度评估前，先进行需求提纯：

#### 3.1 结构化澄清

对于模糊需求，使用 5W1H 框架引导用户表达：

- **What**: 具体要做什么功能/改动
- **Why**: 为什么需要这个功能（业务驱动）
- **Who**: 目标用户是谁
- **Where**: 影响范围在哪里
- **When**: 有无时间/顺序约束
- **How**: 用户期望的交互/体验

**执行方式**：

- 如果需求描述清晰完整，静默跳过此步骤
- 如果需求描述模糊或缺失关键信息，主动提出结构化问题
- 一次性列出所有需要澄清的问题，等待用户回答后再继续

#### 3.2 隐含意图挖掘

从用户描述中提取未明说的期望：

- 分析用户描述中的关键词和上下文
- 识别可能隐含的功能需求（如"添加按钮"可能隐含"要有点击反馈、要有禁用状态"）
- 识别可能隐含的非功能需求（如性能、安全、可访问性等）

**执行方式**：

- 将识别到的隐含意图以建议形式呈现给用户确认
- 避免过度推断，只提出高置信度的隐含需求

#### 3.3 用户真实意图确认

在完成结构化澄清和隐含意图挖掘后，总结理解并确认：

- 用简洁的语言总结需求的核心目标
- 明确需求的范围边界
- 确认关键约束和成功标准

**执行方式**：

- 输出需求理解总结
- 询问用户"以上理解是否正确？"
- 等待用户确认后再继续后续分析

**静默原则**：

- 如果需求已经非常清晰（简单功能），可以静默跳过部分提纯步骤
- 但必须确保核心信息（What/Why）已明确

### 4. 类型识别与复杂度评估

#### 4.1 类型识别

| 类型     | 特征                                | 示例                             |
| -------- | ----------------------------------- | -------------------------------- |
| 纯前端   | 只涉及 UI/交互/前端状态，不涉及后端 | "优化移动端展示"、"添加按钮动画" |
| 纯后端   | 只涉及 API/服务/数据库，不涉及界面  | "优化查询性能"、"调整配额逻辑"   |
| 全栈     | 同时涉及前端和后端                  | "实现用户认证"、"新增分享功能"   |
| 简单功能 | 单一、明确、范围小                  | "修改按钮文案"、"调整错误提示"   |

#### 4.2 复杂度评估

| 复杂度 | 特征                                         |
| ------ | -------------------------------------------- |
| 简单   | 单一功能点，影响范围小，无复杂依赖           |
| 中等   | 涉及多个模块，需要前后端协作，有一定技术难度 |
| 复杂   | 架构级变更，影响全局，依赖多个系统           |

### 5. 需求放大（核心环节）

对每个需求都尝试找到最佳实践和最优方案。

#### 5.1 主动外部调研

对每个需求都尝试找到最佳实践：

- 使用 WebSearch 搜索 "best practice for X 2025/2026"、"X implementation guide"
- 使用 MCP context7 获取框架/库的官方文档和最新 API 说明
- 识别需求中的关键技术点，主动调研相关领域的主流方案

**调研内容**（req 阶段做广度调研，深度留给 plan）：

- 该领域的主流技术方案
- 常见的实现模式
- 已知的典型坑点
- 最新的最佳实践和趋势

#### 5.2 方案对比

对于有多种可行方案的需求：

- 列出 2-3 个主要备选方案
- 对比各方案的优劣（性能、复杂度、维护成本等）
- 基于项目上下文推荐最优方案
- 将对比结果融入文档的相应章节

#### 5.3 最佳实践融入

将调研到的最佳实践直接融入解决方案：

- 在"背景"中引用行业最佳实践
- 在"解决方案概述"中体现推荐方案的理由
- 在"附录"中列出关键参考来源

**输出要求**：

- 不单独写入调研报告，将知识融入任务文档的相应章节
- 复杂需求：在附录中列出关键参考来源和决策对比
- 简单需求：静默融入，不显式标注来源

**静默原则**：

- 如果需求非常简单（如"修改按钮文案"），可以静默跳过外部调研
- 但涉及新技术栈或复杂功能时，必须主动调研

### 6. 经验融入

如果 `memory-index` 匹配到相关记忆，在文档中引用，或在"非目标"中体现历史踩坑点。

**注意**：经验捕获由 `experience-capture` Skill 统一处理，本 Skill 不包含经验捕获逻辑。

### 7. 模板选择

根据类型和复杂度选择模板：

**模板选择矩阵**：

| 类型     | 复杂度    | 包含章节                                                                             |
| -------- | --------- | ------------------------------------------------------------------------------------ |
| 简单功能 | 任意      | 概述、目标、功能需求、验收清单                                                       |
| 纯前端   | 简单      | 概述、目标、用户故事、UI 交互规范、验收清单                                          |
| 纯前端   | 中等/复杂 | 概述、目标、用户故事、功能需求、UI 交互规范、依赖与集成、验收清单                    |
| 纯后端   | 简单      | 概述、目标、用户故事、API 规范（如涉及）、技术可行性、验收清单                       |
| 纯后端   | 中等/复杂 | 概述、目标、用户故事、功能需求、API 规范、数据模型、依赖与集成、技术可行性、验收清单 |
| 全栈     | 任意      | 完整模板（所有章节）                                                                 |

**决策规则**：

- **UI 交互规范**（前端需求）：描述用户交互流程、界面布局、状态变化等，不涉及具体实现细节
- **API 规范**（后端需求）：定义接口契约、请求/响应格式、错误码等，不涉及具体实现
- **数据模型**（后端中等+）：定义核心数据结构、字段含义、约束条件等
- **依赖与集成**（中等+复杂度）：列出外部依赖、需要集成的系统/服务、集成方式概述
- **技术可行性**（后端需求）：评估技术难点、风险点、可行性分析
- req 阶段定义"做什么"和"与什么集成"，详细实现细节留给 plan 和 build

### 8. Requirement 文档生成

根据选择的模板生成 req 文档。

#### 完整模板（全栈或复杂需求）

```markdown
# 001.req.<标题>.md

| 属性     | 值                        |
| -------- | ------------------------- |
| 版本     | 1.0                       |
| 状态     | 草稿                      |
| 创建日期 | {DATE}                    |
| 需求类型 | [前端/后端/全栈/简单功能] |
| 复杂度   | [简单/中等/复杂]          |

---

## 1. 概述

### 1.1 背景

- 为什么需要这个功能？业务驱动是什么？
- 引用行业最佳实践（如适用）

### 1.2 问题描述

- 什么被认为是问题？痛点识别的价值判断

### 1.3 解决方案概述（不含技术实现细节）

- 为什么选择这个方向？体现的设计原则
- 技术选型（框架/库/工具）
- 架构思路（分层、模块划分）
- 关键技术点（核心算法/设计模式）
- **技术方案不包含实现细节**（具体代码、文件路径、函数签名）

---

## 2. 目标与指标

### 2.1 目标

| 编号 | 目标 | 优先级   |
| ---- | ---- | -------- |
| G1   | ...  | 必须实现 |

### 2.2 非目标

> 明确列出"容易被误解为需求范围内，但实际不做"的内容。
> 体现历史踩坑点（如适用）

### 2.3 成功标准（必须可验证）

| 标准 | 描述 | 验证方式           |
| ---- | ---- | ------------------ |
| ...  | ...  | 测试/脚本/手工步骤 |

---

## 3. 用户故事（至少 1 条）

### US-1: ...

**作为** ...
**我想要** ...
**以便** ...

**验收标准：**

- [ ] ...

---

## 4. 功能需求

| 编号 | 需求描述 | 实现方案            | 验收标准     | 优先级   |
| ---- | -------- | ------------------- | ------------ | -------- |
| F1   | ...      | 关键文件 + 实现模式 | 可验证的标准 | 必须实现 |

**实现方案列内容要求**：

- **关键文件**：需要修改/创建的文件路径（指针优先，如 `src/components/Button.tsx`）
- **实现模式**：推荐的代码组织方式或参考指针（简洁描述，如"使用 React Hook 管理状态"）
- **简洁原则**：指针优先，详细实现细节留给 build 阶段

---

## 5. UI 交互规范（前端需求）

### 5.1 交互流程

描述用户操作流程和界面状态变化。

### 5.2 界面布局

描述关键界面的布局结构、组件位置、响应式要求等。

### 5.3 状态说明

描述界面状态（加载、成功、错误、空状态等）及其展示方式。

---

## 6. API 规范（后端需求）

### 6.1 接口列表

| 接口路径   | 方法         | 功能描述 | 请求参数 | 响应格式 |
| ---------- | ------------ | -------- | -------- | -------- |
| `/api/...` | GET/POST/... | ...      | ...      | ...      |

### 6.2 错误码定义

| 错误码 | 说明 | HTTP 状态码 |
| ------ | ---- | ----------- |
| ...    | ...  | ...         |

---

## 7. 数据模型（后端中等+复杂度）

### 7.1 核心实体

| 实体名称 | 字段 | 类型 | 说明 | 约束 |
| -------- | ---- | ---- | ---- | ---- |
| ...      | ...  | ...  | ...  | ...  |

### 7.2 关系说明

描述实体间的关系和约束。

---

## 8. 依赖与集成（中等+复杂度）

### 8.1 外部依赖

- 第三方库/服务：...
- 内部服务依赖：...

### 8.2 集成方式

描述与外部系统/服务的集成方式概述。

---

## 9. 技术可行性（后端需求）

### 9.1 技术难点

列出可能的技术难点和挑战。

### 9.2 风险评估

评估技术风险点和缓解措施。

### 9.3 可行性结论

综合评估技术可行性。

---

## 10. 验收检查清单

- [ ] ...

---

## 11. 附录（复杂需求）

### 11.1 外部参考

- [参考 1]（来源：xxx）
- [参考 2]（来源：xxx）

### 11.2 关键决策记录

| 决策点 | 备选方案 | 最终选择 | 理由 |
| ------ | -------- | -------- | ---- |
| ...    | A / B    | A        | ...  |
```

#### 简化模板（简单功能）

```markdown
# 001.req.<标题>.md

| 属性     | 值       |
| -------- | -------- |
| 版本     | 1.0      |
| 创建日期 | {DATE}   |
| 需求类型 | 简单功能 |
| 复杂度   | 简单     |

---

## 1. 概述

### 1.1 背景

### 1.2 问题描述

### 1.3 解决方案概述

---

## 2. 目标

| 编号 | 目标 | 优先级   |
| ---- | ---- | -------- |
| G1   | ...  | 必须实现 |

---

## 3. 功能需求

| 编号 | 需求描述 | 实现方案            | 验收标准     | 优先级   |
| ---- | -------- | ------------------- | ------------ | -------- |
| F1   | ...      | 关键文件 + 实现模式 | 可验证的标准 | 必须实现 |

---

## 4. 验收检查清单

- [ ] ...
```

#### 文件命名约定

- 格式：`001.req.<标题>.md`（三位数编号 + 类型 + 标题，标题 10 字以内）

### 9. Fail Fast

如果必要信息缺失，一次性列出问题并给出 2-3 个选项，等待用户选择后再写入。

**必要信息**（缺失必须询问）：功能目标、目标用户（前端需求）、核心场景（前端需求）

**重要信息**（模糊建议澄清）：成功标准、优先级、特殊约束

### 10. 信息汇总

在写入前，将收集的信息汇总为可执行决策：

- **需求澄清结论**：目标/范围/成功标准的最终表述
- **关键决策点**（中等+）：备选方案、推荐方案、理由
- **风险与对策**（复杂）：按影响排序，给出缓解措施

---

## 使用场景

### 场景 1：简单功能

用户输入：`/req 修改按钮文案`

执行流程：
1. 项目上下文分析（静默）
2. 任务编号和标题生成
3. 需求提纯（静默跳过，需求清晰）
4. 类型识别：简单功能
5. 复杂度评估：简单
6. 需求放大（静默跳过，简单功能）
7. 经验融入（如有匹配）
8. 模板选择：简单功能模板
9. 文档生成

### 场景 2：复杂全栈需求

用户输入：`/req 实现用户认证功能`

执行流程：
1. 项目上下文分析
2. 任务编号和标题生成
3. 需求提纯（5W1H、隐含意图挖掘、用户确认）
4. 类型识别：全栈
5. 复杂度评估：中等/复杂
6. 需求放大（外部调研、方案对比、最佳实践融入）
7. 记忆融入（通过 memory-index）
8. 模板选择：完整模板
9. 文档生成

---

## 注意事项

1. **经验捕获**：经验捕获由 `experience-capture` Skill 统一处理，本 Skill 不包含经验捕获逻辑
2. **静默原则**：简单需求静默跳过部分步骤，复杂需求必须执行所有步骤
3. **Fail Fast**：必要信息缺失时必须询问，不猜测
4. **文档质量**：生成的 req 文档应该结构清晰、内容完整，符合需求分析的设计目标

---

## 与 Commands 的协作

本 Skill 由 `/req` 命令自动激活，执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。

---

## 参考

- **经验捕获**：`.cursor/skills/experience-capture/SKILL.md`
- **记忆匹配**：`.cursor/skills/memory-index/SKILL.md`
