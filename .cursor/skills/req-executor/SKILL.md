---
name: req-executor
description: 当执行 /req 命令时自动激活，负责需求分析、提纯、放大和任务文档生成。
---

# Req Executor

## 本 Skill 会用到的能力

读项目文件（package.json、README、目录结构）；语义搜索代码库；WebSearch / context7 做最佳实践调研；必要时用 Ask questions 澄清需求。

## Quick Start

- **目标**：产出一份符合模板的 req 文档。
- 项目上下文分析 → 任务编号/标题生成 → 需求提纯 → 类型与复杂度评估 → 需求放大 → 记忆融入 → 按需求类型选模板生成文档（见 references）→ 有产物时输出下一步建议。

## Instructions

### 1. 项目上下文分析（执行前）

在理解需求前，先获取项目背景：

- 查看 `package.json`、`README.md` 等，了解技术栈
- 浏览项目目录结构，识别与需求相关的现有模块
- 初步判断技术可行性和需要引入的新依赖

### 2. 任务编号和标题生成

**任务编号生成规则**：

1. 扫描 `.cursor/.lingxi/tasks/` 目录
2. 提取所有 `*.req.*.md` 文件的编号（使用正则 `^(\d{3})\.req\..*\.md$`）
3. 取最大编号 +1，格式化为三位数（001, 002, ...）
4. 如果目录为空或不存在，从 001 开始
5. 编号上限为 999，超出时提示用户归档旧任务

**标题生成规则**：

- 从需求描述中提取核心关键词作为标题
- 标题限制：最多 10 个中文字符或 20 个英文字符
- 超出时自动截断并添加省略号
- 特殊字符自动替换为下划线（`/\:*?"<>|` → `_`）

### 3. 需求提纯（核心环节）

在开始类型识别和复杂度评估前，先进行需求提纯：

#### 3.1 结构化澄清

对于模糊需求，使用 5W1H 框架引导用户表达：

- **What**: 具体要做什么功能/改动
- **Why**: 为什么需要这个功能（业务驱动）
- **Who**: 目标用户是谁
- **Where**: 影响范围在哪里
- **When**: 有无时间/顺序约束
- **How**: 用户期望的交互/体验

**执行方式**：

- 如果需求描述清晰完整，静默跳过此步骤
- 如果需求描述模糊或缺失关键信息，主动提出结构化问题
- 一次性列出所有需要澄清的问题，等待用户回答后再继续

#### 3.2 隐含意图挖掘

从用户描述中提取未明说的期望：

- 分析用户描述中的关键词和上下文
- 识别可能隐含的功能需求（如"添加按钮"可能隐含"要有点击反馈、要有禁用状态"）
- 识别可能隐含的非功能需求（如性能、安全、可访问性等）

**执行方式**：

- 将识别到的隐含意图以建议形式呈现给用户确认
- 避免过度推断，只提出高置信度的隐含需求

#### 3.3 用户真实意图确认

在完成结构化澄清和隐含意图挖掘后，总结理解并确认：

- 用简洁的语言总结需求的核心目标
- 明确需求的范围边界
- 确认关键约束和成功标准

**执行方式**：

- 输出需求理解总结
- 询问用户"以上理解是否正确？"
- 等待用户确认后再继续后续分析

输出遵循 [workflow-output-principles](.cursor/skills/about-lingxi/references/workflow-output-principles.md)。需求已非常清晰时可静默跳过部分提纯步骤，但必须确保核心信息（What/Why）已明确。

### 4. 类型识别与复杂度评估

#### 4.1 类型识别

| 类型     | 特征                                | 示例                             |
| -------- | ----------------------------------- | -------------------------------- |
| 纯前端   | 只涉及 UI/交互/前端状态，不涉及后端 | "优化移动端展示"、"添加按钮动画" |
| 纯后端   | 只涉及 API/服务/数据库，不涉及界面  | "优化查询性能"、"调整配额逻辑"   |
| 全栈     | 同时涉及前端和后端                  | "实现用户认证"、"新增分享功能"   |
| 简单功能 | 单一、明确、范围小                  | "修改按钮文案"、"调整错误提示"   |

#### 4.2 复杂度评估

| 复杂度 | 特征                                         |
| ------ | -------------------------------------------- |
| 简单   | 单一功能点，影响范围小，无复杂依赖           |
| 中等   | 涉及多个模块，需要前后端协作，有一定技术难度 |
| 复杂   | 架构级变更，影响全局，依赖多个系统           |

当需求明显跨多模块、多文件或复杂度为中等/复杂时，在产出或下一步建议中可提示「建议先执行 /plan 拆解后再 /build」；简单任务可直接推荐 /build。

### 5. 需求放大（核心环节）

对每个需求都尝试找到最佳实践和最优方案。

#### 5.1 主动外部调研

对每个需求都尝试找到最佳实践：

- 使用 WebSearch 搜索 "best practice for X 2025/2026"、"X implementation guide"
- 使用 MCP context7 获取框架/库的官方文档和最新 API 说明
- 识别需求中的关键技术点，主动调研相关领域的主流方案

**调研内容**（req 阶段做广度调研，深度留给 plan）：

- 该领域的主流技术方案
- 常见的实现模式
- 已知的典型坑点
- 最新的最佳实践和趋势

#### 5.2 方案对比

对于有多种可行方案的需求：

- 列出 2-3 个主要备选方案
- 对比各方案的优劣（性能、复杂度、维护成本等）
- 基于项目上下文推荐最优方案
- 将对比结果融入文档的相应章节

#### 5.3 最佳实践融入

将调研到的最佳实践直接融入解决方案：

- 在"背景"中引用行业最佳实践
- 在"解决方案概述"中体现推荐方案的理由
- 在"附录"中列出关键参考来源

**输出要求**：

- 不单独写入调研报告，将知识融入任务文档的相应章节
- 复杂需求：在附录中列出关键参考来源和决策对比
- 简单需求：静默融入，不显式标注来源

需求非常简单（如"修改按钮文案"）时可静默跳过外部调研；涉及新技术栈或复杂功能时必须主动调研。

### 6. 记忆融入

如果每轮注入（sessionStart hook 注入的约定 + `memory-retrieve`）检索到相关记忆，在文档中引用，或在“非目标/风险”中体现历史踩坑点。

**注意**：记忆写入通过**显式调用** lingxi-memory 子代理处理（在提示中使用 `/lingxi-memory` 或自然语言「使用 lingxi-memory 子代理…」）；本 Skill 不包含捕获与写入逻辑。

### 7. 模板选择

根据类型和复杂度选择模板：

**模板选择矩阵**：

| 类型     | 复杂度    | 包含章节                                                                             |
| -------- | --------- | ------------------------------------------------------------------------------------ |
| 简单功能 | 任意      | 概述、目标、功能需求、验收清单                                                       |
| 纯前端   | 简单      | 概述、目标、用户故事、UI 交互规范、验收清单                                          |
| 纯前端   | 中等/复杂 | 概述、目标、用户故事、功能需求、UI 交互规范、依赖与集成、验收清单                    |
| 纯后端   | 简单      | 概述、目标、用户故事、API 规范（如涉及）、技术可行性、验收清单                       |
| 纯后端   | 中等/复杂 | 概述、目标、用户故事、功能需求、API 规范、数据模型、依赖与集成、技术可行性、验收清单 |
| 全栈     | 任意      | 完整模板（所有章节）                                                                 |

**决策规则**：

- **UI 交互规范**（前端需求）：描述用户交互流程、界面布局、状态变化等，不涉及具体实现细节
- **API 规范**（后端需求）：定义接口契约、请求/响应格式、错误码等，不涉及具体实现
- **数据模型**（后端中等+）：定义核心数据结构、字段含义、约束条件等
- **依赖与集成**（中等+复杂度）：列出外部依赖、需要集成的系统/服务、集成方式概述
- **技术可行性**（后端需求）：评估技术难点、风险点、可行性分析
- req 阶段定义"做什么"和"与什么集成"，详细实现细节留给 plan 和 build

### 8. Requirement 文档生成

根据选择的模板生成 req 文档。生成时**按需求类型**查阅 references 中的模板，不要求在 SKILL 内复述模板全文。

- **全栈或复杂需求**：使用 [references/req-doc-template-full.md](references/req-doc-template-full.md)。
- **简单功能**：使用 [references/req-doc-template-simple.md](references/req-doc-template-simple.md)。

#### 文件命名约定

- 格式：`001.req.<标题>.md`（三位数编号 + 类型 + 标题，标题 10 字以内）

### 9. Fail Fast

如果必要信息缺失，一次性列出问题并给出 2-3 个选项，等待用户选择后再写入。

**必要信息**（缺失必须询问）：功能目标、目标用户（前端需求）、核心场景（前端需求）

**重要信息**（模糊建议澄清）：成功标准、优先级、特殊约束

### 10. 信息汇总

在写入前，将收集的信息汇总为可执行决策：

- **需求澄清结论**：目标/范围/成功标准的最终表述
- **关键决策点**（中等+）：备选方案、推荐方案、理由
- **风险与对策**（复杂）：按影响排序，给出缓解措施

### 11. 下一步建议（有产物时必须输出）

**输出时机**：**只要本步写入了 req 文档**（即向 `.cursor/.lingxi/tasks/` 写入了 `*.req.*.md`），**必须在当轮回复末尾**输出下一步建议；与是否在回复中贴出需求摘要无关。若本步未写入任何 req 文档（如仅做了澄清未落盘），可不包含下一步建议。

**必须包含的结构**（在回复末尾）：标题行「**下一步可尝试（选一项）**」+ 四项「**A) …（推荐）**」「**B) …**」「**C) …**」「**D) …**」；给出建议前先做质量自检（见下），根据自检结果决定 A 的推荐内容。

**质量自检维度**（给出建议前先自评当前产出）：目标与非目标是否清晰？是否有可验证的验收标准？实现方案是否含关键文件或可执行指引？边界是否清晰？

**推荐逻辑**：自检通过（满足关键维度、无明显缺口）→ 若需求明显跨多模块、多文件或复杂度为中等/复杂，A 推荐 `/plan` 先拆解再 `/build`；简单任务可推荐直接 `/build`；B = `/review-req` 查漏补缺，C/D 从允许集合选。自检不通过（存在明显缺失或模糊）→ A = `/review-req` 或补充修改 req（推荐），B = `/plan`，C/D 从允许集合选。

**允许动作集合**（选项仅限下列）：`/review-req <taskId>`、`/plan <taskId>`、`/build <taskId>`、补充/修改 req、其他/跳过。

**输出格式**：标题行「**下一步可尝试（选一项）**」；四项格式「**A) 简短描述（推荐）**」「**B) 简短描述**」「**C) 简短描述**」「**D) 简短描述**」；描述中可含具体命令（如 `/build 001`），命令须来自上列允许集合。

**用户回复 A/B/C/D**：当用户下一轮仅输入 A、B、C 或 D 时，视为选择该选项，执行或引导执行对应命令（如提示用户执行该选项中的 `/plan 001`）。

---

## 使用场景

### 场景 1：简单功能

用户输入：`/req 修改按钮文案`

执行流程：

1. 项目上下文分析（静默）
2. 任务编号和标题生成
3. 需求提纯（静默跳过，需求清晰）
4. 类型识别：简单功能
5. 复杂度评估：简单
6. 需求放大（静默跳过，简单功能）
7. 经验融入（如有匹配）
8. 模板选择：简单功能模板
9. 文档生成

### 场景 2：复杂全栈需求

用户输入：`/req 实现用户认证功能`

执行流程：

1. 项目上下文分析
2. 任务编号和标题生成
3. 需求提纯（5W1H、隐含意图挖掘、用户确认）
4. 类型识别：全栈
5. 复杂度评估：中等/复杂
6. 需求放大（外部调研、方案对比、最佳实践融入）
7. 记忆融入（通过每轮注入：sessionStart hook 注入的约定 + `memory-retrieve`）
8. 模板选择：完整模板
9. 文档生成

---

## 注意事项

1. **记忆写入**：记忆写入通过**显式调用** lingxi-memory 子代理处理（`/lingxi-memory` 或自然语言提及），本 Skill 不包含捕获与写入逻辑
2. **输出与静默**：遵循 workflow-output-principles；简单需求可静默跳过部分步骤，复杂需求必须执行所有步骤
3. **Fail Fast**：必要信息缺失时必须询问，不猜测
4. **文档质量**：生成的 req 文档应该结构清晰、内容完整，符合需求分析的设计目标

---

## 与 Commands 的协作

本 Skill 由 `/req` 命令自动激活，执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。

---

## 参考

- **记忆写入**：`.cursor/agents/lingxi-memory.md`
- **记忆注入**：`.cursor/skills/memory-retrieve/SKILL.md`
