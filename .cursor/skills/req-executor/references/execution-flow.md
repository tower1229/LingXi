# Req Executor — 完整执行流程

本文档为 req-executor 的详细步骤、使用场景与注意事项；SKILL.md 仅保留意图与关键约束。

## Instructions

### 1. 项目上下文分析（执行前）

在理解需求前，先了解代码库：

- 查看 `package.json`、`README.md` 等，了解技术栈
- 浏览项目目录结构，识别与需求相关的现有模块
- 初步判断技术可行性和需要引入的新依赖

### 2. 任务编号和标题生成

**任务编号生成规则**：

1. 执行 `node .cursor/skills/req-executor/scripts/next-task-id.mjs` 获取下一个三位数编号；从项目根目录执行
2. 脚本输出即为编号（如 `009`），直接使用
3. 若脚本退出码非 0（如已达 999 上限），提示用户归档旧任务

**标题生成规则**：

- 从需求描述中提取核心关键词作为标题
- 标题限制：最多 10 个中文字符或 20 个英文字符
- 超出时自动截断并添加省略号
- 特殊字符自动替换为下划线（`/\:*?"<>|` → `_`）

### 3. 需求提纯（核心环节）

在开始类型识别和复杂度评估前，先进行需求提纯：

#### 3.1 结构化澄清

对于模糊需求，使用 5W1H 框架引导用户表达：

- **What**: 具体要做什么功能/改动
- **Why**: 为什么需要这个功能（业务驱动）
- **Who**: 目标用户是谁
- **Where**: 影响范围在哪里
- **When**: 有无时间/顺序约束
- **How**: 用户期望的交互/体验

**执行方式**：

- 若需求描述清晰完整，静默跳过此步骤
- 若需澄清：使用 `ask-questions` 交互（遵循 [ask-questions](.cursor/skills/ask-questions/SKILL.md) 契约）：
  - 先识别缺失的 5W1H 维度，用多选问「哪些维度需要补充？」（options: `{id,label}`，可提供「全部跳过」）
  - 对每个需澄清的维度，尽量提供选项（如 Who：终端用户/内部管理员/双方/其他需描述）；无法选项化时再开放文本
  - 含取消选项（如 `id=cancel`，label 为「取消」），遵循无有效选择时重试的契约

#### 3.2 隐含意图挖掘

从用户描述中提取未明说的期望：

- 分析用户描述中的关键词和上下文
- 识别可能隐含的功能需求（如"添加按钮"可能隐含"要有点击反馈、要有禁用状态"）
- 识别可能隐含的非功能需求（如性能、安全、可访问性等）

**执行方式**：

- 将识别到的隐含意图以建议形式呈现，用 `ask-questions` 交互确认（options: `{id,label}`）
- 避免过度推断，只提出高置信度的隐含需求

#### 3.3 用户真实意图确认

在完成结构化澄清和隐含意图挖掘后，总结理解并确认：

- 用简洁的语言总结需求的核心目标
- 明确需求的范围边界
- 确认关键约束和成功标准

**执行方式**：

- 输出需求理解总结
- 用 `ask-questions` 交互确认（options: `{id,label}`）
- 遵循 ask-questions 契约

输出遵循 [workflow-output-principles](.cursor/skills/about-lingxi/references/workflow-output-principles.md)。需求已非常清晰时可静默跳过部分提纯步骤，但必须确保核心信息（What/Why）已明确。

### 4. 类型识别与复杂度评估

#### 4.1 类型识别

| 类型     | 特征                                | 示例                             |
| -------- | ----------------------------------- | -------------------------------- |
| 纯前端   | 只涉及 UI/交互/前端状态，不涉及后端 | "优化移动端展示"、"添加按钮动画" |
| 纯后端   | 只涉及 API/服务/数据库，不涉及界面  | "优化查询性能"、"调整配额逻辑"   |
| 全栈     | 同时涉及前端和后端                  | "实现用户认证"、"新增分享功能"   |
| 简单功能 | 单一、明确、范围小                  | "修改按钮文案"、"调整错误提示"   |
| 其他     | 无法归入以上四类且不适合下述标签    | 兜底选项                         |

**识别与标签**：

- 先按上表判定主类型（纯前端/纯后端/全栈/简单功能）；对外展示时统一为前端/后端/全栈/简单功能。
- 若需求以**文档编辑**为主（如只改 README、规范、设计文档），主类型选「简单功能」或最贴近的一项，并勾选特性标签 **文档为主**。
- 若需求以**库/SDK 纯逻辑**为主（无 UI、无 HTTP API），主类型选「后端」或「简单功能」，并勾选特性标签 **库/SDK**。
- 若无法归入四类且不适合上述标签，主类型选 **其他**。
- 文档头部元数据：主类型必填；**特性标签**为可选行，有则写「文档为主」或「库/SDK」（多选用逗号分隔），无则省略该行。

#### 4.2 复杂度评估

| 复杂度 | 特征                                         |
| ------ | -------------------------------------------- |
| 简单   | 单一功能点，影响范围小，无复杂依赖           |
| 中等   | 涉及多个模块，需要前后端协作，有一定技术难度 |
| 复杂   | 架构级变更，影响全局，依赖多个系统           |

当需求明显跨多模块、多文件或复杂度为中等/复杂时，在产出或下一步建议中可提示「建议先执行 /plan 拆解后再 /build」；简单任务可直接推荐 /build。

### 5. 需求放大（核心环节）

对每个需求都尝试找到最佳实践和最优方案。

#### 5.1 主动外部调研

对每个需求都尝试找到最佳实践：

- 使用 WebSearch 搜索 "best practice for X 2025/2026"、"X implementation guide"
- 使用 MCP context7 获取框架/库的官方文档和最新 API 说明
- 识别需求中的关键技术点，主动调研相关领域的主流方案

**调研内容**（req 阶段做广度调研，深度留给 plan）：

- 该领域的成熟技术方案
- 常见的实现模式
- 已知的典型坑点
- 最新的最佳实践和趋势

#### 5.2 方案对比

对于有多种可行方案的需求：

- 列出 2-3 个主要备选方案
- 对比各方案的优劣（性能、复杂度、维护成本等）
- 基于项目上下文推荐最优方案
- 将对比结果融入文档的相应章节

**品味嗅探**：若两个方案质量、效果接近，差异主要在「品味」偏好（如设计理念、开发原则、体验 vs 成本取舍等），用 `ask-questions` 构建选择题向用户提问，嗅探其偏好；拟提问前调用 memory-retrieve，传入 Agent 构建的决策点描述，若检索到相关记忆则不再问；用户选择后若可沉淀为品味，经 taste-recognition 产出 payload 后交 lingxi-memory 写入。

#### 5.3 最佳实践融入

将调研到的最佳实践直接融入解决方案：

- 在"背景"中引用行业最佳实践
- 在"解决方案概述"中体现推荐方案的理由
- 在"附录"中列出关键参考来源

**输出要求**：

- 不单独写入调研报告，将知识融入任务文档的相应章节
- 复杂需求：在附录中列出关键参考来源和决策对比
- 简单需求：静默融入，不显式标注来源

需求非常简单（如"修改按钮文案"）时可静默跳过外部调研；涉及新技术栈或复杂功能时必须主动调研。

### 6. 模板选择

根据类型和复杂度选择模板：

**模板选择矩阵**：

| 类型     | 复杂度    | 包含章节                                                                             |
| -------- | --------- | ------------------------------------------------------------------------------------ |
| 简单功能 | 任意      | 概述、目标、功能需求、验收清单                                                       |
| 纯前端   | 简单      | 概述、目标、用户故事、UI 交互规范、验收清单                                          |
| 纯前端   | 中等/复杂 | 概述、目标、用户故事、功能需求、UI 交互规范、依赖与集成、验收清单                    |
| 纯后端   | 简单      | 概述、目标、用户故事、API 规范（如涉及）、技术可行性、验收清单                       |
| 纯后端   | 中等/复杂 | 概述、目标、用户故事、功能需求、API 规范、数据模型、依赖与集成、技术可行性、验收清单 |
| 全栈     | 任意      | 完整模板（所有章节）                                                                 |
| 其他     | 任意      | 简单功能模板 + 按需章节（见下「按标签与其他的章节规则」）                            |

**决策规则**：

- **UI 交互规范**（前端需求）：描述用户交互流程、界面布局、状态变化等，不涉及具体实现细节
- **API 规范**（后端需求）：定义接口契约、请求/响应格式、错误码等，不涉及具体实现
- **数据模型**（后端中等+）：定义核心数据结构、字段含义、约束条件等
- **依赖与集成**（中等+复杂度）：列出外部依赖、需要集成的系统/服务、集成方式概述
- **技术可行性**（后端需求）：评估技术难点、风险点、可行性分析
- req 阶段定义"做什么"和"与什么集成"，详细实现细节留给 plan 和 build

**按标签与其他的章节规则**（在选定的基础模板上做显隐/替换）：

- **文档为主**：不要求「UI 交互规范」「API 规范」「数据模型」；建议包含「变更范围、受众、版本/发布约定」等（在概述或目标中体现或单列简短小节均可）。
- **库/SDK**：不要求「UI 交互规范」；若有对外接口，用「接口/行为约定」替代「API 规范」（描述函数/类型/行为变更即可）；「技术可行性」保留。
- **其他**：采用「简单功能」模板（见 [req-doc-template-simple.md](req-doc-template-simple.md)）+ Agent 根据需求内容勾选必要章节（至少：概述、目标、功能需求/变更说明、验收清单）；不强制 UI/API/数据模型章节。

### 7. 信息汇总（含 Fail Fast）

在写入前，将收集的信息汇总为可执行决策。**先执行 Fail Fast 检查**，必要信息齐全后再汇总。

- **Fail Fast**：若必要信息缺失（功能目标、目标用户（前端需求）、核心场景（前端需求）），一次性列出并给出 2-3 个选项，使用 `ask-questions` 交互（遵循 [ask-questions](.cursor/skills/ask-questions/SKILL.md) 契约）等待用户选择后再写入；options 使用 `{id,label}`（如「选项1」「选项2」），含取消选项（如 `id=cancel`）；无有效选择时重试当前问题。重要信息（成功标准、优先级、特殊约束）模糊时建议澄清。
- **需求澄清结论**：目标/范围/成功标准的最终表述
- **关键决策点**（中等+）：备选方案、推荐方案、理由
- **风险与对策**（复杂）：按影响排序，给出缓解措施
- **记忆融入**：若每轮注入（sessionStart hook 注入的约定 + `memory-retrieve`）检索到相关记忆，在汇总中纳入项目约定与踩坑点；文档生成时在相应章节引用，或在「非目标/风险」中体现历史踩坑点

### 8. Requirement 文档生成

根据汇总结果与选择的模板生成 req 文档。生成时**按需求类型**查阅 references 中的模板，不要求在 SKILL 内复述模板全文。

- **全栈或复杂需求**：使用 [req-doc-template-full.md](req-doc-template-full.md)。
- **简单功能**或**其他**：使用 [req-doc-template-simple.md](req-doc-template-simple.md)；主类型为「其他」时按需选章节。
- 若本步识别了特性标签（文档为主、库/SDK），在文档头部元数据中写入**特性标签**行；无标签则省略该行。

**功能需求表（每条 F）必须填写**：需求描述、实现方案、**验收标准**（Given-When-Then 或等价结构化、可二值判定）、**验证方式**（unit/integration/e2e/manual/rubric）、**边界/异常**（至少 1–2 条）、**证据形式**（测试日志/Browser/手工/评审）、**优先级**（必须/应该/可选）。

#### 文件命名约定

- 格式：`001.req.<标题>.md`（三位数编号 + 类型 + 标题，标题 10 字以内）

### 9. 下一步建议

**输出时机**：**只要本步写入了 req 文档**（即向 `.cursor/.lingxi/tasks/` 写入了 `*.req.*.md`），**必须在当轮回复末尾**输出下一步建议；与是否在回复中展示需求摘要无关。若本步未写入任何 req 文档（如仅做了澄清未写入），可不包含下一步建议。

**必须包含的结构**（在回复末尾）：标题行「**下一步可尝试（选一项）**」+ 四项「**A) …（推荐）**」「**B) …**」「**C) …**」「**D) …**」；给出建议前先做质量自检（见下），根据自检结果决定 A 的推荐内容。

**质量自检维度**（给出建议前先自评当前产出）：目标与非目标是否清晰？**是否每条 F 均有验证方式、可判定验收标准与证据形式？是否覆盖全部需求的验证方式？**实现方案是否含关键文件或可执行指引？边界/异常是否至少 1–2 条？

**推荐逻辑**：自检通过（满足关键维度、无明显缺口）→ 若需求明显跨多模块、多文件或复杂度为中等/复杂，A 推荐 `/plan` 先拆解再 `/build`；简单任务可推荐直接 `/build`；B = `/review-req` 查漏补缺，C/D 从允许集合选。自检不通过（存在明显缺失或模糊）→ A = `/review-req` 或补充修改 req（推荐），B = `/plan`，C/D 从允许集合选。

**允许动作集合**（选项仅限下列）：`/review-req <taskId>`、`/plan <taskId>`、`/build <taskId>`、补充/修改 req、其他/跳过。

**输出格式**：标题行「**下一步可尝试（选一项）**」；四项格式「**A) 简短描述（推荐）**」「**B) 简短描述**」「**C) 简短描述**」「**D) 简短描述**」；描述中可含具体命令（如 `/build 001`），命令须来自上列允许集合。

**用户回复 A/B/C/D**：当用户下一轮仅输入 A、B、C 或 D 时，视为选择该选项，执行或引导执行对应命令（如提示用户执行该选项中的 `/plan 001`）。

---

## 使用场景

### 场景 1：简单功能

用户输入：`/req 修改按钮文案`

执行流程：项目上下文分析（静默）→ 任务编号/标题 → 需求提纯（静默跳过）→ 类型识别：简单功能 → 复杂度：简单 → 需求放大（静默跳过）→ 模板选择：简单功能模板 → 信息汇总（静默，含 Fail Fast 与记忆融入）→ 文档生成 → 下一步建议。

### 场景 2：复杂全栈需求

用户输入：`/req 实现用户认证功能`

执行流程：项目上下文分析 → 任务编号/标题 → 需求提纯（5W1H、隐含意图、用户确认）→ 类型识别：全栈 → 复杂度：中等/复杂 → 需求放大（外部调研、方案对比、最佳实践融入）→ 模板选择：完整模板 → 信息汇总（含 Fail Fast、记忆融入）→ 文档生成 → 下一步建议。

---

## 注意事项

1. **记忆写入**：记忆写入通过**显式调用** lingxi-memory 子代理处理（`/lingxi-memory` 或自然语言提及），本 Skill 不包含捕获与写入逻辑
2. **无冻结状态**：不引入「需求冻结」或 Approved/Locked 等硬门禁；是否进入 plan/build 由用户决定，不在 req 文档或流程中做硬阻断
3. **输出与静默**：遵循 workflow-output-principles；简单需求可静默跳过部分步骤，复杂需求必须执行所有步骤
4. **Fail Fast**：信息汇总时若必要信息缺失必须询问，不猜测；各前置步骤发现缺失时应立即提问
5. **文档质量**：生成的 req 文档应该结构清晰、内容完整，每条 F 具备验证方式、验收标准、证据形式、边界/异常，符合需求分析的设计目标

---

## 与 Commands 的协作

本 Skill 由 `/req` 命令自动激活，执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。
