---
name: review-req-executor
description: 当执行 /review-req 命令时自动激活，负责对 req 文档进行多维度审查，辅助提升需求文档质量。
---

# Review Req Executor

## Instructions

### 1. 读取 req 文件

- 扫描 `.cursor/.lingxi/requirements/` 目录
- **如果指定 taskId**：查找 `<taskId>.req.*.md` 文件（如 `001.req.*.md`）
- **如果省略 taskId**：提取所有 `*.req.*.md` 文件的编号，选取最大编号的任务
- 如果找不到文件，输出错误信息并提供解决方案

### 2. 解析 req 元数据

从文档头部表格读取：

- **需求类型**：前端 / 后端 / 全栈 / 简单功能
- **复杂度**：简单 / 中等 / 复杂

### 3. 确定审查维度

根据需求类型和复杂度，从维度适配矩阵确定本次审查应执行的维度：

#### 维度适配矩阵

| 需求类型 | 简单   | 中等  | 复杂  |
| -------- | ------ | ----- | ----- |
| 前端     | D1, D2 | D1-D4 | D1-D5 |
| 后端     | D1, D2 | D1-D5 | D1-D5 |
| 全栈     | D1, D2 | D1-D5 | D1-D5 |
| 简单功能 | D1, D2 | -     | -     |

#### 维度定义

| 维度编号 | 维度名称   | 审查焦点                             |
| -------- | ---------- | ------------------------------------ |
| D1       | 需求完整性 | 目标、边界、用户故事、非目标是否清晰 |
| D2       | 可验证性   | 成功标准和验收标准是否可验证         |
| D3       | 方案合理性 | 技术选型和架构思路是否合理           |
| D4       | 规范完整性 | UI/API/数据模型等规范章节是否完整    |
| D5       | 风险识别   | 技术难点、外部依赖、风险是否识别     |

### 4. 执行分维度审查

#### D1 - 需求完整性（通用必选）

**检查目的**：确保需求的「做什么」和「为什么做」清晰明确

| 检查项                | 简单 | 中等 | 复杂 |
| --------------------- | :--: | :--: | :--: |
| 背景说明是否清晰      |  ✓   |  ✓   |  ✓   |
| 问题描述是否明确      |  ✓   |  ✓   |  ✓   |
| 解决方案概述是否有    |  ✓   |  ✓   |  ✓   |
| 目标是否量化可追踪    |  ✓   |  ✓   |  ✓   |
| 非目标是否明确        |  -   |  ✓   |  ✓   |
| 用户故事是否至少 1 条 |  -   |  ✓   |  ✓   |

**不检查的内容**：

- ❌ 技术实现细节（属于 plan/build）
- ❌ 代码结构设计（属于 plan/build）

---

#### D2 - 可验证性（通用必选）

**检查目的**：确保需求可以被验证，避免「做完了无法判断是否达标」

| 检查项                 | 简单 | 中等 | 复杂 |
| ---------------------- | :--: | :--: | :--: |
| 成功标准是否可验证     |  ✓   |  ✓   |  ✓   |
| 成功标准是否有验证方式 |  ✓   |  ✓   |  ✓   |
| 功能需求是否有验收标准 |  ✓   |  ✓   |  ✓   |
| 验收检查清单是否完整   |  ✓   |  ✓   |  ✓   |

**不检查的内容**：

- ❌ 测试用例设计（属于测试阶段）
- ❌ 自动化测试代码（属于 build 阶段）

---

#### D3 - 方案合理性（中等+复杂度）

**检查目的**：确保技术方向正确，避免「方向错了努力白费」

| 检查项                           | 中等 | 复杂 |
| -------------------------------- | :--: | :--: |
| 技术选型是否在解决方案概述中说明 |  ✓   |  ✓   |
| 架构思路是否清晰                 |  ✓   |  ✓   |
| 是否有方案对比（复杂需求）       |  -   |  ✓   |
| 选型理由是否说明                 |  ✓   |  ✓   |

**不检查的内容**：

- ❌ 具体代码结构（属于 plan/build）
- ❌ 性能优化细节（属于 plan/build）
- ❌ 安全实现细节（属于 plan/build）

---

#### D4 - 规范完整性（按类型触发）

**检查目的**：确保类型相关的规范章节内容完整

##### 前端需求（UI 交互规范）

| 检查项             | 简单 | 中等 | 复杂 |
| ------------------ | :--: | :--: | :--: |
| 交互流程是否描述   |  -   |  ✓   |  ✓   |
| 界面状态是否涵盖   |  -   |  ✓   |  ✓   |
| 响应式要求是否说明 |  -   |  ✓   |  ✓   |

##### 后端需求（API/数据模型）

| 检查项                | 简单 | 中等 | 复杂 |
| --------------------- | :--: | :--: | :--: |
| API 接口路径是否定义  |  ✓   |  ✓   |  ✓   |
| 请求/响应格式是否定义 |  -   |  ✓   |  ✓   |
| 错误码是否定义        |  -   |  ✓   |  ✓   |
| 数据模型是否定义      |  -   |  ✓   |  ✓   |
| 字段约束是否说明      |  -   |  -   |  ✓   |

**不检查的内容**：

- ❌ 接口具体实现（属于 build）
- ❌ 数据库索引设计（属于 plan/build）
- ❌ 缓存策略细节（属于 plan/build）

---

#### D5 - 风险识别（中等+复杂度）

**检查目的**：确保技术风险和外部依赖被识别，避免「开工后才发现做不了」

| 检查项                     | 中等 | 复杂 |
| -------------------------- | :--: | :--: |
| 外部依赖是否列出           |  ✓   |  ✓   |
| 集成方式是否概述           |  ✓   |  ✓   |
| 技术难点是否识别（后端）   |  ✓   |  ✓   |
| 风险是否有缓解思路         |  -   |  ✓   |
| 可行性结论是否明确（后端） |  ✓   |  ✓   |

**不检查的内容**：

- ❌ 详细的降级方案实现（属于 build）
- ❌ 熔断/限流配置（属于 build/运维）
- ❌ 监控告警设计（属于运维）

### 5. 输出审查结果

**输出格式**：

```markdown
## Req 文档审查结果

### 审查范围

| 项       | 值                        |
| -------- | ------------------------- |
| 需求类型 | [前端/后端/全栈/简单功能] |
| 复杂度   | [简单/中等/复杂]          |
| 审查维度 | [如 D1-D5 (5/5)]          |

### 总体评价

[3-6 行总结：文档质量如何，主要问题是什么，是否需要重大改进]

### 详细问题清单

#### D1 需求完整性

- [ ] 问题 1：...
  - **影响**：高/中/低
  - **建议**：...

#### D2 可验证性

- [ ] 问题 1：...
  - **影响**：高/中/低
  - **建议**：...

[...其他维度...]

### 改进优先级

**必须修复**（Blockers）：

- 问题 X：...

**建议修复**（High）：

- 问题 A：...

**可选优化**（Medium/Low）：

- 问题 C：...
```

### 6. 静默成功原则

- **无问题**：如果文档质量良好，无重大问题，静默输出简要总结即可
- **有问题**：发现问题时，详细列出问题清单和改进建议

### 7. 下一步建议（有输出时）

**输出时机**：仅当本次回复已有正文输出（如总体评价、问题清单等）时，在末尾追加下一步建议；纯静默成功时不追加。

**质量自检维度**（给出建议前先自评当前产出）：是否发现 Blockers/High 级别问题？文档质量是否达到可进入 plan/build 阶段的标准？

**推荐逻辑**：

- 无 Blockers/High → A = `/plan <taskId>` 或 `/build <taskId>`（推荐），B = 调整 req，C = 回头看 req，D = 其他
- 有 Blockers/High → A = 先改 req（推荐），B = `/plan` 或 `/build`，C/D = 其他

**允许动作集合**（选项仅限下列）：`/plan <taskId>`、`/build <taskId>`、调整 req、回头看 req、其他/跳过。

**输出格式**：标题行「**下一步可尝试（选一项）**」；四项格式「**A) 简短描述（推荐）**」「**B) 简短描述**」「**C) 简短描述**」「**D) 简短描述**」；描述中可含具体命令（如 `/plan 001`），命令须来自上列允许集合。

**用户回复 A/B/C/D**：当用户下一轮仅输入 A、B、C 或 D 时，视为选择该选项，执行或引导执行对应命令。

---

## 审查边界说明

### req 文档的定位

req 文档是「集设计灵感、产品构思、实现途径于一体的任务文档」，其核心职责是：

- 需求的「提纯」和「放大」
- 核心技术方案或技术决策（但不含实现细节）
- **不是详细设计文档**，实现细节留给 plan 和 build

### 不在审查范围内的内容

以下内容**不属于 req 阶段**，不应作为审查项：

| 不应审查              | 原因                 |
| --------------------- | -------------------- |
| 具体实现代码/函数签名 | 属于 build 阶段      |
| 详细性能调优方案      | 属于 plan/build 阶段 |
| 详细安全防护实现      | 属于 plan/build 阶段 |
| 测试用例设计          | 属于单独的测试阶段   |
| 部署配置/运维脚本     | 属于部署阶段         |
| 监控告警配置          | 属于运维阶段         |

---

## 使用场景

### 场景 1：简单功能审查

用户输入：`/review-req 001`（简单功能）

执行流程：

1. 读取 `001.req.*.md`
2. 解析元数据：类型=简单功能，复杂度=简单
3. 确定审查维度：D1, D2
4. 执行 D1 需求完整性审查（4 项检查）
5. 执行 D2 可验证性审查（4 项检查）
6. 输出审查结果

### 场景 2：复杂后端需求审查

用户输入：`/review-req 002`（后端复杂）

执行流程：

1. 读取 `002.req.*.md`
2. 解析元数据：类型=后端，复杂度=复杂
3. 确定审查维度：D1, D2, D3, D4, D5
4. 执行 D1 需求完整性审查（6 项检查）
5. 执行 D2 可验证性审查（4 项检查）
6. 执行 D3 方案合理性审查（4 项检查）
7. 执行 D4 规范完整性审查（5 项检查，后端）
8. 执行 D5 风险识别审查（5 项检查）
9. 输出审查结果

---

## 注意事项

1. **审查深度与 req 定位匹配**：不要审查超出 req 职责范围的内容
2. **按复杂度裁剪检查项**：简单需求只检查必要项，避免过度审查
3. **静默原则**：无问题时简要总结，有问题时详细列出
4. **明确边界**：实现细节、性能优化、安全实现等属于下游阶段

---

## 与 Commands 的协作

本 Skill 由 `/review-req` 命令自动激活（taskId 可选），执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。

---

## 参考

- **req 生成逻辑**：`.cursor/skills/req-executor/SKILL.md`
- **记忆写入**：`.cursor/agents/lingxi-memory.md`
