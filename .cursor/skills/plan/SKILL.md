---
name: plan
description: 此 Skill 基于 Requirement 生成可执行计划（任务拆解+验证方式+交付物）。当 req 完成且用户确认进入 plan 阶段时激活，写入 REQ.plan.md 并更新 INDEX。
---

# Plan

## Outputs (must write)

- `.workflow/requirements/in-progress/REQ-xxx.plan.md`
- `.workflow/requirements/INDEX.md`

**输出规则（静默成功原则）**：
- 文件写入成功：静默，不输出确认信息（如"已写入 REQ-xxx.plan.md"）
- 文件写入失败：输出错误信息
- 索引更新成功：静默，不输出确认信息

## Instructions

### 1) 读取输入

- `.workflow/requirements/in-progress/REQ-xxx.md`
- 识别需求类型（前端/后端/全栈）和复杂度

### 1.1) 补齐服务上下文（推荐）

如果需求涉及存量系统/多服务协作，参考 `service-loader` 补齐服务上下文：

- 生成/更新 `.workflow/context/tech/services/<service>.md`
- 只写"概要 + 指针 + 常见坑"，避免长文档膨胀

### 1.2) 外部知识放大（推荐）

在生成任务拆解前，针对具体技术实现进行深入调研：

**触发条件**（满足任一即触发）：

- 任务涉及第三方库/API 的使用
- 需要选择多个技术方案中的一个
- 实现细节存在不确定性

**调研工具分工**：

| 场景            | 工具         | 调研内容                                    |
| --------------- | ------------ | ------------------------------------------- |
| 方案选型/对比   | WebSearch    | "X vs Y 2024/2025"、"best practice for X"   |
| 具体库用法      | MCP context7 | 获取库的最新文档、API 说明、代码示例        |
| 常见报错/兼容性 | WebSearch    | "X common issues"、"X with Y compatibility" |

**输出要求**：

- 调研结果不单独写入
- 将最佳实践融入"任务清单"的具体步骤描述
- 将已知坑点融入"复利候选"或直接规避

### 1.3) 规范引用

生成任务时，检查项目是否有相关规范（如 `.cursor/rules/`），在任务描述中明确引用。

### 2) 任务拆解原则

#### 2.1 任务分类

根据需求类型组织任务（测试任务必选）：

| 需求类型 | 任务分类 |
|---------|---------|
| 纯前端 | 组件任务、状态任务、样式任务、**测试任务** |
| 纯后端 | API 任务、服务任务、数据任务、**测试任务** |
| 全栈 | 后端任务、前端任务、集成任务、**测试任务** |

#### 2.2 任务依赖

- 标注任务间的依赖关系（如 `依赖: T1, T2`）
- 确定执行顺序：优先实现被依赖项

#### 2.3 文件变更清单

每个任务明确列出需要创建/修改的文件：

```markdown
- [ ] T1: 实现用户服务
  - 创建: `src/services/user.ts`
  - 修改: `src/services/index.ts`
```

### 3) 测试设计（强化）

#### 3.1 行为提取

从需求中提取可测试行为：

- 只提取适合单元测试的行为（纯逻辑、服务层、工具函数）
- 过滤掉 UI 交互、API 集成、视觉效果等（留给集成测试/手工验证）
- 不发明或推断未明确说明的行为

#### 3.2 测试规格

对每个可测试行为，定义结构化规格：

| 行为 | 输入 | 预期输出 | 边界/错误条件 |
|-----|-----|---------|--------------|
| B1: 计算折扣 | price=100, discount=0.1 | 90 | discount<0 抛错 |
| B2: 验证邮箱 | "test@example.com" | true | 空字符串返回 false |

#### 3.3 测试类型选择

| 验证类型 | 适用场景 | 内容要求 |
|---------|---------|---------|
| 单元测试 | 纯函数、服务逻辑、工具函数 | 测试文件路径、输入/输出/边界条件 |
| 集成测试 | API、多模块协作、数据库操作 | 测试场景、预期结果、Mock 范围 |
| 手工验证 | UI 交互、视觉效果、用户体验 | 操作步骤、预期行为 |

### 3.4 经验候选捕获（即时捕获）

在任务拆解/测试设计过程中，如发生以下情况，立即输出经验候选（HTML 注释包裹，不干扰对话）：

| 触发场景 | 描述 | 典型信号 |
|----------|------|----------|
| **任务调整** | 用户调整任务拆解（合并/拆分/重排） | "这两个合成一个"、"这个要拆开" |
| **依赖变更** | 用户调整任务依赖关系 | "不需要先做 A"、"B 要等 C 完成" |
| **技术选型** | 用户选择/拒绝某个技术方案 | "用 React"、"不用 Redux" |
| **测试策略** | 用户调整测试方式（单测/集成/手工） | "这个手工验就行"、"必须有单测" |
| **任务增删** | 用户新增/删除任务项 | "还需要加一个..."、"这个不用做" |
| **行为调整** | 用户调整可测试行为定义 | "这个行为不对"、"还要测这种情况" |
| **风险识别** | 识别到 req 中未显式写出的风险 | "这里可能有坑"、"要注意 X" |
| **约束明确** | 用户明确技术约束或依赖选择 | "必须用这个版本"、"不能引入新依赖" |
| **交付调整** | 用户调整交付物清单 | "不用改文档"、"要加个配置文件" |
| **验证变更** | 用户调整验证方式或标准 | "用这种方式验证"、"这个指标要达到" |

输出格式：

<!-- EXP-CANDIDATE
{
  "stage": "plan",
  "trigger": "当任务 T2 依赖从A改为B",
  "decision": "任务/验收/测试策略的取舍",
  "alternatives": ["原方案A（放弃，因为...）"],
  "signal": "判断依据/风险信号",
  "solution": "新的任务拆解/验收/测试策略",
  "verify": "后续如何验证该决策",
  "pointers": ["path/to/plan-file 或相关模块"],
  "notes": "可选补充"
}
-->

### 4) Plan 模板

```markdown
# <REQ-xxx> Plan

## 目标回放（1-3 行）

## 状态摘要（Status Summary）

- **当前阶段**：plan
- **进度**：0/X
- **当前任务**：无
- **阻塞项**：无
- **上次更新**：{DATE}
- **测试状态**（可选）：单元测试 X passed / Y total，集成测试 X passed / Y total

## 文件变更清单（Files to Change）

| 操作 | 文件路径 | 说明 |
|-----|---------|-----|
| 创建 | `src/...` | ... |
| 修改 | `src/...` | ... |
| 创建 | `src/__tests__/...` | 测试文件 |

## 任务清单（Tasks）

### 后端任务（全栈需求）

- [ ] T1: ...（依赖: 无）
  - 创建: `src/...`
  - 修改: `src/...`
- [ ] T2: ...（依赖: T1）

### 前端任务（全栈需求）

- [ ] T3: ...（依赖: T1, T2）
- [ ] T4: ...

### 测试任务（必选）

- [ ] T5: 编写单元测试（依赖: T1, T2）
  - 创建: `src/__tests__/...`
- [ ] T6: 编写集成测试（依赖: T3, T4）
- [ ] T7: 运行全部测试并确认通过

## 交付物（Deliverables）

- [ ] 代码变更：...
- [ ] 单元测试通过：...
- [ ] 集成测试通过：...（如适用）
- [ ] 文档更新：...（如适用）

## 测试规格（Test Specifications）

### 可测试行为清单

| 行为ID | 行为描述 | 测试类型 |
|-------|---------|---------|
| B1 | ... | 单元测试 |
| B2 | ... | 集成测试 |

### 单元测试规格

| 行为 | 输入 | 预期输出 | 边界/错误条件 |
|-----|-----|---------|--------------|
| B1 | ... | ... | ... |

### 集成测试场景

| 场景 | 前置条件 | 操作 | 预期结果 |
|-----|---------|-----|---------|
| S1 | ... | ... | ... |

### 手工验证步骤

| 步骤 | 操作 | 预期行为 |
|-----|-----|---------|
| 1 | ... | ... |

## 复利候选（Compounding Candidates）

- [ ] （候选）...
```

### 5) Plan 质量自检

写入前检查：

- [ ] 覆盖 req 中的所有功能需求
- [ ] 每个验收标准有对应的验证方式
- [ ] 任务可独立执行，依赖关系明确
- [ ] 文件变更清单完整（包含测试文件）
- [ ] 测试任务作为独立分类存在
- [ ] 可测试行为已从需求中提取
- [ ] 单元测试规格包含输入/输出/边界条件
- [ ] 复杂任务有规范引用

### 6) 更新索引

遵循 `index-manager` 的指引更新索引：

- Status：`planned`
- Current Phase：`plan`
- Links：补充 plan 路径

### 7) 阶段完成输出（人工闸门）

阶段完成后输出：
```
计划文档已创建，您可以：

A) 继续修改/补充 计划
B) 进入 audit
C) 跳过audit 直接 work
D) 回退
E) 退出
```

### 8) 可推进判据检查（plan → audit/work，仅用户选择 B 或 C 后执行）

用户选择 B 或 C 后，检查以下判据：

| 判据 | 验证方式 |
|------|---------|
| plan 文件已写入 | `REQ-xxx.plan.md` 存在且非空 |
| plan 含 Tasks 小节 | 包含 `## 任务清单` 或 `## Tasks` |
| plan 含 Validation 小节 | 包含 `## 测试规格` 或 `## Validation` |
| plan 含复利候选小节 | 包含 `## 复利候选`（可为空） |
| INDEX 已更新 | Status = planned |

**检查逻辑**：满足 → 静默推进；不满足 → 输出检查清单，提供选项（强制推进 / 回退 / 补充修改）（仅在异常时展示）
