---
name: work
description: 此 Skill 按 Plan 执行实现并持续验证。当 plan 生成完成且用户确认开始 work 时激活，回写 plan 的任务勾选与 Status Summary，必要时写 checkpoint，阶段推进需人工确认。
---

# Work

## Outputs (must write)

- 更新：`.workflow/requirements/in-progress/REQ-xxx.plan.md`（任务勾选 + Status Summary）
- 按需新增：`.workflow/context/session/<REQ-xxx>-checkpoint-*.md`

## Instructions

### 0) Experience Index（强制）

进入代码编写前，`experience-index` 会自动匹配历史经验提醒。

### 1) 状态恢复

- 优先读取 plan 的 Status Summary
- 若存在 checkpoint，加载最新一个继续

### 1.1) 识别 Auto-generated Plan 并准备按需补充（推荐）

**为什么推荐实现**：
- work 阶段在执行任务时，可能会发现 plan 中缺失的实际文件
- 动态补充可以保持 plan 的实时准确性，便于进度跟踪
- 虽然不是阻塞项，但能显著改善执行体验

**识别 Auto-generated Plan**：
- 检查 plan 标题是否包含 "Auto-generated"（包括 Minimal 或 Enhanced 版本）
- 如果识别到 Auto-generated plan，准备在执行过程中动态补充

**执行过程中动态补充**（按需触发）：

1. **文件变更清单补充**：
   - 在执行任务时，如果创建/修改了计划外文件，自动更新"文件变更清单"
   - 将新文件添加到文件变更清单表格中，标记为"由 work 阶段动态补充"

2. **任务粒度调整**：
   - 如果发现任务粒度不匹配（如粗粒度任务需要拆解），自动拆解为子任务并更新任务清单
   - 在任务描述中标注"由 work 阶段拆解"

3. **测试规格补充**：
   - 如果发现需要补充测试规格（如编写测试时发现缺少测试用例），自动更新测试规格部分
   - 在补充的测试规格中标注"由 work 阶段补充"

**更新 plan 文件**：
- 补充后，如果 plan 是 Minimal 版本，更新 plan 标题为 "Auto-generated, Enhanced"
- 在补充的章节添加注释说明"由 work 阶段动态补充"
- 静默更新 plan 文件（符合静默成功原则）

### 1.2) 经验候选捕获（即时捕获）

在实现/排查过程中，如发生以下情况，立即输出经验候选（HTML 注释包裹，不干扰对话）：

| 触发场景 | 描述 | 典型信号 |
|----------|------|----------|
| **实现纠正** | 用户纠正实现方向/方式/细节 | "不要这样写"、"改成那样" |
| **方案切换** | 实现中发现原方案不可行，切换方案 | "这个方案不行，换成..." |
| **根因定位** | 排查问题找到 root cause | "原来是因为..."、"根本原因是..." |
| **测试修复** | 测试失败暴露问题并修复 | 测试红→绿 + 修复原因 |
| **契约确认** | 确认/修订接口契约或数据结构 | "接口改成这样"、"字段要加个 X" |
| **性能问题** | 发现性能/内存/兼容性问题并解决 | "太慢了"、"内存泄漏"、"不兼容" |
| **依赖问题** | 发现依赖库问题，更换或绕过 | "这个库有 bug"、"换成另一个" |
| **边界处理** | 确认/修订边界条件处理方式 | "空值怎么处理"、"异常怎么抛" |
| **规范确认** | 用户确认代码风格/命名/结构规范 | "要用这种命名"、"放在这个目录" |
| **隐含假设** | 发现并明确代码中的隐含假设 | "原来假设了 X"、"前提条件是 Y" |

输出格式：

<!-- EXP-CANDIDATE
{
  "stage": "work",
  "trigger": "当发现 root cause 并更换方案",
  "decision": "实现/修复/接口/边界的取舍",
  "alternatives": ["原方案A（放弃，因为...）"],
  "signal": "判断依据/风险信号/失败证据",
  "solution": "新的实现/修复方案",
  "verify": "测试/验证步骤与结果期望",
  "pointers": ["path/to/file 或接口说明"],
  "notes": "可选补充"
}
-->

### 2) 测试执行规范（强化）

#### 2.1 测试执行时机

| 时机                 | 动作         | 目的         |
| -------------------- | ------------ | ------------ |
| 任务开始前           | 运行现有测试 | 确认基线正常 |
| 每完成一个实现任务后 | 运行相关测试 | 确认实现正确 |
| 进入 review 前       | 运行全部测试 | 确认无回归   |

#### 2.2 测试编写规范

编写单元测试时遵循：

| 原则             | 说明                                                     |
| ---------------- | -------------------------------------------------------- |
| **隔离测试**     | Mock 所有外部依赖（API、数据库、文件系统）               |
| **一行为一测试** | 每个测试只验证一个行为，便于定位问题                     |
| **AAA 模式**     | Arrange（准备数据）→ Act（执行操作）→ Assert（验证结果） |
| **基于规格**     | 只测试 plan 中定义的行为，不发明新行为                   |

**测试代码结构示例**：

```typescript
describe('功能名称', () => {
  it('B1: 行为描述', () => {
    // Arrange - 准备
    const input = ...;

    // Act - 执行
    const result = functionUnderTest(input);

    // Assert - 断言
    expect(result).toBe(expectedOutput);
  });
});
```

#### 2.3 测试结果记录（静默成功原则）

**测试通过时**：

- 完全静默，不输出测试结果
- 仅在 Status Summary 中更新测试状态（可选，仅在需要时更新）

**测试失败时**：

- 输出失败详情，包含失败的测试用例、错误信息、修复建议
- 在 Status Summary 中简要记录：
  ```markdown
  - **测试状态**（可选）：单元测试 4 passed / 5 total（B2 失败，已修复）
  ```

### 3) 边做边验证（Fail Fast）

- 每完成一个"最小步"，立即验证（PASS/FAIL）
- 核心逻辑优先即时验证，避免最后才发现基础模块有问题
- **测试任务与实现任务交替执行**：实现一个功能后立即编写/运行对应测试

### 4) 长任务续航：checkpoint / compaction（强烈建议）

当满足任一条件时，必须写 checkpoint（并尽量压缩到"最小高信号"）：

- 已完成一个可交付"最小步"（完成一个 task 或子任务）
- 讨论/排查超过 10-15 轮对话，信息开始分散
- 阶段切换前（work → review）
- 需要"换人/换会话/明天继续"

checkpoint 文件路径：

- `.workflow/context/session/<REQ-xxx>-checkpoint-<YYYYMMDD-HHMM>.md`

checkpoint 建议格式（结构化，便于交接）：

```markdown
# <REQ-xxx> Checkpoint - <YYYY-MM-DD HH:MM>

## 状态摘要（Status Summary）

- 阶段：work
- 进度：X/Y
- 当前任务：...
- 阻塞项：...

## 已完成（Done）

- ...

## 测试状态（Test Status）

- 单元测试：X passed / Y total
- 集成测试：X passed / Y total
- 未覆盖行为：B3, B4（待实现）

## 关键决策（Decisions）

- 决策：...
  - 原因：...
  - 影响：...

## 验证记录（Validation）

- [ ] 步骤：...
  - 结果：PASS/FAIL
  - 证据/输出：...

## 指针（Pointers）

- `path/to/file`: 为什么重要

## 下一步（Next）

- ...

## 复利候选（Compounding Candidates）

- ...
```

### 5) 回写规范（必须，静默成功原则）

plan.md 中必须持续更新：

- Status Summary（阶段/进度/当前任务/阻塞项/上次更新，可选的测试状态）
- 任务勾选（标记已完成的任务）
- Compounding Candidates（可沉淀点）
- **文件变更清单**（如果是 Auto-generated plan，动态补充实际创建/修改的文件）
- **任务清单**（如果是 Auto-generated plan，动态拆解任务粒度）

**输出规则**：

- 文件写入成功：静默，不输出确认信息
- 文件写入失败：输出错误信息
- 任务完成：静默更新，不输出"已完成 XXX"的确认信息
- **动态补充**：如果是 Auto-generated plan，在执行过程中静默更新 plan 文件，不输出补充确认信息

### 6) 进入 Review 前检查

在请求进入 review 前，确认：

- [ ] 所有实现任务已完成
- [ ] 所有测试任务已完成
- [ ] 全部测试通过（运行 `yarn test` 或等效命令）
- [ ] 测试覆盖 plan 中定义的所有可测试行为

### 7) 阶段完成输出（人工闸门）

阶段完成后输出：

```
实现完成，您可以：

A) 继续修改/补充 实现
B) 进入 review
C) 跳过review 直接 archive
D) 回退
E) 退出
```

**重要**：当用户选择 A（继续修改/补充实现）后：

- 执行用户请求的修改操作
- **修改完成后，必须再次输出上述菜单**，让用户能够继续选择下一步
- 确保用户始终能够通过菜单选项继续流程，避免只能使用空 `/flow` 命令继续

### 8) 可推进判据检查（work → review/archive，仅用户选择 B 或 C 后执行）

用户选择 B 或 C 后，检查以下判据：

| 判据                     | 验证方式                               |
| ------------------------ | -------------------------------------- |
| Deliverables 关键项完成  | 所有关键交付物已创建/修改              |
| 验证记录可复现           | Test Specifications 已定义或测试已执行 |
| 所有实现任务已完成       | Tasks 中实现任务全部勾选               |
| 测试任务已完成（如适用） | Tasks 中测试任务全部勾选               |

**检查逻辑**：满足 → 静默推进；不满足 → 输出检查清单，提供选项（强制推进 / 回退 / 补充修改）（仅在异常时展示）
