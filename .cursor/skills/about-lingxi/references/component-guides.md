# 组件选择指南

## 概述

基于 Cursor 官方文档的组件能力边界和适用场景，提供组件选择指南。

## 组件对比

| 组件         | 设计目标                          | 适用场景               | 限制                         |
| ------------ | --------------------------------- | ---------------------- | ---------------------------- |
| **Command**  | 可复用的工作流，单一用途          | 单一用途、可重复的操作 | 不需要单独的上下文窗口       |
| **Skill**    | 教会 Agent 如何执行特定领域的任务 | 特定领域知识和工作流   | 与主 Agent 共享上下文窗口    |
| **Rule**     | 系统级指令，持久、可重用的上下文  | 系统级约束规则         | 作用于提示级别，Always Apply |
| **Hook**     | 观察、控制和扩展 agent 循环       | 自动化、门控、审计     | 脚本执行，必须快速执行       |
| **Subagent** | 专门 AI 助手，可委派任务          | 独立上下文、并行任务   | 启动开销和 Token 消耗更高    |

## Commands 指南

### 设计目标（官方定义）

- 创建**可复用的工作流**，在聊天输入框中使用简单的 `/` 前缀触发
- 有助于在团队内规范流程并提升常见任务的效率

### 能力边界

**技术特性**：

- 纯 Markdown 文件：存放在 `.cursor/commands/` 或 `~/.cursor/commands/`
- 支持参数：命令名之后的内容会包含在模型提示中
- 自动发现：Cursor 自动扫描命令目录

**适用场景**：

- ✅ 单一用途、可重复的操作（如生成变更日志、格式化等）
- ✅ 代码审查清单
- ✅ 安全审计流程
- ✅ 创建 PR 的标准流程
- ✅ 新功能设置模板

**不适合的场景**：

- ❌ 需要上下文隔离的复杂任务（应用 Subagents）
- ❌ 复杂的业务逻辑（应用 Skills）
- ❌ 质量资产（应用 Memory 记忆系统）

**限制**：

- 单一用途，不需要单独的上下文窗口
- 任务可以一次性完成
- 不需要并行执行

### 在灵犀中的应用

- `/req`：创建任务文档
- `/plan`：任务规划
- `/build`：代码实现
- `/review`：审查交付
- `/remember`：记忆写入
- `/init`：项目初始化（Command 负责交互契约与菜单；主逻辑由 `init-executor` Skill 承载，清单定义放在 Skill 的 references 里作为 SSoT）

## Skills 指南

### 设计目标（官方定义）

- 可移植、受版本控制的包，用于**教会 Agent 如何执行特定领域的任务**
- Agent 会根据上下文决定何时使用（基于 description 匹配）
- 扩展 AI Agent 的专业能力和专业知识

### 能力边界

**技术特性**：

- 平台要求：需要 **Cursor Nightly** 版本
- 自动发现：从 `.cursor/skills/` 或 `~/.cursor/skills/` 加载
- Agent 自动匹配：根据 description 判断何时使用
- 手动调用：在对话中输入 `/` 搜索技能名称

**适用场景**：

- ✅ 特定领域的知识和工作流
- ✅ 阶段 Playbook
- ✅ 专业知识：需要特定领域的知识和工作流

**不适合的场景**：

- ❌ 需要独立上下文窗口的长时间任务（应用 Subagents）

**限制**：

- 需要明确的 description 以便 Agent 匹配
- 不应过长（保持精炼）
- 与主 Agent 共享上下文窗口
- 需要 Nightly 版本支持

### 在灵犀中的应用

**Executor Skills**：

- `req-executor`：需求分析、提纯、放大和文档生成
- `plan-executor`：任务规划、测试设计和文档生成
- `build-executor`：代码实现、测试编写和执行
- `review-executor`：多维度审查和交付质量保证

**记忆系统**：

- `memory-retrieve`（Skill）：每轮回答前检索并最小注入（由 Always Apply Rule 强保证触发）
- **lingxi-memory**（Subagent）：记忆写入通过**显式调用**（`/lingxi-memory` 或自然语言提及子代理）使用；双入口 auto/remember；在独立上下文中完成产候选、治理、门控与直接文件写入（notes + INDEX），主对话仅收一句结果

**Rules（强保证触发器）**：

- `.cursor/rules/memory-injection.mdc`：Always Apply，每轮回答前要求执行一次检索与最小注入（无匹配静默，失败可降级）

**工具类 Skills**：

- `about-lingxi`：快速了解灵犀的背景知识
- `write-doc`：文档编写和风格一致性保证
- `style-fusion`：风格画像提取和融合

**审查类 Skills**：

- `reviewer-doc-consistency`：文档一致性审查
- `reviewer-security`：安全审查
- `reviewer-performance`：性能审查
- `reviewer-e2e`：端到端测试审查

## Hooks 指南

### 设计目标（官方定义）

- 通过自定义脚本**观察、控制和扩展 agent 循环**
- 在 agent 循环中定义的各阶段之前或之后运行
- 允许运行时自定义 agent 行为

### 能力边界

**技术特性**：

- 配置文件：`hooks.json` 文件
- 脚本语言：Node.js 或其他可执行脚本
- 触发时机：在 agent 循环的特定阶段之前或之后
- 同步执行：脚本执行会阻塞主流程（必须快速执行）

**适用场景**：

- ✅ 输入门控：校验 prompt 格式
- ✅ 命令拦截：阻止危险命令
- ✅ 自动归档：对话结束时自动归档
- ✅ 审计日志：记录命令执行和响应
- ✅ Git 集成：自动提交和分支管理
- ✅ 格式化：编辑后运行代码格式化工具
- ✅ 安全检查：扫描敏感信息、阻止高风险操作

**不适合的场景**：

- ❌ 复杂的业务逻辑（应在 Skills 中）
- ❌ 需要 AI 推理的任务（应在 Skills 或 Subagents 中）
- ❌ 长时间运行的任务（会阻塞主流程）

**限制**：

- 需要编写脚本（Node.js 或其他可执行脚本）
- 有性能开销（每次触发都会执行）
- 错误处理需要谨慎（避免阻塞主流程）
- 脚本必须可执行且有必要的权限

### 在灵犀中的应用

（可选机制）

## Subagents 指南

### 设计目标（官方定义）

- 专门 AI 助手，可以**委派任务**
- 每个子代理都有**独立的上下文窗口**
- 可以**并行执行**工作

### 能力边界

**技术特性**：

- 目录结构：子代理定义存储在 `.cursor/agents/` 或 `.cursor/subagents/` 目录中
- 独立上下文：每个子代理有独立的上下文窗口
- 并行执行：多个子代理可以并行运行
- 自动匹配：Agent 根据 description 字段自动匹配调用

**适用场景**：

- ✅ 长时间的研究类任务（隔离上下文）
- ✅ 需要并行运行多个工作流
- ✅ 任务在多个步骤中需要专业领域知识
- ✅ 对工作结果进行独立验证
- ✅ 需要静默处理，不干扰主对话的任务

**不适合的场景**：

- ❌ 单一用途的简单任务（应用 Commands 或 Skills）
- ❌ 可以一次性完成的任务（应用 Skills）

**限制**：

- 启动开销：每个子代理需要单独收集自己的上下文
- Token 消耗：多个上下文同时运行，消耗更高
- 延迟：对于简单任务可能比主代理更慢
- 并行运行 5 个子代理 ≈ 单个 agent 约 5 倍的 tokens

### 在灵犀中的应用

- **lingxi-memory**（`.cursor/agents/lingxi-memory.md`）：记忆写入。通过**显式调用**使用——在提示中使用 `/lingxi-memory` 语法（例如 `/lingxi-memory mode=remember input=<内容>`）或自然语言提及「lingxi-memory 子代理」来调用；当用户执行 `/remember` 或主 Agent 判断存在可沉淀并决定写入时，主 Agent 以此方式将任务交给子代理；子代理在独立上下文中完成产候选、治理、门控与**直接文件写入**（notes + INDEX），主对话仅收一句结果，减少对主对话的干扰。
- 审查类任务通过 Reviewer Skills 实现，由 review-executor 显式调用，共享上下文以降低 token 消耗。

## 选择决策矩阵

### 需求类型 → 推荐组件

| 需求类型             | 推荐组件 | 理由（基于官方定义）                                     |
| -------------------- | -------- | -------------------------------------------------------- |
| 单一用途、可重复操作 | Command  | 官方定义：单一用途，不需要单独的上下文窗口               |
| 特定领域知识和工作流 | Skill    | 官方定义：教会 Agent 如何执行特定领域的任务              |
| 系统级约束规则       | Rule     | 官方定义：系统级指令，在提示级别提供持久、可重用的上下文 |
| 自动化、门控、审计   | Hook     | 官方定义：通过自定义脚本观察、控制和扩展 agent 循环      |
| 独立上下文、并行任务 | Subagent | 官方定义：专门 AI 助手，独立的上下文窗口，可以并行执行   |

### 性能考虑

| 组件     | 性能开销                                    | 适用场景             |
| -------- | ------------------------------------------- | -------------------- |
| Command  | 低                                          | 简单、可重复的操作   |
| Skill    | 低（共享上下文）                            | 特定领域知识和工作流 |
| Hook     | 低（脚本执行快速）                          | 自动化、门控、审计   |
| Subagent | 高（独立上下文，启动开销和 Token 消耗更高） | 独立上下文、并行任务 |

## Rules 指南

> **注意**：本文档描述 Cursor 官方的 Rules 功能。灵犀当前**使用 Project Rules** 作为“强保证触发器”（例如 `.cursor/rules/memory-injection.mdc`），用于每轮对话的最小记忆注入；其他质量资产仍主要通过记忆库（`memory/notes/` + `INDEX.md`）治理与复用。

### 设计目标（官方定义）

- 提供**系统级指令**，在提示级别提供持久、可重用的上下文
- 将提示词、脚本等内容打包，便于在团队内管理和共享工作流
- 支持从对话中生成规则（`/Generate Cursor Rules` 命令）

### 能力边界

**存储位置**：

1. **Project Rules**（`.cursor/rules/`）：存储在项目目录中，版本控制
2. **User Rules**（Cursor 设置）：在 Cursor 设置中全局定义，跨项目应用
3. **AGENTS.md**（项目根目录）：作为 `.cursor/rules/` 的简化替代方案

**适用场景**：

- ✅ 沉淀与代码库相关的领域知识
- ✅ 自动化项目特定的工作流或模板
- ✅ 统一风格或架构决策
- ❌ 不适合：单一用途的简单任务（应用 Commands）

**限制**：

- 应控制在 500 行以内
- 应聚焦、可操作、范围明确
- Always Apply 规则必须极精炼（< 50 行，总计 < 150 行）

### 在灵犀中的应用

灵犀使用 Rules 的典型用途：

- **强保证触发**：Always Apply（如 `.cursor/rules/memory-injection.mdc`）确保每轮回答前执行一次检索与最小注入
- **系统级约束**：可用于补充关键的提示级约束（要求极精炼，使用指针，不复制长文）

## 参考

- **Rules 指南**：`references/rules-guide.md`（详细技术参考）
- **Cursor 官方文档**：Commands、Skills、Hooks、Subagents、Rules 的能力边界
