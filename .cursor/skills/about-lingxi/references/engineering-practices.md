# 工程实践准则

本文档收录公认的、经过检验的工程实践准则，用于指导 workflow 的工程设计质量评估。

## 核心原则

### 1. Single Source of Truth (SSoT) - 单一事实来源

**原则**：每个信息片段应该只在一个地方定义和维护。

**为什么**：

- **一致性**：避免信息不一致导致的错误
- **可维护性**：修改时只需更新一处
- **可追溯性**：明确信息的来源和权威性

**在 workflow 中的应用**：

- 索引文件（如 `INDEX.md`）作为 SSoT，其他文件引用而非复制
- 经验索引作为经验的 SSoT，避免重复定义
- 质量资产（Experience 系统）作为项目规范的 SSoT

**检查点**：

- [ ] 是否存在重复定义的信息？
- [ ] 是否通过引用而非复制来共享信息？
- [ ] 是否有明确的权威数据源？

### 2. Separation of Concerns (SoC) - 关注点分离

**原则**：将系统分解为不同的部分，每个部分负责一个特定的关注点。

**为什么**：

- **可维护性**：修改一个关注点不影响其他部分
- **可测试性**：可以独立测试每个关注点
- **可复用性**：不同关注点可以独立复用

**在 workflow 中的应用**：

- Skills 负责特定领域的任务（req、plan、work 等）
- Experience 系统负责质量资产（团队级标准/经验和项目级经验）
- Hooks 负责自动化流程
- Subagents 负责独立任务

**检查点**：

- [ ] 每个组件是否有明确的单一职责？
- [ ] 组件之间的边界是否清晰？
- [ ] 是否存在职责重叠或混淆？

### 3. Don't Repeat Yourself (DRY) - 不要重复自己

**原则**：避免代码、配置、文档的重复。

**为什么**：

- **可维护性**：修改时只需更新一处
- **一致性**：避免重复内容的不一致
- **简洁性**：减少冗余，提高可读性

**在 workflow 中的应用**：

- 通过 Skills 复用工作流逻辑，而非在每个命令中重复
- 通过 Experience 系统复用质量准则（团队级标准/经验和项目级经验），而非在每个 Skill 中重复
- 通过索引和引用共享信息，而非复制

**检查点**：

- [ ] 是否存在重复的逻辑、配置或文档？
- [ ] 是否可以通过抽象或复用消除重复？
- [ ] 重复是否真的必要（有时重复是合理的）？

### 4. Keep It Simple, Stupid (KISS) - 保持简单

**原则**：设计应该尽可能简单，避免不必要的复杂性。

**为什么**：

- **可理解性**：简单的设计更容易理解
- **可维护性**：简单的设计更容易维护
- **可调试性**：简单的设计更容易调试

**在 workflow 中的应用**：

- Single Entrypoint 降低认知负担
- 最小高信号上下文避免过度复杂
- 明确的阶段划分和推进协议

**检查点**：

- [ ] 设计是否足够简单？
- [ ] 是否存在不必要的复杂性？
- [ ] 是否可以进一步简化？

### 5. You Aren't Gonna Need It (YAGNI) - 你不会需要它

**原则**：不要实现当前不需要的功能，避免过度设计。

**为什么**：

- **聚焦**：专注于当前需求，避免分心
- **效率**：避免浪费时间和资源
- **灵活性**：保持设计的灵活性，便于未来调整

**在 workflow 中的应用**：

- 不要为假设的未来需求设计复杂机制
- 保持设计的灵活性，便于未来扩展
- 优先解决当前问题，而非预测未来问题

**检查点**：

- [ ] 是否在解决当前的实际问题？
- [ ] 是否存在过度设计？
- [ ] 是否为了假设的未来需求增加了复杂性？

### 6. Fail Fast - 快速失败

**原则**：尽早发现和报告错误，避免错误传播。

**为什么**：

- **可调试性**：错误越早发现，越容易定位和修复
- **可靠性**：避免错误在系统中传播
- **效率**：避免在错误的基础上继续工作

**在 workflow 中的应用**：

- 索引一致性检查（Fail Fast 验证）
- 阶段推进前的可推进判据检查
- 经验匹配的早期验证

**检查点**：

- [ ] 是否在关键点进行了验证？
- [ ] 错误是否能够尽早发现？
- [ ] 是否有适当的错误处理和报告机制？

### 7. Explicit is Better than Implicit - 显式优于隐式

**原则**：明确表达意图，避免隐式行为和魔法。

**为什么**：

- **可理解性**：明确的代码更容易理解
- **可维护性**：明确的逻辑更容易维护
- **可预测性**：明确的行为更容易预测

**在 workflow 中的应用**：

- 明确的阶段推进协议（菜单选项）
- 明确的确认机制（`/remember ...` 或用户选择存储目标）
- 明确的索引和引用关系

**检查点**：

- [ ] 行为是否明确表达？
- [ ] 是否存在隐式行为或魔法？
- [ ] 意图是否清晰可读？

### 8. Composition over Inheritance - 组合优于继承

**原则**：优先使用组合而非继承来构建复杂系统。

**为什么**：

- **灵活性**：组合更灵活，易于调整
- **可维护性**：组合的依赖关系更清晰
- **可测试性**：组合的组件可以独立测试

**在 workflow 中的应用**：

- Skills 可以组合使用，形成复杂工作流
- Subagents 可以组合使用，处理复杂任务
- Experience 系统可以组合应用，形成完整的质量资产体系

**检查点**：

- [ ] 是否优先使用组合？
- [ ] 是否存在不必要的继承或层次结构？
- [ ] 组件是否可以独立使用和测试？

### 9. Principle of Least Surprise - 最小意外原则

**原则**：设计应该符合用户的预期，避免意外行为。

**为什么**：

- **易用性**：符合预期的设计更容易使用
- **可学习性**：减少学习成本
- **可靠性**：减少因意外行为导致的错误

**在 workflow 中的应用**：

- 统一的入口和交互模式
- 一致的命名和结构
- 明确的阶段推进和状态反馈

**检查点**：

- [ ] 行为是否符合用户预期？
- [ ] 是否存在令人意外的行为？
- [ ] 命名和结构是否一致？

### 10. Single Responsibility Principle (SRP) - 单一职责原则

**原则**：每个模块、类或函数应该只有一个改变的理由。

**为什么**：

- **可维护性**：修改时影响范围小
- **可理解性**：职责清晰，易于理解
- **可测试性**：可以独立测试每个职责

**在 workflow 中的应用**：

- 每个 Skill 负责一个特定阶段或任务
- 每个质量资产（团队级标准/经验或项目级经验）包含特定的质量准则
- 每个 Hook 负责一个特定的自动化场景

**检查点**：

- [ ] 每个组件是否只有一个职责？
- [ ] 是否存在职责混合？
- [ ] 修改一个功能是否会影响其他功能？

### 11. Open/Closed Principle (OCP) - 开闭原则

**原则**：对扩展开放，对修改关闭。

**为什么**：

- **稳定性**：核心功能稳定，不受扩展影响
- **灵活性**：可以灵活扩展功能
- **可维护性**：扩展不需要修改现有代码

**在 workflow 中的应用**：

- Skills 可以扩展，而不需要修改命令文件（2.0 中命令独立，通过 description 匹配自动激活）
- Rules 可以添加，而不需要修改现有 Rules
- 经验可以积累，而不需要修改核心机制

**检查点**：

- [ ] 是否可以扩展而不修改现有代码？
- [ ] 核心机制是否稳定？
- [ ] 扩展点是否清晰？

### 12. Dependency Inversion Principle (DIP) - 依赖倒置原则

**原则**：高层模块不应该依赖低层模块，两者都应该依赖抽象。

**为什么**：

- **灵活性**：可以替换实现而不影响高层逻辑
- **可测试性**：可以轻松模拟依赖
- **可维护性**：依赖关系清晰，易于调整

**在 workflow 中的应用**：

- Skills 依赖抽象的工作流协议，而非具体实现
- 经验索引依赖抽象的匹配机制
- 组件之间通过明确的接口交互

**检查点**：

- [ ] 是否依赖抽象而非具体实现？
- [ ] 是否可以替换实现？
- [ ] 依赖关系是否清晰？

## 设计模式与最佳实践

### 1. 分层架构

**原则**：将系统组织为清晰的层次，每层有明确的职责。

**在 workflow 中的应用**：

- 命令层（Commands）：用户交互入口
- 技能层（Skills）：业务逻辑和规则
- 数据层（Data）：索引、经验、计划等
- 基础设施层（Infrastructure）：Hooks、Subagents 等

**检查点**：

- [ ] 层次是否清晰？
- [ ] 每层职责是否明确？
- [ ] 是否存在跨层依赖？

### 2. 约定优于配置

**原则**：通过约定减少配置，提高开发效率。

**在 workflow 中的应用**：

- 文件命名约定（001.req.<标题>.md、001.plan.<标题>.md）
- 目录结构约定（.cursor/.lingxi/tasks/、.cursor/skills/）
- 索引格式约定（统一索引 `.cursor/.lingxi/memory/INDEX.md`）

**检查点**：

- [ ] 是否有明确的约定？
- [ ] 约定是否被一致遵循？
- [ ] 配置是否最小化？

### 3. 渐进式增强

**原则**：从简单开始，逐步增加复杂性。

**在 workflow 中的应用**：

- 基础工作流（req → plan → work → review）
- 逐步增加能力（audit、archive、experience）
- 保持向后兼容

**检查点**：

- [ ] 是否从简单开始？
- [ ] 是否可以逐步增强？
- [ ] 是否保持向后兼容？

### 4. 防御性编程

**原则**：假设输入可能有问题，进行验证和处理。

**在 workflow 中的应用**：

- 索引一致性检查
- 阶段推进前的验证
- 经验匹配的容错处理

**检查点**：

- [ ] 是否验证输入？
- [ ] 是否处理异常情况？
- [ ] 是否有适当的错误处理？

### 5. 可观测性

**原则**：系统应该提供足够的可见性，便于理解和调试。

**在 workflow 中的应用**：

- 明确的阶段状态反馈
- 索引和经验的可见性
- 决策和变更的可追溯性

**检查点**：

- [ ] 状态是否可见？
- [ ] 决策是否可追溯？
- [ ] 是否便于调试？

## 质量评估框架

### 评估维度

1. **可维护性**：代码/配置/文档是否易于理解和修改？
2. **可扩展性**：是否易于添加新功能？
3. **可测试性**：是否易于测试和验证？
4. **可复用性**：组件是否可以在不同场景复用？
5. **可理解性**：设计意图是否清晰？
6. **可靠性**：是否能够正确处理各种情况？
7. **性能**：是否满足性能要求？
8. **一致性**：是否遵循一致的约定和模式？

### 评估流程

1. **识别问题域**：明确需要评估的设计或实现
2. **应用相关准则**：根据问题域选择相关的工程实践准则
3. **检查清单验证**：使用检查清单验证是否符合准则
4. **权衡分析**：识别可能的权衡和取舍
5. **改进建议**：提出具体的改进建议

### 权衡考虑

工程实践准则之间可能存在权衡：

- **简单性 vs 完整性**：简单设计可能牺牲某些功能
- **灵活性 vs 一致性**：灵活设计可能降低一致性
- **性能 vs 可维护性**：性能优化可能增加复杂性
- **当前需求 vs 未来扩展**：过度设计 vs 设计不足

**原则**：根据项目阶段和实际需求，做出合理的权衡决策。

## 参考

- **项目设计原则**：`docs/01-concepts/key-principles.md`
- **核心价值指引**：`references/workflow-vision.md`
- **技术能力边界**：各组件指南（Commands、Rules、Skills、Hooks、Subagents）
