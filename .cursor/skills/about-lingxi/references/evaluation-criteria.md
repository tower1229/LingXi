# 灵犀改动评价准则

## 概述

当需要对灵犀 workflow 做出改动时，使用此评价准则进行评估。所有改动都应首先考虑是否符合核心价值指引（Why 和 How）。

## 价值对齐检查

### 心有灵犀

- [ ] **是否有助于经验沉淀和复用？**（有助于记住创造者的指引）
- [ ] **是否有助于让 AI 按创造者的方式做事？**
- [ ] **是否有助于持久化记忆能力？**

### AI Native

- [ ] **是否尊重 AI 作为能力源泉？**
- [ ] **是否为 AI 进化预留空间？**
- [ ] **是否过度约束 AI？**（否 → 通过，是 → 需要调整）

**检查点**：
- 是否依赖大模型的自然语言理解能力，而非硬编码规则匹配？
- 是否用自然语言描述处理策略，而非关键词列表、正则表达式？
- 是否让大模型根据上下文智能判断，而非复杂的 if-else 逻辑？

### 称心如意

- [ ] **是否降低认知负担？**
- [ ] **是否提供友好的交互体验？**
- [ ] **是否让常用操作更便捷？**

**检查点**：
- 是否遵循静默成功原则（成功、无问题、无匹配时静默）？
- 是否遵循最小高信号原则（仅输出关键信息）？
- 是否降低用户的操作复杂度？

## 架构合理性检查

### 组件选择

- [ ] **选择的组件是否符合其官方定义的适用场景？**
- [ ] **选择的组件是否在其能力边界内？**
- [ ] **是否有更适合的组件选择？**

**决策矩阵**（基于官方能力边界）：

| 需求类型             | 推荐组件 | 理由（基于官方定义）                                     |
| -------------------- | -------- | -------------------------------------------------------- |
| 单一用途、可重复操作 | Command  | 官方定义：单一用途，不需要单独的上下文窗口               |
| 特定领域知识和工作流 | Skill    | 官方定义：教会 Agent 如何执行特定领域的任务              |
| 系统级约束规则       | Rule     | 官方定义：系统级指令，在提示级别提供持久、可重用的上下文 |
| 自动化、门控、审计   | Hook     | 官方定义：通过自定义脚本观察、控制和扩展 agent 循环      |
| 独立上下文、并行任务 | Subagent | 官方定义：专门 AI 助手，独立的上下文窗口，可以并行执行   |

### 职责分离

- [ ] **组件职责是否清晰？**
- [ ] **组件之间的边界是否明确？**
- [ ] **是否存在职责重叠或混淆？**

**检查点**：
- 每个 Skill 是否只负责一个特定领域？
- Commands 是否只负责参数解析和调用说明，执行逻辑委托给 Skills？
- Experience 系统是否只负责质量资产，不负责业务逻辑？

### 目录结构

- [ ] **是否符合灵犀的目录结构约定？**
- [ ] **文件命名是否符合约定？**
- [ ] **是否遵循 SSoT 原则（通过引用而非复制）？**

### 文档同步

- [ ] **是否需要同步更新 `about-lingxi` 中的相关文档？**
  - 如果改动涉及 Commands、Skills、Rules、Hooks、Subagents 的增减或职责变更 → 更新 `references/architecture.md` 和 `references/component-guides.md`
  - 如果改动涉及记忆系统机制 → 更新 `references/memory-system.md`
  - 如果改动涉及设计原则或评价准则 → 更新 `references/design-principles.md` 或 `references/evaluation-criteria.md`
  - 如果改动涉及工作流输出与静默约束 → 更新 `references/workflow-output-principles.md`
  - 如果改动涉及核心价值或实现方式 → 更新 `references/core-values.md`
  - 如果改动涉及工作流程或使用场景 → 更新 `SKILL.md` 中的相关场景描述

## 工程实践检查

### 核心原则

- [ ] **SSoT（单一事实来源）**：是否存在重复定义？是否通过引用共享信息？
- [ ] **SoC（关注点分离）**：组件职责是否清晰？边界是否明确？
- [ ] **DRY（不要重复）**：是否存在重复逻辑、配置或文档？是否可以通过抽象消除？
- [ ] **KISS（保持简单）**：设计是否足够简单？是否存在不必要的复杂性？
- [ ] **YAGNI（你不会需要它）**：是否在解决当前问题？是否存在过度设计？
- [ ] **Fail Fast（快速失败）**：是否在关键点进行验证？错误是否能尽早发现？
- [ ] **显式优于隐式**：行为是否明确表达？意图是否清晰可读？
- [ ] **组合优于继承**：是否优先使用组合？组件是否可以独立使用和测试？
- [ ] **最小意外原则**：行为是否符合用户预期？命名和结构是否一致？
- [ ] **单一职责原则**：每个组件是否只有一个职责？修改一个功能是否会影响其他功能？
- [ ] **开闭原则**：是否可以扩展而不修改现有代码？核心机制是否稳定？
- [ ] **依赖倒置原则**：是否依赖抽象而非具体实现？是否可以替换实现？

### 设计模式与最佳实践

- [ ] **分层架构**：层次是否清晰？每层职责是否明确？是否存在跨层依赖？
- [ ] **约定优于配置**：是否有明确的约定？约定是否被一致遵循？配置是否最小化？
- [ ] **渐进式增强**：是否从简单开始？是否可以逐步增强？是否保持向后兼容？
- [ ] **防御性编程**：是否验证输入？是否处理异常情况？是否有适当的错误处理？
- [ ] **可观测性**：状态是否可见？决策是否可追溯？是否便于调试？

### 质量维度

- [ ] **可维护性**：代码/配置/文档是否易于理解和修改？
- [ ] **可扩展性**：是否易于添加新功能？扩展点是否清晰？
- [ ] **可测试性**：是否易于测试和验证？组件是否可以独立测试？
- [ ] **可复用性**：组件是否可以在不同场景复用？
- [ ] **可理解性**：设计意图是否清晰？是否易于理解？
- [ ] **可靠性**：是否能够正确处理各种情况？是否有适当的错误处理？
- [ ] **性能**：是否满足性能要求？是否存在性能瓶颈？
- [ ] **一致性**：是否遵循一致的约定和模式？命名和结构是否一致？

## 评估输出

基于检查清单，输出：

1. **通过项**：哪些检查项已通过
2. **需要调整项**：哪些检查项需要调整，如何调整（参考核心价值指引、工程实践准则）
3. **技术边界问题**：哪些超出技术能力边界，如何调整
4. **工程实践问题**：哪些不符合工程实践准则，如何改进
5. **权衡分析**：识别可能的权衡和取舍，根据项目阶段和实际需求做出合理决策
6. **风险评估**：哪些检查项存在风险，如何缓解

## 参考

- **核心价值指引**：`references/core-values.md`
- **设计原则**：`references/design-principles.md`
- **组件指南**：`references/component-guides.md`
- **工程实践准则**：`references/engineering-practices.md`
