---
name: plan-executor
description: 当执行 /plan 命令时自动激活（taskId 可选，省略时使用最新任务），负责任务规划、测试设计和文档生成。
---

# Plan Executor

## 本 Skill 会用到的能力

读 req/代码；语义搜索相关实现；Web/context7 做深度调研；必要时向用户提问澄清。

## Quick Start

- **目标**：产出 plan + testcase 文档。
- 读 req → 1 读取 → 2 目标回放 → 3 代码库与上下文 → 4 澄清与外部知识 → 5 任务清单与测试基础 → 6 任务拆解 → 7 测试设计与框架 → 8 文档准备与写入 → 9 下一步建议。

## Instructions

### 1. 读取输入

- 扫描 `.cursor/.lingxi/tasks/` 目录
- **如果指定 taskId**：查找 `<taskId>.req.*.md` 文件（如 `001.req.*.md`）
- **如果省略 taskId**：提取所有 `*.req.*.md` 文件的编号，选取最大编号的任务
- 如果找不到文件，提示用户并提供解决方案
- 识别需求类型（前端/后端/全栈/简单功能/其他）与特性标签（文档为主、库/SDK），以及复杂度

### 2. 理解 req 并生成目标回放

读取 req 文档全文，基于以下部分理解并生成目标回放：

- **"1. 概述"**：1.1 背景、1.2 问题描述、1.3 解决方案概述
- **"2. 目标与指标"**：2.1 目标、2.2 非目标、2.3 成功标准

**生成方式**：总结和提炼 req 中的核心目标、成功标准和关键约束，形成简洁的目标回放。

### 3. 代码库分析与服务上下文

#### 3.1 代码库分析（复杂需求必选）

在生成任务清单前，分析代码库获取相关上下文，以便任务清单与文件变更清单能引用准确的文件路径和依赖关系。

**触发条件**（满足任一）：需求涉及存量系统/多服务协作；需要修改多个模块；涉及与现有代码的集成。

**分析内容**：补齐服务/模块上下文；使用 SemanticSearch/Grep 定位相关代码；识别需要修改的现有文件和模块；分析依赖关系和影响范围。

**输出要求**：将分析结果供后续「步骤 5.1 任务清单生成」与「步骤 6.3 文件变更清单」使用；在任务描述中引用具体文件路径；复杂需求必须执行，简单需求可静默跳过。

#### 3.2 补齐服务上下文（可选，复杂需求推荐）

将 3.1 的代码库分析结论沉淀为记忆笔记，在步骤 5 之前完成，以便任务清单与后续任务拆解能利用服务上下文。若需求涉及存量系统/多服务协作：生成/更新 `memory/notes/` 下的 `Kind=tech` 记忆笔记，只写"概要 + 指针 + 常见坑"，避免长文档膨胀。

### 4. 澄清与外部知识

在**生成任务清单之前**完成，先澄清再调研，避免基于模糊需求拆解导致返工。

#### 4.1 澄清性问题（复杂需求必选）

分析 req 是否存在以下不清晰点：

| 检查维度 | 检查内容              | 示例问题                                   |
| -------- | --------------------- | ------------------------------------------ |
| 边界不清 | 功能边界、影响范围    | "这个功能是否需要支持移动端？"             |
| 方案未定 | 存在多个可行方案      | "用 A 方案还是 B 方案？各有什么优劣？"     |
| 依赖不明 | 与其他模块/系统的依赖 | "这个功能需要调用哪些现有服务？"           |
| 约束缺失 | 性能/安全/兼容性约束  | "对响应时间有要求吗？需要支持哪些浏览器？" |
| 验收模糊 | 成功标准不明确        | "什么样的结果算成功？"                     |

如有澄清性问题，先输出问题列表，等待用户回答后再继续步骤 5。若 req 已足够清晰（简单需求），可静默跳过。

#### 4.2 外部知识放大（推荐）

做深度调研，使步骤 5 任务清单与步骤 6 任务拆解都能融入最佳实践与已知坑点。

**触发条件**（满足任一即触发）：任务涉及第三方库/API 的使用；需要选择多个技术方案中的一个；实现细节存在不确定性。

**调研工具分工**：方案选型/对比用 WebSearch（"X vs Y 2024/2025"、"best practice for X"）；具体库用法用 MCP context7；常见报错/兼容性用 WebSearch。调研结果不单独写入，将最佳实践融入任务清单与任务描述，将已知坑点融入复利候选或直接规避。req 阶段做广度调研，plan 阶段做深度调研。

### 5. 任务清单与测试基础生成

基于 req 文档产出任务清单与可测试行为基础，供步骤 6、7 使用。

#### 5.1 任务清单生成

当需求拆解为多个子任务且存在依赖时，使用结构化任务列表并标明依赖关系。基于 req「4. 功能需求」表格；可结合**步骤 3** 代码库分析、**步骤 4.2** 外部知识结论。读取功能需求表格，分析需求描述/实现方案/验收标准/优先级，拆解为可执行任务（T1, T2, ...），识别依赖关系，从实现方案与代码库分析结果提取文件路径。本步产出的任务清单作为**步骤 6 任务拆解**的输入。

#### 5.2 测试用例基础生成

基于 req「10. 验收检查清单」：将验收标准转化为可测试行为，识别适合单元测试的行为，过滤 UI/API 集成/视觉效果（留给集成测试/手工验证）。为后续步骤 7.1 测试设计提供基础。

**注意事项**（步骤 2、5）：若 req 结构不规范或缺少章节应优雅降级；理解过程应准确；生成内容与 req 语义保持一致。

### 6. 任务拆解

**规范引用**：生成任务时，优先依赖每轮注入（sessionStart hook + `memory-retrieve`）获得相关记忆，在任务描述中明确引用（文件指针即可）。

以**步骤 5.1** 产出的任务清单为输入，做任务分类、依赖与先测再实现排序、文件变更清单落地：

#### 6.1 任务分类

需求类型与 req 文档元数据保持一致：**前端 / 后端 / 全栈 / 简单功能 / 其他**；可选**特性标签**：文档为主、库/SDK。

根据需求类型组织任务（测试任务在存在可测单元时必选）：

| 需求类型 | 任务分类                                                               |
| -------- | ---------------------------------------------------------------------- |
| 前端     | 组件任务、状态任务、样式任务、**测试任务**                             |
| 后端     | API 任务、服务任务、数据任务、**测试任务**                             |
| 全栈     | 后端任务、前端任务、集成任务、**测试任务**                             |
| 简单功能 | 按变更单元组织（如单文件/单模块任务）、**测试任务**（如有可测逻辑）    |
| 其他     | 按文档内容与实现范围组织（以变更单元与验收为准）、**测试任务**（如有） |

当带有 **文档为主** 或 **库/SDK** 特性标签时，按文档内容与实现范围组织任务（可不拘泥于「组件/API/数据」分类，以变更单元与验收为准）；与主类型「其他」时的处理方式一致。

#### 6.2 任务依赖

- 标注任务间的依赖关系（如 `依赖: T1, T2`）
- 确定执行顺序：优先实现被依赖项

#### 6.2.1 先探索再修改（原则）

生成任务描述或执行顺序时，对涉及不熟悉模块/目录的任务，在任务描述中可包含「先语义搜索或读取关键文件建立理解，再实现」的指引；用自然语言表述，无硬编码规则。

#### 6.2.2 先测再实现（任务顺序）

对每个可单元测试的单元，拆成两条有序任务，便于 build 阶段按「先测再实现」执行：

- **Txa**：为 \<单元名\> 编写单元测试（基于 testcase 中该单元的行为与输入/输出/边界）
- **Txb**：实现 \<单元名\>

**依赖**：Txb 依赖 Txa；Txa 仅依赖测试框架就绪与 testcase 文档。执行顺序上「编写该单元测试」在「实现该单元」之前。

**例外**：不适合先测的任务（如纯 UI、强集成）在任务描述中注明「实现后补测或手工验证」即可。

#### 6.3 文件变更清单

每个任务明确列出需要创建/修改的文件。测试文件对应「编写该单元测试」任务（Txa），实现文件对应「实现该单元」任务（Txb），便于 build 按任务执行。

```markdown
- [ ] T1a: 为用户服务编写单元测试
  - 创建: `tests/unit/services/user.test.ts`
- [ ] T1b: 实现用户服务（依赖: T1a）
  - 创建: `src/services/user.ts`
  - 修改: `src/services/index.ts`
```

### 7. 测试设计与框架

#### 7.1 测试设计（强化）

基于**步骤 5.2** 的测试用例基础做行为提取与规格化，供 build 先测再实现使用。

**行为提取**：基于步骤 5.2 产出的可测试行为做细化与规格化（不重复从需求零散提取）：

- 只保留/细化适合单元测试的行为（纯逻辑、服务层、工具函数）
- 过滤掉 UI 交互、API 集成、视觉效果等（留给集成测试/手工验证）
- 不发明或推断未明确说明的行为

**测试规格**：对每个可测试行为，定义结构化规格。本规格供 build 在实现前编写测试（先测再实现）；编写时仅依赖输入/输出/边界，不依赖实现细节。

| 行为         | 输入                    | 预期输出 | 边界/错误条件      |
| ------------ | ----------------------- | -------- | ------------------ |
| B1: 计算折扣 | price=100, discount=0.1 | 90       | discount<0 抛错    |
| B2: 验证邮箱 | "test@example.com"      | true     | 空字符串返回 false |

**测试类型选择**：单元测试（纯函数、服务逻辑、工具函数）；集成测试（API、多模块协作、数据库操作）；手工验证（UI 交互、视觉效果、用户体验）。

#### 7.2 测试框架检测与安装

**多层检测策略**：

1. 检查 `package.json` 的 `devDependencies`（jest, vitest, mocha, jasmine 等）
2. 检查项目根目录的测试配置文件（`jest.config.js`, `vitest.config.ts`, `mocha.opts` 等）
3. 检查测试目录结构（`tests/`, `__tests__/`, `test/`, `spec/` 等）
4. 检查测试文件模式（`*.test.js`, `*.spec.ts`, `*.test.tsx` 等）

**检测结果处理**：

- 如果检测到现有框架：记录框架类型和配置，在 plan 中说明将使用该框架
- 如果未检测到框架：
  - 检查依赖冲突：检查 `package.json` 是否有冲突依赖
  - 安装 vitest：`yarn add -D vitest` 或 `npm install -D vitest`
  - 创建配置文件：`vitest.config.ts`（按最佳实践）
  - 创建测试目录：`tests/unit/`, `tests/integration/`
  - 更新 `package.json` 的 `scripts.test`
  - 验证安装：执行 `yarn test` 或 `npm test` 验证框架是否正常工作

**冲突处理**：

- 如果检测到依赖冲突：提示用户，不自动安装，在 plan 中标记需要手动处理

**注意**：记忆写入通过**显式调用** lingxi-memory 子代理处理；本 Skill 不包含捕获与写入逻辑。

### 8. 文档准备与写入

#### 8.1 文档同步清单检测

在写入 plan 文档**之前**执行，以便「需同步的文档列表」能写入 plan 正文。扫描 `docs/`、`design/`、`architecture/` 等，识别可能受本次改动影响的文档，在 plan 中列出需同步的文档列表。

#### 8.2 Plan 文档写入

按 [references/plan-doc-template.md](references/plan-doc-template.md) 生成。命名：`001.plan.<标题>.md`（标题 10 字以内，从 req 标题提取）。

#### 8.3 Testcase 文档写入

按 [references/testcase-doc-template.md](references/testcase-doc-template.md) 生成。命名：`001.testcase.<标题>.md`（标题 10 字以内，从 req 标题提取）。

#### 8.4 写入后自检

完成 8.2、8.3 的文档写入后，执行以下自检：

- [ ] 覆盖 req 中的所有功能需求
- [ ] 每个验收标准有对应的验证方式
- [ ] 任务可独立执行，依赖关系明确
- [ ] 文件变更清单完整（包含测试文件）
- [ ] 测试任务作为独立分类存在
- [ ] 可测试行为已从需求中提取
- [ ] 单元测试规格包含输入/输出/边界条件
- [ ] 复杂任务有规范引用
- [ ] 任务顺序支持先测再实现：每个可测单元均为「编写该单元测试」在「实现该单元」之前

### 9. 下一步建议（有产物时必须输出）

**输出时机**：**只要本步写入了 plan 或 testcase 文档**（即向 `.cursor/.lingxi/tasks/` 写入了 `*.plan.*.md` 或 `*.testcase.*.md`），**必须在当轮回复末尾**输出下一步建议；与是否在回复中展示摘要无关。若本步未写入任何 plan/testcase 文档，可不包含下一步建议。

**必须包含的结构**（在回复末尾）：标题行「**下一步可尝试（选一项）**」+ 四项「**A) …（推荐）**」「**B) …**」「**C) …**」「**D) …**」；给出建议前先做质量自检（见下），根据自检结果决定 A 的推荐内容。

**质量自检维度**（给出建议前先自评当前产出）：任务是否已拆解且依赖清晰？是否覆盖 req 的主要需求？测试策略是否可执行？任务顺序是否支持先测再实现（每个可测单元是否为「编写该单元测试」在「实现该单元」之前）？

**推荐逻辑**：自检通过 → A = `/build` 按计划实现（推荐），B = 调整 plan，C = 回头看 req，D = 其他。自检不通过 → A = 调整 plan 或回头看 req（推荐），B = `/build`，C/D = 其他。

**允许动作集合**（选项仅限下列）：`/build <taskId>`、调整 plan、回头看 req、其他/跳过。

**输出格式**：标题行「**下一步可尝试（选一项）**」；四项格式「**A) 简短描述（推荐）**」「**B) 简短描述**」「**C) 简短描述**」「**D) 简短描述**」；描述中可含具体命令（如 `/build 001`），命令须来自上列允许集合。

**用户回复 A/B/C/D**：当用户下一轮仅输入 A、B、C 或 D 时，视为选择该选项，执行或引导执行对应命令。

---

## 使用场景

### 场景 1：简单前端需求

用户输入：`/plan 001`

执行流程：

1. 读取输入（步骤 1）
2. 理解 req 并生成目标回放（步骤 2）
3. 代码库分析与服务上下文（步骤 3，简单需求可静默跳过 3.1、3.2 可选）
4. 澄清与外部知识（步骤 4：4.1 静默跳过、4.2 可选）
5. 任务清单与测试基础生成（步骤 5.1–5.2）
6. 任务拆解（步骤 6：组件任务、样式任务、测试任务）
7. 测试设计与框架（步骤 7.1–7.2）
8. 文档准备与写入（步骤 8.1–8.4）

### 场景 2：复杂全栈需求

用户输入：`/plan 001`

执行流程：

1. 读取输入（步骤 1）
2. 理解 req 并生成目标回放（步骤 2）
3. 代码库分析与服务上下文（步骤 3.1 必选、3.2 推荐）
4. 澄清与外部知识（步骤 4.1 必选、4.2 推荐）
5. 任务清单与测试基础生成（步骤 5.1–5.2）
6. 任务拆解（步骤 6：后端任务、前端任务、集成任务、测试任务）
7. 测试设计与框架（步骤 7.1 强化、7.2 检测与安装）
8. 文档准备与写入（步骤 8.1–8.4）

---

## 注意事项

1. **记忆写入**：记忆写入通过**显式调用** lingxi-memory 子代理处理（`/lingxi-memory` 或自然语言提及），本 Skill 不包含捕获与写入逻辑
2. **输出与静默**：输出遵循 [workflow-output-principles](.cursor/skills/about-lingxi/references/workflow-output-principles.md)；简单需求可静默跳过部分步骤，复杂需求必须执行所有步骤
3. **测试设计**：必须从需求中提取可测试行为，不发明未明确说明的行为
4. **文档质量**：生成的 plan 和 testcase 文档必须完整、准确

---

## 与 Commands 的协作

本 Skill 由 `/plan` 命令自动激活（taskId 可选），执行逻辑完全由本 Skill 负责。Commands 只负责参数解析和产物说明。
