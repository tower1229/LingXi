# Plan Executor — 完整执行流程

本文档为 plan-executor 的详细步骤、使用场景与注意事项；SKILL.md 仅保留意图与关键约束。

## Instructions

### 1. 读取输入

- 扫描 `.cursor/.lingxi/tasks/` 目录
- **如果指定 taskId**：查找 `<taskId>.task.*.md` 文件（如 `001.task.*.md`）
- **如果省略 taskId**：提取所有 `*.task.*.md` 文件的编号，选取最大编号的任务
- 如果找不到文件，提示用户并提供解决方案
- 识别需求类型（前端/后端/全栈/简单功能/其他）与特性标签（文档为主、库/SDK），以及复杂度

### 2. 理解 task 并生成目标回放

读取 task 文档全文，基于「1. 概述」「2. 目标与指标」总结核心目标、成功标准和关键约束，形成简洁的目标回放。

### 3. 代码库分析与服务上下文

#### 3.1 代码库分析（复杂需求必选）

触发条件：需求涉及存量系统/多服务协作；需修改多模块；涉及与现有代码集成。分析内容：补齐服务/模块上下文；SemanticSearch/Grep 定位相关代码；识别需修改的文件与依赖。复杂需求必须执行，简单需求可静默跳过。

#### 3.2 补齐服务上下文（可选，复杂需求推荐）

若涉及存量系统/多服务协作：生成/更新 `memory/notes/` 下 `Kind=tech` 记忆笔记，只写「概要 + 指针 + 常见坑」。

### 4. 澄清与外部知识

#### 4.1 澄清性问题（复杂需求必选）

分析 task 是否边界不清、方案未定、依赖不明、约束缺失、验收模糊；如有则先输出问题列表，等待用户回答后再继续步骤 5。简单需求可静默跳过。

#### 4.2 外部知识放大（推荐）

触发条件：涉及第三方库/API、多方案选型、实现细节不确定。WebSearch 做方案对比与最佳实践，context7 查库用法；结果融入任务清单与任务描述，不单独写入。

### 5. 任务清单与测试基础生成

#### 5.1 任务清单生成

基于 task「4. 功能需求」表格，结合步骤 3、4.2；拆解为可执行任务 T1,T2,...；**强制 F→T 映射**（每任务标注关联 F 编号）；识别依赖与文件路径。产出作为步骤 6 输入。

#### 5.2 测试用例基础生成

基于 task「10. 验收检查清单」将验收标准转化为可测试行为，过滤 UI/API/视觉效果留给集成或手工。为步骤 7.1 提供基础。

### 6. 任务拆解

以步骤 5.1 任务清单为输入。规范引用：优先用 sessionStart + memory-retrieve 的记忆在任务描述中引用。

#### 6.1 任务分类

按需求类型：前端（组件/状态/样式/测试任务）、后端（API/服务/数据/测试任务）、全栈（后端/前端/集成/测试任务）、简单功能/其他（按变更单元 + 测试任务）。文档为主/库/SDK 标签时按文档与验收组织。

#### 6.2 任务依赖与先测再实现

标注依赖（如 `依赖: T1, T2`）。对可单元测试的单元：**Txa** 编写该单元测试，**Txb** 实现该单元；Txb 依赖 Txa，顺序上先 Txa 再 Txb。不适合先测的注明「实现后补测或手工验证」。

#### 6.3 文件变更清单

每任务列出创建/修改文件；测试文件对应 Txa，实现文件对应 Txb。

### 7. 测试设计与框架

#### 7.1 测试设计

基于步骤 5.2 与 task 每条 F 的验证方式（unit/integration/e2e/manual/rubric）做行为提取与规格化。单元测试对应 unit；manual/rubric 产出可执行步骤、预期结果、rubric 时评分维度与记录模板。不发明未明确说明的行为。

#### 7.2 测试框架检测与安装

检测 package.json devDependencies、根目录测试配置、测试目录与文件模式。无框架时可选安装 vitest、创建 vitest.config.ts、tests/unit|integration、更新 scripts.test；依赖冲突时提示用户不自动安装。

### 8. 文档准备与写入

#### 8.1 文档同步清单

写入 plan 前扫描 docs/、design/、architecture/ 等，在 plan 中列出需同步的文档列表。

#### 8.2 Plan 文档写入

按 [plan-doc-template.md](plan-doc-template.md) 生成，命名 `001.plan.<标题>.md`（标题 10 字以内）。

#### 8.3 Testcase 文档写入

调用 testcase-designer skill，输入 task 文档，输出结构化 testcase；命名 `001.testcase.<标题>.md`。

#### 8.4 写入后自检

覆盖 task 所有功能需求；每条 F（验证方式不为空）均有 TC 或手工/rubric 覆盖；任务含 F→T 映射；文件变更清单含测试文件；任务顺序支持先测再实现。

### 9. 下一步建议（有产物时必须输出）

只要写入了 plan 或 testcase，必须在当轮回复末尾输出「**下一步可尝试（选一项）**」+ 四项 A/B/C/D。允许集合：`/build <taskId>`、调整 plan、回头看 task、其他/跳过。自检通过 → A = `/build`；不通过 → A = 调整 plan 或回头看 task。

---

## 使用场景

- **简单需求**：步骤 3.1/4.1 可静默跳过，4.2 可选；任务分类为组件/样式/测试等。
- **复杂全栈**：步骤 3.1 必选、3.2 推荐；4.1 必选、4.2 推荐；任务分类为后端/前端/集成/测试。

---

## 注意事项

1. 记忆写入通过显式调用 lingxi-memory，本 Skill 不包含写入逻辑。
2. 输出遵循 workflow-output-principles；简单需求可静默跳过部分步骤。
3. 测试设计必须从需求提取可测试行为，不发明行为。
4. plan 与 testcase 文档必须完整、准确。

---

## 与 Commands 的协作

由 `/plan` 命令自动激活（taskId 可选）；Commands 只负责参数解析和产物说明。
