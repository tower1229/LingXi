---
name: memory-index
description: 此 Skill 在执行 /req、/plan 001、/build 001、/review 001 等命令时自动激活，按 Trigger 匹配 memory/INDEX.md 的统一索引（Experience/Tech/Business）并主动提醒风险与指针。
---

# Memory Index

## Instructions

### 1. 上下文获取逻辑（遵循上下文组织原则）

**上下文组织原则**：
- **先指针后细节**：先读取 INDEX.md（索引），再按需加载记忆文件（细节）
- **最小高信号**：仅输出关键信息（风险级别 + 指针），省略冗长格式
- **分层加载**：先索引与概要，按需加载细节，避免 context rot

在激活 memory-index 时，自动获取上下文：

#### 1.1 从命令参数推断任务编号和阶段

- `/req <描述>` → 阶段：req，任务编号：自动生成
- `/plan 001` → 阶段：plan，任务编号：001
- `/build 001` → 阶段：build，任务编号：001
- `/review 001` → 阶段：review，任务编号：001
- `/review-req 001` → 阶段：review-req，任务编号：001

#### 1.2 读取对应的 req 文件

- 扫描 `.cursor/.lingxi/requirements/` 目录
- 匹配 `<taskId>.req.*.md` 文件（如 `001.req.*.md`）
- 读取 req 文件内容作为匹配上下文

**特殊情况**：

- `/req` 命令：如果 req 文件尚未创建，使用需求描述作为匹配上下文
- 如果找不到 req 文件，提示用户并提供解决方案

#### 1.3 基于 req 内容 + 当前阶段进行记忆匹配

- 提取 req 中的关键词（技术选型、功能描述、架构思路等）
- 结合当前阶段（req/plan/build/review）进行 Trigger 匹配
- 输出匹配的记忆（风险级别 + 指针）

### 2. 记忆匹配流程（遵循上下文组织原则）

**分层加载策略**：

1. **元数据过滤（基于 INDEX.md）**：
   - 读取 `memory/INDEX.md`，根据命令决定匹配范围
     - `/init` → 只匹配 Experience 中 Level = team 的记忆（团队级标准和经验）
     - `/req`、`/plan`、`/build`、`/review` → 匹配所有维度（Experience/Tech/Business），其中 Experience 包括 Level = team 和 Level = project
   - 只匹配 `Status = active` 的记忆（已删除的记忆不在索引中）
   - 根据 Level、Type 等元数据过滤，确定要搜索的目录

2. **概念级语义搜索（基于完整记忆文件）**：
   - 使用 `codebase_search` 工具对记忆文件目录进行语义搜索
   - **构建概念化查询**：描述"当前要解决什么问题"、"要查找什么概念"，而非提取结构化字段
     ```
     我正在[阶段：plan/build/review]，需要[描述当前要解决的核心问题]。
     查找相关经验：处理类似问题的判断、风险、解决方案。
     ```
     - 示例：`我正在 plan 阶段，需要规划一个用户认证功能，需要考虑安全性和用户体验的平衡。查找相关经验：处理类似认证问题的判断、风险、解决方案。`
   - 查询范围限定在 `.cursor/.lingxi/memory/experience/`（根据元数据过滤结果）
   - Cursor 语义搜索自动进行**概念级匹配**，理解记忆内容的真正含义
   - 返回按语义相似度排序的结果

3. **LLM 概念级相似度评估**：
   - 对语义搜索结果，使用 LLM 进行**概念级相似度评估**
   - **评估维度**（基于概念理解，而非字段匹配）：
     - 问题概念相似度：记忆要解决的问题是否与当前场景在概念上相似
     - 风险概念相似度：记忆识别的风险是否与当前场景的风险在概念上相关
     - 解决方案概念相似度：记忆的解决方案是否与当前场景在概念上相关
     - 阶段适用性：记忆是否适用于当前阶段
   - 让 Agent 理解记忆内容的**真正含义**，进行概念级判断
   - 输出相似度得分（0-1）和判断理由

4. **元数据加权**：
   - 对相似度得分进行元数据加权：
     - Strength：`enforced` = 1.2, `validated` = 1.1, `hypothesis` = 1.0
     - Scope：`broad` = 1.2, `medium` = 1.1, `narrow` = 1.0
     - Type：`standard` = 1.1, `knowledge` = 1.0
   - 最终得分 = 相似度得分 × 元数据权重

5. **返回结果**：
   - 按最终得分降序排列
   - 只返回得分 >= 0.3 的记忆
   - 最多返回 Top 5

6. **按需加载细节**：仅在需要详细内容时，才加载对应的记忆文件（细节层）

### 3. 匹配优先级

**优先级 1：命令匹配**（最高优先级）

根据当前命令决定匹配范围：
- `/init` → 只匹配 Experience 中 Level = team 的记忆（标准和经验）
- `/req`、`/plan`、`/build`、`/review` → 匹配所有维度（Experience/Tech/Business）

**优先级 2：文件匹配**（中等优先级）

如果当前有打开文件：
- globs 匹配 → 匹配文件相关的标准和经验
- Experience：通用文件规范（如 `**/*.ts` → TypeScript 规范）
- Tech：服务相关文件（如 `**/services/auth/**` → 认证服务上下文）
- Business：业务相关文件（如 `**/workflow/**` → 工作流业务上下文）

**优先级 3：概念级语义匹配**（最低优先级）

- 问题概念匹配 → 基于"要解决什么问题"的概念级匹配
- 风险概念匹配 → 基于"识别的风险"的概念级匹配（仅 Experience）
- 解决方案概念匹配 → 基于"解决方案"的概念级匹配
- 服务概念匹配 → 基于服务职责和边界的概念级匹配（仅 Tech）
- 业务主题概念匹配 → 基于业务主题的概念级匹配（仅 Business）

**匹配过滤**：
- 知识可获得性过滤：高可获得性且代码库有示例 → 降低优先级或跳过
- 团队级标准优先：同时匹配标准和经验 → 优先返回标准（Type = standard）

### 4. 输出规则（静默成功原则 + 最小高信号）

**遵循"最小高信号"原则**：
- **无匹配时**：完全静默，不输出任何内容
- **有匹配时**：仅输出关键信息（风险级别 + 指针），省略冗长的结构化格式
- 输出格式示例：
  ```
  ⚠️ 高风险：XXX（参考 memory/experience/EXP-001.md）
  💡 技术上下文：认证服务（参考 memory/tech/services/auth-service.md）
  📋 业务上下文：工作流生命周期（参考 memory/business/workflow-lifecycle.md）
  ```
- **仅包含**：风险级别（high/medium/low）、记忆标题或关键提示、文件指针
- **省略**：完整的结构化表格、详细的认知触发器说明（除非风险极高）

**先指针后细节**：
- 输出时先给出记忆文件指针，而非直接输出详细内容
- 用户需要时可自行查看详细记忆文件

## INDEX 字段说明

### Experience（经验记忆）

| 字段         | 类型                                    | 说明                                                                       |
| ------------ | --------------------------------------- | -------------------------------------------------------------------------- |
| `Tag`        | 唯一标识                                | 用于引用与检索                                                             |
| `Type`       | `standard` / `knowledge`                | 经验类型：standard=标准（强约束、执行底线），knowledge=经验（复杂判断、认知触发） |
| `Title`      | 简短标题                                | 一句话描述经验                                                             |
| `Trigger`    | 关键词/场景                             | 触发加载的条件（when to load，偏工程检索）                                 |
| `Surface signal` | 句子 | 表层信号（我闻到熟悉风险味道的线索，偏认知触发） |
| `Hidden risk` | 句子 | 隐含风险（真正会出问题的点，偏认知触发） |
| `Status`     | `active`                                 | active=可用（废弃的记忆已直接删除，不再保留 deprecated 状态）             |
| `Scope`      | `narrow` / `medium` / `broad`           | 经验适用范围：narrow=单一场景，medium=同类问题，broad=跨场景通用           |
| `Strength`   | `hypothesis` / `validated` / `enforced` | 经验强度：hypothesis=首次总结，validated=多次验证，enforced=已转为自动拦截 |
| `Level`      | `team` / `project`                      | 经验层级：team=团队级，project=项目级                                     |
| `Replaces`   | 逗号分隔的 Tag 列表                     | 本经验取代了哪些旧经验（谱系链：新 → 旧）。注意：已删除的记忆会从 Replaces 字段中移除 |
| `ReplacedBy` | Tag                                     | 本经验被哪条新经验取代（谱系链：旧 → 新）。注意：废弃的经验已直接删除，此字段不再使用 |
| `File`       | 文件路径                                | 经验详情文件                                                               |

### Tech（技术记忆）

| 字段      | 类型                | 说明                     |
| --------- | ------------------- | ------------------------ |
| `Tag`     | 唯一标识            | 用于引用与检索           |
| `Title`   | 简短标题            | 一句话描述技术上下文     |
| `Service` | 服务名称            | 服务或模块名称           |
| `Trigger` | 关键词/场景         | 触发加载的条件           |
| `Status`  | `active` | active=可用（废弃的记忆已直接删除，不再保留 deprecated 状态） |
| `File`    | 文件路径            | 技术上下文详情文件       |

### Business（业务记忆）

| 字段      | 类型                | 说明                     |
| --------- | ------------------- | ------------------------ |
| `Tag`     | 唯一标识            | 用于引用与检索           |
| `Title`   | 简短标题            | 一句话描述业务上下文     |
| `Topic`   | 业务主题            | 业务领域或主题           |
| `Trigger` | 关键词/场景         | 触发加载的条件           |
| `Status`  | `active` | active=可用（废弃的记忆已直接删除，不再保留 deprecated 状态） |
| `File`    | 文件路径            | 业务上下文详情文件       |

## 禁止

- 没匹配就硬输出"无相关记忆"（应完全静默）
- 一次任务重复提醒同一条记忆
- 返回已删除的记忆（已删除的记忆不在索引中）
- 输出冗长的结构化格式（有匹配时仅输出关键信息）
- 在上下文获取失败时继续执行（应先提示用户）
