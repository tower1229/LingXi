# /work - Work 阶段：按计划实现并持续验证

## 命令用途

按 `ai/requirements/in-progress/<REQ-xxx>.plan.md` 执行开发任务，持续更新勾选状态与验证记录。

## 依赖的技能型 rules（Skill）

- `.cursor/rules/skill-plan-manager.mdc`（Plan 作为执行账本：Worklog/验证方式/任务勾选/复利候选）
- `.cursor/rules/skill-context-engineering.mdc`
- `.cursor/rules/skill-experience-index.mdc`（自动检索与加载历史经验）
- `.cursor/rules/development-specifications.mdc`

## 使用方式

```
/work <REQ-xxx>
```

---

## 产物（必须落盘）

- 代码变更（视项目而定）
- `ai/requirements/in-progress/<REQ-xxx>.plan.md`（持续更新勾选与 Worklog）
- `ai/context/session/<REQ-xxx>-checkpoint-{timestamp}.md`（阶段性保存，视触发时机而定）

## 执行要点（入口 + 路由）

### 第一步：理解计划与上下文

- **输入**：读取 `ai/requirements/in-progress/<REQ-xxx>.plan.md`
- **状态恢复**：
  - 检查 plan.md 中的"状态摘要"（如有），快速了解当前进度
  - 如有 checkpoint 文件（`ai/context/session/<REQ-xxx>-checkpoint-*.md`），加载最近的 checkpoint 继续
  - **跨会话恢复流程**：
    1. 自动检测 `ai/context/session/` 目录下是否存在 `<REQ-xxx>-checkpoint-*.md` 文件
    2. 如有，读取最新的 checkpoint 文件
    3. 根据 checkpoint 中的"已完成任务清单"和"当前进度"恢复上下文
    4. 从"下一步建议"中的任务开始继续执行
    5. 在对话中主动提醒："检测到 checkpoint，已从上次中断处恢复"
- **分析项目上下文**：了解现有实现（设计模式、可复用组件、需要修改的模块）

### 第二步：经验检索（强制执行）

**⚠️ 必须执行：** 在代码编写前就必须执行经验检索，不可跳过。

调用 `skill-experience-index.mdc`，根据当前任务与代码文件自动检索匹配的代码模式与风险，并主动提醒。

**执行步骤：**
1. 读取 `ai/context/experience/INDEX.md`
2. 匹配所有 Status = `active` 的经验
3. 根据当前任务与代码文件进行语义匹配
4. 在对话中输出匹配结果（高风险警告、背景文档路径、相关服务、代码模式）

### 第二步补充：技术文档查询（按需）

当遇到不熟悉的技术点、API 或需要确认实现方式时，使用 Context7 查询技术文档：

- **触发场景**：
  1. 使用不熟悉的库/框架 API 时
  2. 需要确认最佳实践或推荐用法时
  3. 遇到技术问题需要查阅官方文档时
- **使用方式**：调用 `mcp_context7_query-docs` 工具查询相关库/框架文档
- **示例**：
  - 查询 "React useEffect cleanup 函数用法"
  - 查询 "Express.js 错误处理中间件最佳实践"
  - 查询 "TypeScript 泛型约束语法"
- **注意**：优先使用 Context7 查询官方文档，确保实现的准确性和最佳实践

### 第三步：编写测试用例（先测试后开发）

> **核心原则**：开发前先编写测试用例，明确验收标准。

- **测试用例文档**：根据 Plan 中的测试用例规划，编写测试用例文档（`docs/test-cases/{功能名称}-test-cases.md`）
- **测试范围**：功能测试（正常流程）、边界条件测试、错误处理测试、集成测试（如适用）

#### 单元测试生成流程（三阶段严格流程）

> **适用场景**：核心业务逻辑、工具函数/Hooks、API 端点（根据 Plan 中的即时验证策略）

对于需要即时测试的模块，使用以下三阶段流程生成单元测试：

**Phase 1: 行为提取（Behavior Extraction）**

从 Requirement 和测试用例文档中：

- 提取**仅适合单元测试**的行为（忽略 UI、集成、E2E、性能、视觉需求）
- **不要**发明或推断未明确声明的行为
- 将每个行为重写为清晰、可测试的规则

**输出**：编号的行为列表（无代码）

**Phase 2: 测试规范（Test Specification）**

对每个行为：

- 定义精确的输入
- 定义期望的输出
- 定义边界情况和错误条件（如适用）

**输出**：结构化的 JSON 数组（无测试代码）

**Phase 3: 单元测试实现（Unit Test Implementation）**

仅使用 Phase 2 的测试规范：

- 使用 Jest 编写单元测试
- 测试隔离（Mock 所有外部依赖）
- 一个测试对应一个行为
- 使用 Arrange–Act–Assert 模式
- 使用明确、有意义的断言
- **不要**添加新行为

**输入**：

- Requirement 文档
- 测试用例文档
- 待测试的源代码（如已实现）

**输出**：可运行的单元测试代码（无解释）

### 第四步：执行开发（边开发边验证）

> **核心原则**：核心逻辑即时测试，快速反馈，避免最后才发现基础模块有问题。

**执行节奏**：

- 按 Plan 中的 Tasks 顺序逐条推进（遵循依赖关系：先依赖项，后依赖方）
- 每完成一个功能模块，立即运行该模块的测试（根据 Plan 中的即时验证策略）
- 发现问题立即修复，再继续下一模块

**单元测试生成时机**（根据即时验证策略）：

对于需要即时测试的模块（核心业务逻辑、工具函数/Hooks、API 端点），在完成实现后：

1. **如果已编写测试用例文档**：使用三阶段流程（行为提取 → 测试规范 → 单元测试实现）生成单元测试
2. **如果未编写测试用例文档**：先快速提取行为，然后使用三阶段流程生成单元测试
3. **立即运行测试**：生成后立即运行，确保通过后再继续下一模块

**即时测试范围**（参考 Plan 中的即时验证策略）：

| 类型           | 策略              |
| -------------- | ----------------- |
| 核心业务逻辑   | ✅ 即时测试       |
| 工具函数/Hooks | ✅ 即时测试       |
| API 端点       | ✅ 即时测试       |
| UI 组件        | ⏳ 可延迟批量测试 |

**持续更新**：
- 将任务勾选与验证结果写回 plan 的 Worklog（以 `skill-plan-manager.mdc` 为准）
- **阶段性保存机制**（避免上下文占满）：
  - **触发时机**：
    1. 每完成一个重要任务模块（如完成一个完整功能）
    2. 遇到阻塞需要暂停时
    3. 上下文接近上限前（预估剩余 token 不足时）
    4. 工作会话即将结束时
  - **保存位置**：`ai/context/session/<REQ-xxx>-checkpoint-{timestamp}.md`
  - **保存内容**：
    ```markdown
    # Checkpoint: <REQ-xxx> - {timestamp}

    ## 已完成任务清单
    - [x] 任务1：...
    - [x] 任务2：...

    ## 当前进度
    - 完成度：X/Y 任务（百分比%）
    - 当前任务：正在执行的任务描述

    ## 关键决策点
    - 决策1：说明和理由
    - 决策2：说明和理由

    ## 待处理事项
    - 待完成任务1
    - 待完成任务2

    ## 阻塞项
    - 阻塞1：描述和解决方案（如有）

    ## 下一步建议
    - 下一步要执行的任务
    ```
  - **自动加载**：下次执行 `/work REQ-xxx` 时，自动检测并加载最近的 checkpoint

### 第五步：集成验收（开发完成后）

完成开发后进行最终验证：

- 运行完整测试套件
- 端到端集成测试
- 逐项确认 Requirement 验收检查清单
- 检查模块间交互正确性

### 第六步：同步文档（必须完成）

更新相关文档，确保与实现一致（参考 Plan 中的文档同步计划）：

- **技术文档**：API 文档、架构文档、数据库文档
- **设计文档**：UI/UX 说明、流程图
- **README**：功能列表、环境变量、部署说明
- **测试文档**：执行结果、已知问题

### 第七步：完成判断

当 Deliverables 全部完成，进入 `/review <REQ-xxx>`

---

## 输出要求

- 必须实际完成代码修改/文件更新，而不是只给建议
- 必须完成文档同步（不能跳过）
- **阶段性保存**：根据触发时机，自动保存 checkpoint 到 `ai/context/session/<REQ-xxx>-checkpoint-{timestamp}.md`
- **状态更新**：更新 plan.md 中的"状态摘要"字段（当前阶段、进度、当前任务、阻塞项）
- 最后用 3-6 行说明：完成了哪些任务、剩余哪些任务、当前验证状态、文档更新情况、下一步建议

## 质量检查清单

### Requirement 覆盖度

- [ ] 所有功能需求已实现
- [ ] 所有验收标准已达成

### 代码规范

- [ ] 命名约定正确
- [ ] 类型定义完整
- [ ] 代码结构符合架构模式

### 测试覆盖

- [ ] 测试用例文档已编写（如 Plan 中规划）
- [ ] 单元测试已生成（使用三阶段流程：行为提取 → 测试规范 → 单元测试实现）
- [ ] 单元测试全部通过
- [ ] 集成测试全部通过

### 文档同步

- [ ] 所有文档内容与实现一致（参考 Plan 中的文档同步计划）

## 注意事项

1. **严格遵守顺序**：先测试用例 → 边开发边验证 → 集成验收 → 同步文档
2. **规范优先**：不确定时参考 `.cursor/rules/development-specifications.mdc`
3. **核心逻辑即时测试**：不要等到最后才发现基础模块有问题
4. **文档同步必须完成**：不能跳过
