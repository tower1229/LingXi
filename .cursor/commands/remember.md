# /remember - 即时经验沉淀命令

## 命令用途

智能提取并沉淀经验到 `.workflow/context/experience/`，无需依赖 REQ-xxx。支持从用户输入直接提取经验，或从对话历史中提取"刚解决的问题/踩的坑"。这是最低摩擦的"即时沉淀入口"。

**设计原则**：
- **即时沉淀**：不依赖 REQ-xxx，随时可以沉淀单条经验
- **智能判断**：AI 根据用户输入的自然语言意图，自动选择合适的处理方式
- **预览确认**：提炼经验后先预览，用户确认后再写入经验库

---

## 前置要求（必须）

- **Cursor Nightly**：本工作流依赖 Agent Skills（仅 Nightly 渠道可用）

---

## 依赖的 Agent Skills

- `experience-depositor`（位于 `.cursor/skills/experience-depositor/SKILL.md`）
- `context-engineering`（位于 `.cursor/skills/context-engineering/SKILL.md`）

## 使用方式

```
/remember [用户输入]
```

**用户输入必须提供**，可以是：

- **直接经验表达**：`/remember 用户是唯一拥有价值判断能力的人`（AI 从输入中提取并结构化经验）
- **历史提取指引**：`/remember 吸取刚才这个bug的经验`（AI 从对话历史中提取相关经验）
- **混合模式**：`/remember 记住：用户是唯一拥有价值判断能力的人。另外，吸取刚才这个bug的经验`（AI 分别处理各部分）
- **简短提示**：`/remember 钱包选择问题`（帮助 AI 定位对话历史中要提取的内容）
- **关键词提示**：`/remember Apollo 配置`（帮助 AI 聚焦某个模块）

**核心原则**：
- **智能判断**：AI 根据用户输入的自然语言意图，自动选择合适的处理方式
- 如果用户输入是直接经验/原则/判断，从输入中提取并结构化
- 如果用户输入是历史提取指引（如"刚才/刚才的"），从对话历史中提取
- 如果用户输入是提示词，帮助定位对话历史中的相关内容

---

## 产物（必须写入）

- `.workflow/context/experience/<tag>-<title>.md`（一条经验文件，需用户确认后写入）
- `.workflow/context/experience/INDEX.md`（更新索引，需用户确认后写入）

---

## 执行要点

### 0) 解析用户输入（必须）

**用户输入不能为空**。如果用户只输入 `/remember` 而没有提供任何内容，应提示用户提供输入。

根据用户输入，理解意图：

- **直接经验表达**：用户直接陈述经验/原则/判断（如"用户是唯一拥有价值判断能力的人"）
- **历史提取指引**：用户要求从对话历史中提取（如"吸取刚才这个bug的经验"）
- **提示词定位**：用户提供关键词帮助定位（如"钱包选择问题"）
- **混合模式**：同时包含直接经验表达和历史提取指引

**处理策略**：

- 根据用户输入的自然语言意图，自动选择合适的处理方式
- 如果用户输入包含直接经验，从输入中提取并结构化
- 如果用户输入指向历史对话，从对话历史中提取
- 如果用户输入是混合的，分别处理各部分
- **优先推断，避免提问**：尽可能通过上下文推断缺失信息，只在完全无法推断时提问

### 1) 信息提取（根据意图选择来源）

根据理解到的意图，从合适的来源提取信息：

**如果用户输入是直接经验表达**：

- 从用户输入中提取核心判断/原则
- 从输入中的场景描述推断触发条件
- 从输入中提到的文件/函数/配置提取关联指针
- 通过上下文推断缺失的触发条件、校验方式等

**如果用户输入是历史提取指引或提示词**：

- 分析最近 20-30 轮对话
- 根据用户提示定位要提取的内容
- 识别"问题 → 排查 → 解决"的完整流程

提取的信息包括：

- **问题现象（Symptom）**：错误信息、异常表现、用户反馈
- **根因（Root cause）**：排查过程、验证结论
- **解决方案（Fix）**：修复步骤、配置变更、代码修改
- **触发条件（When to load）**：场景描述、需求上下文、技术栈
  - 例如：对话提到"商品发放"，触发条件就是"涉及商品发放功能时"
- **校验方式（How to verify）**：测试步骤、验证方法、检查点
  - 例如：对话提到"启动时检查配置"，校验方式就是"启动服务验证配置格式正确"
- **关联指针（Pointers）**：文件路径、函数名、配置项、服务名
  - 例如：对话提到 `src/config/apollo.ts` 和 `config/xxx.yaml`，就把这些作为指针

### 2) 自动推断缺失信息（优先推断，避免提问）

如果提取的信息有缺失，**优先通过上下文推断**，而不是问用户：

- **触发条件缺失**：从用户输入/对话历史中的功能/模块/场景描述推断（例如：如果对话围绕"用户登录"，触发条件就是"实现用户登录功能时"）
- **校验方式缺失**：从对话中的测试/验证/检查动作推断（例如：如果对话提到"运行测试"，校验方式就是"运行对应测试用例"）
- **关联指针缺失**：从对话中提到的代码文件/配置/服务自动提取

### 3) 仅在关键信息完全无法推断时提问（最多 1 个问题，提供选项）

只有在以下情况才问用户（且只问 1 个）：

- **触发条件完全无法推断**：向用户提问并提供可能的场景选项
- **校验方式完全无法推断**：向用户提问并提供可能的验证方式选项

**问询规则：**

- **只问 1 个最关键的问题**：如果多个信息缺失，优先推断最容易的，只问最关键的那个
- **提供选项**：根据上下文推断可能的选项，提供 2-3 个选项供用户选择
- **提问格式**：

  ```markdown
  ## 需要澄清的信息

  **问题**：[具体问题]

  - **选项 A**：[选项描述]
  - **选项 B**：[选项描述]
  - **选项 C**：[选项描述]

  请选择选项 A、B 或 C？
  ```

- **等待用户选择后，再继续执行**

**禁止问多个问题**；如果多个信息缺失，优先推断最容易的，只问最关键的那个。

### 4) 成长过滤器（强制：决定进 session 还是进 experience）

在决定"写入经验文档（长期）"之前，对每条候选先回答一个问题：

> **如果我一年后在完全不同的项目里再遇到类似局面，这条信息还能帮我提前做出正确判断吗？**

- 若答案是 **否**：不写入 experience，改为沉淀到 **session/worklog**（项目记录），并说明原因
- 若答案是 **是**：允许写入 experience（长期判断资产）

> 目的：避免 experience 退化为"事实堆叠/案例百科"，把长期资产留给"可迁移的判断结构"。

### 5) 冲突检测（必须执行）

在沉淀新经验前，必须执行冲突检测（按 skill `experience-depositor` 的冲突处理机制）：

1. **读取所有现有经验**：读取 `.workflow/context/experience/INDEX.md` 中的所有 active 经验
2. **冲突检测**：检查新经验是否与现有经验冲突（触发条件相同/相似且解决方案矛盾）
3. **识别冲突/重复**：如果检测到冲突或重复，在预览中明确标注

### 6) 生成经验预览（必须，用户确认前）

在写入经验库之前，**必须先展示完整的经验预览**，让用户确认：

**预览格式**：

```markdown
## 经验预览

### 基本信息
- **Tag**：<tag>
- **Title**：<title>
- **触发条件**：<trigger>

### 完整内容
<完整的经验文档内容，按模板格式展示>

### 冲突/重复检测
- [如有冲突] 与现有经验 `<existing-title>` 冲突，将标记旧经验为 deprecated
- [如有重复] 与现有经验 `<existing-title>` 高度相似，建议合并

### 确认选项
请选择：
- **A) 确认写入**：将经验写入 `.workflow/context/experience/<tag>-<title>.md` 并更新索引
- **B) 修改后写入**：告诉我需要修改的部分，我会调整后再次预览
- **C) 取消**：不写入经验库
```

**等待用户选择后，再继续执行**。

### 7) 经验写入（用户确认后）

只有当用户选择"确认写入"时，才执行以下操作。

每条经验必须补齐以下两段（必须含 Decision Shape 与 Judgment Capsule）

每条经验必须补齐以下两段（哪怕每段只写 3 行）：

- **Decision Shape（判断结构）**
  - Decision being made: 我当时在判断什么
  - Alternatives rejected: 我拒绝了哪些备选方案（至少 1 个）
  - Discriminating signal: 我靠什么可观测信号做出分叉
- **Judgment Capsule（认知蒸馏）**
  - I used to think:
  - Now I believe:
  - Because the decisive variable is:

创建 `.workflow/context/experience/<tag>-<title>.md`，按 skill `experience-depositor` 的模板写入：

```markdown
# <Title>

## 触发条件（When to load）

- ...（在什么场景下需要加载这条经验）

## 问题现象（Symptom）

- ...（用户看到/遇到的具体表现）

## 根因（Root cause）

- ...（为什么会出现这个问题）

## 解决方案（Fix）

- ...（如何解决/规避）

## 校验方式（How to verify）

- ...（如何验证问题已被解决/规避，必须可复现）

## 关联指针（Pointers）

- `path/to/file`：说明看什么

## Decision Shape（判断结构）

- Decision being made: 我当时在判断什么
- Alternatives rejected: 我拒绝了哪些备选方案（至少 1 个）
- Discriminating signal: 我靠什么可观测信号做出分叉

## Judgment Capsule（认知蒸馏）

- I used to think:
- Now I believe:
- Because the decisive variable is:

## 替代关系（Replaced by / Replaces）（可选，如有冲突则必须）

- **被替代**：此经验已被 `.workflow/context/experience/<tag>-<new-title>.md` 替代
- **替代**：此经验替代了 `.workflow/context/experience/<tag>-<old-title>.md`
```

### 8) 索引更新（用户确认后）

只有当用户选择"确认写入"时，才更新 `.workflow/context/experience/INDEX.md`，新增一行（Status 默认为 `active`）：

| Tag | Title | Trigger (when to load) | Status | File |

要求：

- **Tag**：简短标签（用于分类检索）
- **Title**：经验标题
- **Trigger**：触发条件摘要（1-2 行）
- **File**：`.workflow/context/experience/<tag>-<title>.md`

### 9) 触发 curator（自动执行）

当本次沉淀**实际新增**了经验文件后，需执行 `experience-curator` 的治理流程：

1. **经验治理（自动执行）**：合并/取代、更新 INDEX
2. **质量准则建议（仅建议）**：输出 1-3 条建议，等待用户采纳

---

## 输出要求

- **预览阶段**：展示完整的经验预览，等待用户确认
- **确认后**：实际创建/更新 `.workflow/context/experience/` 文件与索引
- **最后输出**：用 3-6 行简短说明：提取了什么经验、触发条件是什么、下次会在什么场景下自动提醒

---

## 示例场景

### 场景 1：直接经验表达

```
用户：/remember 用户是唯一拥有价值判断能力的人
AI：（识别为直接经验表达）
- 提取核心判断：用户是唯一拥有价值判断能力的人
- 推断触发条件：当 AI 需要做价值判断或决策时
- 推断校验方式：检查决策是否涉及价值判断，如是则必须询问用户
- 推断解决方案：涉及价值判断时，必须将决策权交给用户

AI：展示经验预览，等待用户确认
用户：选择 A) 确认写入
AI：写入经验文件并更新索引
```

### 场景 2：历史提取指引

```
用户：/remember 吸取刚才这个bug的经验
AI：（识别为历史提取指引，分析最近对话）
- 聚焦对话中关于 bug 的部分
- 提取：商品发放时选错钱包类型导致领取失败
- 触发条件：实现商品发放功能时
- 解决方案：虚拟商品必须发到虚拟钱包，实物商品发到实物钱包
- 校验方式：检查 goods_type 与 wallet_type 的匹配关系

AI：展示经验预览，等待用户确认
用户：选择 A) 确认写入
AI：写入经验文件并更新索引
```

### 场景 3：混合模式

```
用户：/remember 记住：用户是唯一拥有价值判断能力的人。另外，吸取刚才这个bug的经验
AI：（识别为混合模式，分别处理）
- 处理第一部分：生成直接经验（用户是唯一拥有价值判断能力的人）
- 处理第二部分：从历史提取经验（刚才的 bug）

AI：展示 2 条经验预览，等待用户确认
用户：选择 A) 确认写入（两条都写入）
AI：写入 2 条经验文件并更新索引
```

### 场景 4：提示词定位

```
用户：/remember 钱包选择问题
AI：（识别为提示词，聚焦对话中关于"钱包选择"的部分）
- 提取：商品发放时选错钱包类型导致领取失败
- 触发条件：实现商品发放功能时
- 解决方案：虚拟商品必须发到虚拟钱包，实物商品发到实物钱包
- 校验方式：检查 goods_type 与 wallet_type 的匹配关系

AI：展示经验预览，等待用户确认
用户：选择 B) 修改后写入，要求补充更多细节
AI：调整后再次展示预览
用户：选择 A) 确认写入
AI：写入经验文件并更新索引
```

### 场景 5：信息不足，需要提问

```
用户：/remember 刚才修复的配置问题
AI：（分析对话，发现解决了问题但缺少触发条件）
AI：这个问题会在什么场景下再次出现？
- 选项 A：商品发放时
- 选项 B：用户登录时
- 选项 C：订单处理时
用户：选项 A

AI：展示经验预览，等待用户确认
用户：选择 A) 确认写入
AI：写入经验文件并更新索引
```

### 场景 6：空输入（不支持）

```
用户：/remember
AI：请提供要沉淀的经验内容。你可以：
- 直接表达经验：/remember 用户是唯一拥有价值判断能力的人
- 从历史提取：/remember 吸取刚才这个bug的经验
- 提供提示词：/remember 钱包选择问题
```

---

## 与 `/flow 沉淀` 的区别

| 维度 | `/remember` | `/flow 沉淀` |
|-----|------------|-------------|
| **使用场景** | 即时沉淀单条经验 | 围绕 REQ-xxx 系统性复利收尾 |
| **依赖** | 不需要 REQ-xxx | 需要 REQ-xxx |
| **确认机制** | 预览后确认写入 | 选择候选后确认写入 |
| **产物** | 单条经验 | 多条经验 + 上下文补齐 + 需求状态推进 |

两者互补，不冲突。
