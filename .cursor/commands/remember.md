# /remember（可选兼容）

本仓库主入口为 `/flow`；沉淀确认也统一走 `/flow 沉淀 ...`。

如果你仍想手动即时沉淀，可继续使用 `/remember`（内部应调用 skill `experience-depositor`）。

**从最近的对话历史中自动提取“刚解决的问题/踩的坑”**，并沉淀为经验到 `.workflow/context/experience/`，无需依赖 REQ-xxx。这是最低摩擦的“即时沉淀入口”。

## 依赖的 Skills

- `experience-depositor`（位于 `.cursor/skills/experience-depositor/SKILL.md`）
- `context-engineering`（位于 `.cursor/skills/context-engineering/SKILL.md`）

## 使用方式

```
/remember [可选：提示词]
```

用户输入是可选的，可以是：

- **完全为空**：`/remember`（AI 自动识别最近对话中解决的问题）
- **简短提示**：`/remember 钱包选择问题`（帮助 AI 定位要提取的内容）
- **关键词提示**：`/remember Apollo 配置`（帮助 AI 聚焦某个模块）

**核心原则**：用户输入只是提示，主要上下文是**对话历史**。

---

## 产物（必须落盘）

- `.workflow/context/experience/<tag>-<title>.md`（一条经验文件）
- `.workflow/context/experience/INDEX.md`（更新索引）

## 执行要点（智能提取）

### 1) 从对话历史提取关键信息（优先）

**必须主动分析最近 20-30 轮对话**，识别“问题 → 排查 → 解决”的完整流程，并提取：

- **问题现象（Symptom）**：从对话中的错误信息、异常表现、用户反馈提取
- **根因（Root cause）**：从对话中的排查过程、验证结论提取
- **解决方案（Fix）**：从对话中的修复步骤、配置变更、代码修改提取
- **触发条件（When to load）**：从对话中的场景描述、需求上下文、技术栈推断
  - 例如：对话提到“商品发放”，触发条件就是“涉及商品发放功能时”
- **校验方式（How to verify）**：从对话中的测试步骤、验证方法、检查点提取
  - 例如：对话提到“启动时检查配置”，校验方式就是“启动服务验证配置格式正确”
- **关联指针（Pointers）**：从对话中提到的文件路径、函数名、配置项、服务名提取
  - 例如：对话提到 `src/config/apollo.ts` 和 `config/xxx.yaml`，就把这些作为指针

### 2) 自动推断缺失信息（尽量避免提问）

如果提取的信息有缺失，**优先通过上下文推断**，而不是问用户：

- **触发条件缺失**：从对话中的功能/模块/场景描述推断（例如：如果对话围绕“用户登录”，触发条件就是“实现用户登录功能时”）
- **校验方式缺失**：从对话中的测试/验证/检查动作推断（例如：如果对话提到“运行测试”，校验方式就是“运行对应测试用例”）
- **关联指针缺失**：从对话中提到的代码文件/配置/服务自动提取

### 3) 仅在关键信息完全无法推断时提问（最多 1 个问题，提供选项）

只有在以下情况才问用户（且只问 1 个）：

- **触发条件完全无法推断**：向用户提问并提供可能的场景选项
- **校验方式完全无法推断**：向用户提问并提供可能的验证方式选项

**问询规则：**
- **只问 1 个最关键的问题**：如果多个信息缺失，优先推断最容易的，只问最关键的那个
- **提供选项**：根据上下文推断可能的选项，提供 2-3 个选项供用户选择
- **提问格式**：
  ```markdown
  ## 需要澄清的信息

  **问题**：[具体问题]

  - **选项 A**：[选项描述]
  - **选项 B**：[选项描述]
  - **选项 C**：[选项描述]

  请选择选项 A、B 或 C？
  ```
- **等待用户选择后，再继续执行**

**禁止问多个问题**；如果多个信息缺失，优先推断最容易的，只问最关键的那个。

### 4) 冲突检测与处理（必须执行）

在沉淀新经验前，必须执行冲突检测（按 skill `experience-depositor` 的冲突处理机制）：

1. **读取所有现有经验**：读取 `.workflow/context/experience/INDEX.md` 中的所有 active 经验
2. **冲突检测**：检查新经验是否与现有经验冲突（触发条件相同/相似且解决方案矛盾）
3. **自动剔除矛盾旧经验**：如果检测到冲突，自动标记旧经验为 `deprecated`，并在新经验中记录替代关系
4. **经验合并/去重**：如果检测到重复或高度相似的经验（而非冲突），提供合并选项

### 5) 经验落盘（必须含触发条件与校验方式）

创建 `.workflow/context/experience/<tag>-<title>.md`，按 skill `experience-depositor` 的模板写入：

```markdown
# <Title>

## 触发条件（When to load）

- ...（在什么场景下需要加载这条经验）

## 问题现象（Symptom）

- ...（用户看到/遇到的具体表现）

## 根因（Root cause）

- ...（为什么会出现这个问题）

## 解决方案（Fix）

- ...（如何解决/规避）

## 校验方式（How to verify）

- ...（如何验证问题已被解决/规避，必须可复现）

## 关联指针（Pointers）

- `path/to/file`：说明看什么

## 替代关系（Replaced by / Replaces）（可选，如有冲突则必须）

- **被替代**：此经验已被 `.workflow/context/experience/<tag>-<new-title>.md` 替代
- **替代**：此经验替代了 `.workflow/context/experience/<tag>-<old-title>.md`
```

### 6) 索引更新（必须）

更新 `.workflow/context/experience/INDEX.md`，新增一行（Status 默认为 `active`）：

| Tag | Title | Trigger (when to load) | Status | File |

要求：

- **Tag**：简短标签（用于分类检索）
- **Title**：经验标题
- **Trigger**：触发条件摘要（1-2 行）
- **File**：`.workflow/context/experience/<tag>-<title>.md`

---

## 输出要求

- 必须实际创建/更新 `.workflow/context/experience/` 文件与索引
- 最后用 3-6 行简短说明：从对话中提取了什么经验、触发条件是什么、下次会在什么场景下自动提醒

## 示例场景

### 场景 1：用户只说 `/remember`（无输入）

```
用户：/remember
AI：（分析最近对话）
- 对话提到：Apollo 配置格式导致启动失败
- 排查过程：发现配置值必须用引号包裹
- 解决方案：修改 config/apollo.yaml，给值加引号
- 验证：重启服务，启动成功
AI：自动生成 `.workflow/context/experience/apollo-config-quote-requirement.md`
```

### 场景 2：用户给提示 `/remember 钱包选择`

```
用户：/remember 钱包选择
AI：（聚焦对话中关于“钱包选择”的部分）
- 提取：商品发放时选错钱包类型导致领取失败
- 触发条件：实现商品发放功能时
- 解决方案：虚拟商品必须发到虚拟钱包，实物商品发到实物钱包
- 校验方式：检查 goods_type 与 wallet_type 的匹配关系
AI：自动生成经验文件
```

### 场景 3：信息不足，需要提问

```
用户：/remember
AI：（分析对话，发现解决了问题但缺少触发条件）
AI：这个问题会在什么场景下再次出现？
用户：商品发放时
AI：自动生成经验文件（补充触发条件）
```

## 与 `/compound` 的区别

- **`/remember`**：即时沉淀**单条经验**，不需要 REQ-xxx，最低摩擦
- **`/compound`**：围绕一个 **REQ-xxx** 做**系统性复利收尾**（多条经验 + 上下文补齐 + 需求状态推进）

两者互补，不冲突。
