# /remember - 即时质量标准沉淀命令

## 命令用途

智能提取并沉淀质量标准，支持从用户输入直接提取质量标准，或从对话历史中提取"刚解决的问题/踩的坑"。这是最低摩擦的"即时沉淀入口"。

**存储目标**：用户可选择存入经验库（`.workflow/context/experience/`）或规则库（`.cursor/rules/qs-*/`），AI 推荐规则应用方式。

**设计原则**：

- **即时沉淀**：不依赖 REQ-xxx，随时可以沉淀单条经验
- **智能判断**：AI 根据用户输入的自然语言意图，自动选择合适的处理方式
- **预览确认**：提炼经验后先预览，用户确认后再写入经验库

---

## 前置要求（必须）

- **Cursor Nightly**：本工作流依赖 Agent Skills（仅 Nightly 渠道可用）

---

## 依赖的 Agent Skills

- `experience-depositor`（位于 `.cursor/skills/experience-depositor/SKILL.md`）
- `context-engineering`（位于 `.cursor/skills/context-engineering/SKILL.md`）

## 使用方式

```
/remember [用户输入]
```

**用户输入必须提供**，可以是：

- **直接经验表达**：`/remember 用户是唯一拥有价值判断能力的人`（AI 从输入中提取并结构化经验）
- **历史提取指引**：`/remember 吸取刚才这个bug的经验`（AI 从对话历史中提取相关经验）
- **混合模式**：`/remember 记住：用户是唯一拥有价值判断能力的人。另外，吸取刚才这个bug的经验`（AI 分别处理各部分）
- **简短提示**：`/remember 钱包选择问题`（帮助 AI 定位对话历史中要提取的内容）
- **关键词提示**：`/remember Apollo 配置`（帮助 AI 聚焦某个模块）

**核心原则**：

- **智能判断**：AI 根据用户输入的自然语言意图，自动选择合适的处理方式
- 如果用户输入是直接经验/原则/判断，从输入中提取并结构化
- 如果用户输入是历史提取指引（如"刚才/刚才的"），从对话历史中提取
- 如果用户输入是提示词，帮助定位对话历史中的相关内容

---

## 产物（必须写入）

根据用户选择的存储目标：

- **如果选择经验库**：

  - `.workflow/context/experience/<tag>-<title>.md`（一条经验文件，需用户确认后写入）
  - `.workflow/context/experience/INDEX.md`（更新索引，需用户确认后写入）

- **如果选择规则库**：
  - `.cursor/rules/qs-{type}-{scope}/RULE.md`（质量准则规则，需用户确认后写入）
  - `.cursor/rules/quality-standards-index.md`（更新索引，需用户确认后写入）
  - `.cursor/rules/quality-standards-schema.md`（更新状态，需用户确认后写入）

---

## 执行要点

### 0) 解析用户输入（必须）

**用户输入不能为空**。如果用户只输入 `/remember` 而没有提供任何内容，应提示用户提供输入。

> **注意**：编号选择（如 `1,3`）通常直接输入即可，无需 `/remember` 前缀。如果用户使用 `/remember 1,3`，也支持，但建议直接输入编号。

**如果用户输入是编号格式**（如 `1,3`、`1 3`、`1,2,3`、`全部`、`all`），则：

1. 读取 `.workflow/context/session/pending-compounding-candidates.json`
2. 解析编号，选择对应的候选
3. 对选中的候选执行沉淀流程（从步骤 4 开始，跳过提取步骤）

**如果不是编号选择**，根据用户输入理解意图：

- **直接经验表达**：用户直接陈述经验/原则/判断（如"用户是唯一拥有价值判断能力的人"）
- **历史提取指引**：用户要求从对话历史中提取（如"吸取刚才这个 bug 的经验"）
- **提示词定位**：用户提供关键词帮助定位（如"钱包选择问题"）
- **混合模式**：同时包含直接经验表达和历史提取指引

**处理策略**：

- 如果用户输入是编号格式，优先按编号选择候选
- 如果用户输入包含直接经验，从输入中提取并结构化
- 如果用户输入指向历史对话，从对话历史中提取
- 如果用户输入是混合的，分别处理各部分
- **优先推断，避免提问**：尽可能通过上下文推断缺失信息，只在完全无法推断时提问

### 1) 信息提取（根据意图选择来源）

根据理解到的意图，从合适的来源提取信息：

**如果用户输入是直接经验表达**：

- 从用户输入中提取核心判断/原则
- 从输入中的场景描述推断触发条件
- 从输入中提到的文件/函数/配置提取关联指针
- 通过上下文推断缺失的触发条件、校验方式等

**如果用户输入是历史提取指引或提示词**：

- 分析最近 20-30 轮对话
- 根据用户提示定位要提取的内容
- 识别"问题 → 排查 → 解决"的完整流程

提取的信息包括：

- **问题现象（Symptom）**：错误信息、异常表现、用户反馈
- **根因（Root cause）**：排查过程、验证结论
- **解决方案（Fix）**：修复步骤、配置变更、代码修改
- **触发条件（When to load）**：场景描述、需求上下文、技术栈
  - 例如：对话提到"商品发放"，触发条件就是"涉及商品发放功能时"
- **校验方式（How to verify）**：测试步骤、验证方法、检查点
  - 例如：对话提到"启动时检查配置"，校验方式就是"启动服务验证配置格式正确"
- **关联指针（Pointers）**：文件路径、函数名、配置项、服务名
  - 例如：对话提到 `src/config/apollo.ts` 和 `config/xxx.yaml`，就把这些作为指针

### 2) 自动推断缺失信息（优先推断，避免提问）

如果提取的信息有缺失，**优先通过上下文推断**，而不是问用户：

- **触发条件缺失**：从用户输入/对话历史中的功能/模块/场景描述推断（例如：如果对话围绕"用户登录"，触发条件就是"实现用户登录功能时"）
- **校验方式缺失**：从对话中的测试/验证/检查动作推断（例如：如果对话提到"运行测试"，校验方式就是"运行对应测试用例"）
- **关联指针缺失**：从对话中提到的代码文件/配置/服务自动提取

### 3) 仅在关键信息完全无法推断时提问（最多 1 个问题，提供选项）

只有在以下情况才问用户（且只问 1 个）：

- **触发条件完全无法推断**：向用户提问并提供可能的场景选项
- **校验方式完全无法推断**：向用户提问并提供可能的验证方式选项

**问询规则：**

- **只问 1 个最关键的问题**：如果多个信息缺失，优先推断最容易的，只问最关键的那个
- **提供选项**：根据上下文推断可能的选项，提供 2-3 个选项供用户选择
- **提问格式**：

  ```markdown
  ## 需要澄清的信息

  **问题**：[具体问题]

  - **选项 A**：[选项描述]
  - **选项 B**：[选项描述]
  - **选项 C**：[选项描述]

  请选择选项 A、B 或 C？
  ```

- **等待用户选择后，再继续执行**

**禁止问多个问题**；如果多个信息缺失，优先推断最容易的，只问最关键的那个。

### 4) 成长过滤器（强制：决定进 session 还是进 experience）

在决定"写入经验文档（长期）"之前，对每条候选先回答一个问题：

> **如果我一年后在完全不同的项目里再遇到类似局面，这条信息还能帮我提前做出正确判断吗？**

- 若答案是 **否**：不写入 experience，改为沉淀到 **session/worklog**（项目记录），并说明原因
- 若答案是 **是**：允许写入 experience（长期判断资产）

> 目的：避免 experience 退化为"事实堆叠/案例百科"，把长期资产留给"可迁移的判断结构"。

### 5) 冲突检测（必须执行）

在沉淀新经验前，必须执行冲突检测（按 skill `experience-depositor` 的冲突处理机制）：

1. **读取所有现有经验**：读取 `.workflow/context/experience/INDEX.md` 中的所有 active 经验
2. **冲突检测**：检查新经验是否与现有经验冲突（触发条件相同/相似且解决方案矛盾）
3. **识别冲突/重复**：如果检测到冲突或重复，在预览中明确标注

### 6) 生成质量标准预览（必须，用户确认前）

在写入之前，**必须先展示完整的质量标准预览**，让用户确认：

**预览格式**：

```markdown
## 质量标准预览

### 内容摘要

- **标题**：<title>
- **触发条件**：<trigger>
- **核心判断**：<核心判断摘要>

### 存储目标选择

- **A) 存入经验库**：写入 .workflow/context/experience/，下次匹配时作为提醒

- **B) 存入规则库**：写入 .cursor/rules/，作为 Cursor 规则自动加载

  **规则配置预览**（如果选择 B）：

- **推荐应用方式**：文件匹配（上下文成本最低）
- **推荐配置**：
- Type: fs (file-scoped)
- Scope: frontend
- Globs: `**/components/**/*.tsx`（根据项目实际结构调整）
- 理由：内容明确涉及"组件"，适合文件匹配方式

### 完整内容

<完整的质量标准文档内容，按模板格式展示>

### 冲突/重复检测

- [如有冲突] 与现有经验 `<existing-title>` 冲突，将标记旧经验为 deprecated
- [如有重复] 与现有经验 `<existing-title>` 高度相似，建议合并

### 确认选项

请选择：

- **A) 存入经验库**：将质量标准写入 `.workflow/context/experience/<tag>-<title>.md` 并更新索引
- **B) 存入规则库**：将质量标准写入 `.cursor/rules/qs-{type}-{scope}/RULE.md` 并更新索引（使用上述推荐配置）
- **C) 修改后写入**：告诉我需要修改的部分，我会调整后再次预览
- **D) 取消**：不写入
```

**等待用户选择后，再继续执行**。

### 7) 质量标准写入（用户确认后）

只有当用户选择"存入经验库"或"存入规则库"时，才执行以下操作。

每条经验必须补齐以下两段（必须含 Decision Shape 与 Judgment Capsule）

每条经验必须补齐以下两段（哪怕每段只写 3 行）：

- **Decision Shape（判断结构）**
  - Decision being made: 我当时在判断什么
  - Alternatives rejected: 我拒绝了哪些备选方案（至少 1 个）
  - Discriminating signal: 我靠什么可观测信号做出分叉
- **Judgment Capsule（认知蒸馏）**
  - I used to think:
  - Now I believe:
  - Because the decisive variable is:

**如果用户选择 A（存入经验库）**：

创建 `.workflow/context/experience/<tag>-<title>.md`，按 skill `experience-depositor` 的模板写入：

```markdown
# <Title>

## 触发条件（When to load）

- ...（在什么场景下需要加载这条经验）

## 问题现象（Symptom）

- ...（用户看到/遇到的具体表现）

## 根因（Root cause）

- ...（为什么会出现这个问题）

## 解决方案（Fix）

- ...（如何解决/规避）

## 校验方式（How to verify）

- ...（如何验证问题已被解决/规避，必须可复现）

## 关联指针（Pointers）

- `path/to/file`：说明看什么

## Decision Shape（判断结构）

- Decision being made: 我当时在判断什么
- Alternatives rejected: 我拒绝了哪些备选方案（至少 1 个）
- Discriminating signal: 我靠什么可观测信号做出分叉

## Judgment Capsule（认知蒸馏）

- I used to think:
- Now I believe:
- Because the decisive variable is:

## 替代关系（Replaced by / Replaces）（可选，如有冲突则必须）

- **被替代**：此经验已被 `.workflow/context/experience/<tag>-<new-title>.md` 替代
- **替代**：此经验替代了 `.workflow/context/experience/<tag>-<old-title>.md`
```

**如果用户选择 B（存入规则库）**：

调用 `rules-creator` skill，使用预览阶段推荐的配置创建规则：

- 创建或更新 `.cursor/rules/qs-{type}-{scope}/RULE.md`
- 更新 `.cursor/rules/quality-standards-index.md`
- 更新 `.cursor/rules/quality-standards-schema.md`

### 8) 索引更新（用户确认后）

**如果用户选择 A（存入经验库）**：

只有当用户选择"存入经验库"时，才更新 `.workflow/context/experience/INDEX.md`，新增一行（Status 默认为 `active`）：

| Tag | Title | Trigger (when to load) | Status | File |

要求：

- **Tag**：简短标签（用于分类检索）
- **Title**：经验标题
- **Trigger**：触发条件摘要（1-2 行）
- **File**：`.workflow/context/experience/<tag>-<title>.md`

### 9) 触发 curator（仅限经验库，自动执行）

当本次沉淀**实际新增**了经验文件（存入经验库）后，需执行 `experience-curator` 的治理流程：

1. **经验治理（自动执行）**：合并/取代、更新 INDEX

**注意**：不再输出质量准则建议，用户已在存储目标选择阶段决定是否创建规则。

---

## 输出要求

- **预览阶段**：展示完整的质量标准预览（包括存储目标选择和规则配置预览），等待用户确认
- **确认后**：根据用户选择，实际创建/更新经验库或规则库文件与索引
- **最后输出**：
  - 如果存入经验库：用 3-6 行简短说明：提取了什么经验、触发条件是什么、下次会在什么场景下自动提醒
  - 如果存入规则库：用 3-6 行简短说明：创建了什么规则、应用方式是什么、何时会自动加载

---

## 示例场景

### 场景 1：直接经验表达（存入经验库）

```
用户：/remember 用户是唯一拥有价值判断能力的人
AI：（识别为直接经验表达）
- 提取核心判断：用户是唯一拥有价值判断能力的人
- 推断触发条件：当 AI 需要做价值判断或决策时
- 推断校验方式：检查决策是否涉及价值判断，如是则必须询问用户
- 推断解决方案：涉及价值判断时，必须将决策权交给用户

AI：展示质量标准预览（包括存储目标选择），等待用户确认
用户：选择 A) 存入经验库
AI：写入经验文件并更新索引，触发 curator 治理
```

### 场景 1b：直接经验表达（存入规则库）

```
用户：/remember 组件必须定义 Props 类型
AI：（识别为直接经验表达）
- 提取核心判断：组件必须定义 Props 类型
- 推断触发条件：编写 React 组件时
- 推断校验方式：检查组件是否定义了 Props 类型

AI：展示质量标准预览（包括存储目标选择和规则配置预览），等待用户确认
用户：选择 B) 存入规则库
AI：调用 rules-creator，创建 qs-fs-frontend 规则并更新索引
```

### 场景 2：历史提取指引

```
用户：/remember 吸取刚才这个bug的经验
AI：（识别为历史提取指引，分析最近对话）
- 聚焦对话中关于 bug 的部分
- 提取：商品发放时选错钱包类型导致领取失败
- 触发条件：实现商品发放功能时
- 解决方案：虚拟商品必须发到虚拟钱包，实物商品发到实物钱包
- 校验方式：检查 goods_type 与 wallet_type 的匹配关系

AI：展示质量标准预览（包括存储目标选择），等待用户确认
用户：选择 A) 存入经验库
AI：写入经验文件并更新索引，触发 curator 治理
```

### 场景 3：混合模式

```
用户：/remember 记住：用户是唯一拥有价值判断能力的人。另外，吸取刚才这个bug的经验
AI：（识别为混合模式，分别处理）
- 处理第一部分：生成直接经验（用户是唯一拥有价值判断能力的人）
- 处理第二部分：从历史提取经验（刚才的 bug）

AI：展示 2 条质量标准预览（每条都包括存储目标选择），等待用户确认
用户：选择 A) 存入经验库（两条都存入经验库）
AI：写入 2 条经验文件并更新索引，触发 curator 治理
```

### 场景 4：提示词定位

```
用户：/remember 钱包选择问题
AI：（识别为提示词，聚焦对话中关于"钱包选择"的部分）
- 提取：商品发放时选错钱包类型导致领取失败
- 触发条件：实现商品发放功能时
- 解决方案：虚拟商品必须发到虚拟钱包，实物商品发到实物钱包
- 校验方式：检查 goods_type 与 wallet_type 的匹配关系

AI：展示质量标准预览（包括存储目标选择），等待用户确认
用户：选择 C) 修改后写入，要求补充更多细节
AI：调整后再次展示预览
用户：选择 A) 存入经验库
AI：写入经验文件并更新索引，触发 curator 治理
```

### 场景 5：信息不足，需要提问

```
用户：/remember 刚才修复的配置问题
AI：（分析对话，发现解决了问题但缺少触发条件）
AI：这个问题会在什么场景下再次出现？
- 选项 A：商品发放时
- 选项 B：用户登录时
- 选项 C：订单处理时
用户：选项 A

AI：展示质量标准预览（包括存储目标选择），等待用户确认
用户：选择 A) 存入经验库
AI：写入经验文件并更新索引，触发 curator 治理
```

### 场景 6：编号选择候选

```
用户：/remember 1,3
AI：（识别为编号选择）
- 读取 pending-compounding-candidates.json
- 解析编号：选择第 1 和第 3 个候选
- 展示选中的 2 个候选的预览
- 等待用户确认

用户：选择 A) 存入经验库（两条都存入经验库）
AI：写入 2 条经验文件并更新索引，触发 curator 治理
```

### 场景 7：空输入（不支持）

```
用户：/remember
AI：请提供要沉淀的经验内容。你可以：
- 直接表达经验：/remember 用户是唯一拥有价值判断能力的人
- 从历史提取：/remember 吸取刚才这个bug的经验
- 提供提示词：/remember 钱包选择问题

（如果有候选列表，直接输入编号即可，如：1,3）
```
