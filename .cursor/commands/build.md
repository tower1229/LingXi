---
name: build
description: 执行构建（双模式：Plan-driven 或 Agent-driven）
args:
  - name: taskId
    required: true
    description: 任务编号（如 001）
---

# /build - 执行构建

## 命令用途

用于按 req 文档实现功能，支持两种执行模式：

- **Plan-driven 模式**：有 plan 文档时，按计划结构化执行（推荐）
- **Agent-driven 模式**：无 plan 文档时，Agent 基于 req 自行决策执行

**定位**：该步骤虽然理论上不可跳过，但是创造者可以选择不调用 build 命令而自行基于 req 文档和可选的 plan 文档进行开发工作，因此从流程上将该步骤仍然可以跳过。

## 前置要求

- **Cursor Nightly**：本工作流依赖 Agent Skills（仅 Nightly 渠道可用）
- req 文档已存在：`.workflow/requirements/<taskId>.req.*.md`

## 使用方式

```
/build <taskId>
```

**示例**：

```
/build 001
```

## 依赖的 Agent Skills

- `experience-index`：自动匹配历史经验提醒
- `service-loader`：如适用，生成服务上下文
- `context-engineering`：上下文工程指导

## 模式检测（自动）

执行 `/build <taskId>` 时，自动检测执行模式：

1. **检测 plan 文件**：
   - 扫描 `.workflow/requirements/` 目录
   - 查找 `<taskId>.plan.*.md` 文件（如 `001.plan.*.md`）

2. **模式判断**：
   - **存在 plan 文件** → Plan-driven 模式
   - **不存在 plan 文件** → Agent-driven 模式

3. **模式提示**：
   - 静默检测，在开始执行时输出当前模式（如："检测到 plan 文档，进入 Plan-driven 模式"）

## 执行逻辑分支

### Plan-driven 模式（有 plan 时）

#### 1. 读取输入

- `.workflow/requirements/<taskId>.req.<标题>.md`
- `.workflow/requirements/<taskId>.plan.<标题>.md`
- `.workflow/requirements/<taskId>.testcase.<标题>.md`

#### 2. 代码实现

- 按 req 的技术方案实现功能
- 按 plan 的任务清单顺序执行开发任务
- 遵循 plan 中的依赖关系和执行顺序

#### 3. 编写测试脚本

- 读取 `<taskId>.testcase.<标题>.md`
- 基于测试用例文档编写测试脚本
- 遵循项目测试框架（plan 中检测到的框架）
- 按模块组织：模块完成后编写并执行对应测试

#### 4. 执行单元测试（循环修复直到全部通过）

- 模块完成后执行单元测试
- 记录测试执行结果（通过/失败）
- **如果测试失败**：
  - 分析失败原因，定位 bug
  - 修复 bug
  - 重新执行单元测试
  - **循环执行**：修复 → 测试 → 修复 → 测试，直到所有单元测试全部通过
- **只有所有单元测试通过后，才继续下一个模块或任务**

#### 5. 文档同步（plan 中的任务）

- 读取 plan 中的文档同步任务清单
- 基于代码变更自动更新相关文档：
  - 扫描代码注释、类型定义
  - 提取接口信息、模块结构
  - 更新文档对应章节
- 同步完成后标记任务完成

### Agent-driven 模式（无 plan 时）

#### 1. 读取输入

- `.workflow/requirements/<taskId>.req.<标题>.md`（仅）

#### 2. 任务拆解（Agent 决策）

- 基于 req 的功能需求，Agent 自行拆解为可执行的子任务
- 识别功能模块、依赖关系、执行顺序
- 动态决策实现路径（在无 plan 的情况下）

#### 3. 代码实现

- 按 req 的技术方案实现功能
- 按 Agent 拆解的任务顺序执行
- Agent 自行判断实现细节（req 中不含实现细节）

#### 4. 测试框架检测（Agent 决策）

- 检测项目中现有的测试框架（同 plan 阶段的检测逻辑）：
  - 检查 `package.json` 的 `devDependencies`（jest, vitest, mocha, jasmine 等）
  - 检查项目根目录的测试配置文件（`jest.config.js`, `vitest.config.ts`, `mocha.opts` 等）
  - 检查测试目录结构（`tests/`, `__tests__/`, `test/`, `spec/` 等）
  - 检查测试文件模式（`*.test.js`, `*.spec.ts`, `*.test.tsx` 等）
- 如无框架，Agent 自行决定是否安装 vitest（推荐安装）
- 如安装，执行安装流程（同 plan 阶段）

#### 5. 编写测试脚本（基于 req 验收标准）

- 基于 req 的验收标准编写测试用例（而非 testcase 文档）
- 覆盖 req 中定义的功能验收清单
- 遵循检测到的测试框架
- 按模块组织：模块完成后编写并执行对应测试

#### 6. 执行单元测试（循环修复直到全部通过）

- 模块完成后执行单元测试
- 记录测试执行结果（通过/失败）
- **如果测试失败**：
  - 分析失败原因，定位 bug
  - 修复 bug
  - 重新执行单元测试
  - **循环执行**：修复 → 测试 → 修复 → 测试，直到所有单元测试全部通过
- **只有所有单元测试通过后，才继续下一个模块或任务**

#### 7. 文档同步（Agent 识别）

- Agent 自行识别可能受本次改动影响的文档：
  - 扫描项目目录（`docs/`, `design/`, `architecture/` 等）
  - 基于代码变更识别相关文档
  - 识别技术方案文档、设计文档等
- 基于代码变更自动更新相关文档：
  - 扫描代码注释、类型定义
  - 提取接口信息、模块结构
  - 更新文档对应章节

## 降级方案

**Plan-driven 模式降级**：

- 如果测试框架无法执行：输出手动测试清单（基于 testcase 文档）
- 如果文档同步无法执行：输出文档更新清单（基于 plan 清单）

**Agent-driven 模式降级**：

- 如果测试框架无法执行：输出手动测试清单（基于 req 验收标准）
- 如果文档同步无法执行：输出文档更新清单（Agent 识别的文档列表）

## 模式选择建议

| 场景 | 推荐模式 | 理由 |
|------|---------|------|
| 复杂任务（多模块、多依赖） | Plan-driven | 需要明确的任务拆解和依赖管理 |
| 简单任务（单一功能、无依赖） | Agent-driven | Agent 可直接判断和执行 |
| 需要明确的测试策略 | Plan-driven | 有 testcase 文档指导 |
| 需要文档同步计划 | Plan-driven | 有明确的文档清单 |
| 快速原型开发 | Agent-driven | 无需详细规划，快速迭代 |
| 生产环境功能 | Plan-driven | 需要更严格的计划和验证 |

## 执行质量保证

两种模式都确保：

1. **功能完整性**：满足 req 中的所有功能需求
2. **验收标准**：通过 req 定义的验收标准
3. **代码质量**：遵循项目代码规范（由 rules 定义）
4. **测试覆盖**：确保关键功能有测试覆盖
5. **文档一致性**：代码与相关文档保持一致

## 测试执行规范

### 测试执行时机

| 时机                 | 动作         | 目的         |
| -------------------- | ------------ | ------------ |
| 任务开始前           | 运行现有测试 | 确认基线正常 |
| 每完成一个实现任务后 | 运行相关测试 | 确认实现正确 |
| 进入 review 前       | 运行全部测试 | 确认无回归   |

### 测试编写规范

编写单元测试时遵循：

| 原则             | 说明                                                     |
| ---------------- | -------------------------------------------------------- |
| **隔离测试**     | Mock 所有外部依赖（API、数据库、文件系统）               |
| **一行为一测试** | 每个测试只验证一个行为，便于定位问题                     |
| **AAA 模式**     | Arrange（准备数据）→ Act（执行操作）→ Assert（验证结果） |
| **基于规格**     | 只测试 plan/testcase 或 req 中定义的行为，不发明新行为   |

### 测试结果记录

**测试通过时**：

- 完全静默，不输出测试结果
- 继续下一个任务

**测试失败时**：

- 输出失败详情，包含失败的测试用例、错误信息、修复建议
- 修复后重新执行测试，循环直到全部通过

## 经验候选捕获（即时捕获）

在实现/排查过程中，如发生以下情况，立即输出经验候选（HTML 注释包裹，不干扰对话）：

| 触发场景     | 描述                               | 典型信号                           |
| ------------ | ---------------------------------- | ---------------------------------- |
| **实现纠正** | 用户纠正实现方向/方式/细节         | "不要这样写"、"改成那样"           |
| **方案切换** | 实现中发现原方案不可行，切换方案   | "这个方案不行，换成..."            |
| **根因定位** | 排查问题找到 root cause            | "原来是因为..."、"根本原因是..."   |
| **测试修复** | 测试失败暴露问题并修复             | 测试红→绿 + 修复原因               |
| **契约确认** | 确认/修订接口契约或数据结构        | "接口改成这样"、"字段要加个 X"     |
| **性能问题** | 发现性能/内存/兼容性问题并解决     | "太慢了"、"内存泄漏"、"不兼容"     |
| **依赖问题** | 发现依赖库问题，更换或绕过         | "这个库有 bug"、"换成另一个"       |
| **边界处理** | 确认/修订边界条件处理方式          | "空值怎么处理"、"异常怎么抛"       |
| **规范确认** | 用户确认代码风格/命名/结构规范     | "要用这种命名"、"放在这个目录"     |
| **隐含假设** | 发现并明确代码中的隐含假设         | "原来假设了 X"、"前提条件是 Y"     |

**输出格式**：

```html
<!-- EXP-CANDIDATE
{
  "taskId": "001",
  "stage": "build",
  "trigger": "当发现 root cause 并更换方案",
  "decision": "实现/修复/接口/边界的取舍",
  "alternatives": ["原方案A（放弃，因为...）"],
  "signal": "判断依据/风险信号/失败证据",
  "solution": "新的实现/修复方案",
  "verify": "测试/验证步骤与结果期望",
  "pointers": ["path/to/file 或接口说明"],
  "reqFile": ".workflow/requirements/001.req.<标题>.md",
  "notes": "可选补充"
}
-->
```

**关键字段**：

- `taskId`：任务编号（001, 002, ...）
- `stage`：当前阶段（build）
- `reqFile`：关联的 req 文件路径（用于后续匹配和追溯）

---

## 与 1.0 的主要区别

1. **命令名称**：从 `work` 阶段改名为 `build` 命令
2. **文件命名**：适配新的文件命名格式（`001.req.*.md`, `001.plan.*.md`, `001.testcase.*.md`）
3. **文件位置**：从 `.workflow/requirements/in-progress/` 改为 `.workflow/requirements/`
4. **索引管理**：不再更新 INDEX.md（2.0 废弃）
5. **状态管理**：不再更新 plan.md 的状态摘要（2.0 废弃 plan-manager）
6. **双模式**：支持 Plan-driven 和 Agent-driven 两种执行模式
