# /plan - Plan 阶段：把需求变成可执行计划

## 命令用途

基于 `ai/requirements/in-progress/<REQ-xxx>.md` 生成可执行的开发计划（任务拆解 + 验证方式 + 交付物），并落盘。

## 依赖的技能型 rules（Skill）

- `.cursor/rules/skill-index-manager.mdc`
- `.cursor/rules/skill-context-engineering.mdc`
- `.cursor/rules/skill-experience-index.mdc`（自动检索与加载历史经验）

## 使用方式

```
/plan <REQ-xxx>
```

---

## 产物（必须落盘）

- `ai/requirements/in-progress/<REQ-xxx>.plan.md`
- `ai/requirements/INDEX.md`

## 执行要点（入口 + 路由）

- **输入**：读取 `ai/requirements/in-progress/<REQ-xxx>.md`（Requirement）

### 第一步：经验检索（强制执行）

**⚠️ 必须执行：** 在命令执行的第一步就必须执行经验检索，不可跳过。

调用 `skill-experience-index.mdc`，根据需求与计划模块自动检索匹配的技术经验，并主动提醒相关风险与代码模式。

**执行步骤：**

1. 读取 `ai/context/experience/INDEX.md`
2. 匹配所有 Status = `active` 的经验
3. 根据需求描述和计划模块进行语义匹配
4. 在对话中输出匹配结果（高风险警告、背景文档路径、相关服务、代码模式）

- **需求类型识别**：从 Requirement 中读取需求类型（前端/后端/全栈/简单功能）和复杂度（简单/中等/复杂），用于选择技术方案设计深度
- **技术方案设计**（中等以上复杂度必须）：
  - **外部参考调研（技术方案层面）**：
    - **与 Requirement 阶段的区别**：Requirement 阶段聚焦需求定义（功能边界、成功标准、业务风险），Plan 阶段聚焦技术方案（技术选型、架构模式、实现方式）
    - **调研范围**：开源项目、知名产品的技术实现、行业技术最佳实践、最新技术进展
    - **技术文档查询**：当需要查询特定库/框架的官方文档时，使用 `mcp_context7_query-docs` 工具查询相关技术文档
      - **触发场景**：需要了解 API 用法、最佳实践、配置选项时
      - **使用示例**：`mcp_context7_query-docs` 查询 "React Hooks 最佳实践"、"Express.js 中间件配置" 等
      - **优先级**：优先查询官方文档，再考虑其他参考
    - **产出要求**：形成技术方案对比表（至少 2 个可行方案，包含优缺点、风险、成本、适配度）和推荐方案与决策理由
  - **API 规范**（后端/全栈需求必须）：详细设计接口定义、Request/Response、错误码、前端所需字段清单
  - **数据模型**（后端/全栈需求必须）：设计数据表/字段变更
  - **技术可行性**：确认技术方案可行，评估实现成本与风险
- **计划结构**：创建/更新 `ai/requirements/in-progress/<REQ-xxx>.plan.md`，使用以下结构（可勾选、可执行、可复现验证）：

```markdown
# <REQ-xxx> Plan

## 目标回放（1-3 行）

## 状态摘要（Status Summary）

> **注意**：此部分便于新 agent 窗口快速恢复上下文，执行 `/work` 时自动更新。

- **当前阶段**：plan（初始值，work 阶段会更新）
- **进度**：0/X 任务完成（work 阶段更新）
- **当前任务**：无（work 阶段更新）
- **阻塞项**：无
- **上次更新**：{DATE}

## 交付物（Deliverables）

- [ ] 代码变更：...
- [ ] 文档变更：...
- [ ] 验证记录：...

## 任务清单（Tasks）

### A. 准备与对齐

- [ ] ...

### B. 后端

- [ ] ...

### C. 前端

- [ ] ...

### D. 数据/配置/外部系统（如有）

- [ ] ...

## 文件清单（Files）

- [ ] 新增：`...`
- [ ] 修改：`...`

## 测试用例规划（Test Cases Planning）

> **注意**：简单功能可省略此章节，或仅列出核心测试点。

### 测试用例文档

- [ ] 功能测试（正常流程）：`docs/test-cases/{功能名称}-test-cases.md`
- [ ] 边界条件测试
- [ ] 错误处理测试
- [ ] 集成测试（如适用）

## 文档同步计划（Documentation Sync Plan）

> **注意**：确保开发完成后更新相关文档，保持代码与文档一致。

- [ ] **技术文档**：API 文档、架构文档、数据库文档
- [ ] **设计文档**：UI/UX 说明、流程图
- [ ] **README**：功能列表、环境变量、部署说明
- [ ] **测试文档**：执行结果、已知问题

## 验证方式（Validation）

> 允许多样化：测试/脚本/手工步骤。必须"可复现"。

### 即时验证策略

> **核心原则**：核心逻辑即时测试，快速反馈，避免最后才发现基础模块有问题。

| 任务类型       | 验证策略          | 说明                       |
| -------------- | ----------------- | -------------------------- |
| 核心业务逻辑   | ✅ 即时测试       | 每完成一个功能模块立即测试 |
| 工具函数/Hooks | ✅ 即时测试       | 每完成一个工具函数立即测试 |
| API 端点       | ✅ 即时测试       | 每完成一个 API 立即测试    |
| UI 组件        | ⏳ 可延迟批量测试 | 可批量测试多个组件         |

### 验证清单

- **自动化测试**：
  - [ ] 单元测试：...
  - [ ] 集成测试：...
- **脚本验证**：
  - [ ] ...
- **手工验证步骤**：
  - [ ] ...
- **集成验收**（开发完成后）：
  - [ ] 运行完整测试套件
  - [ ] 端到端集成测试
  - [ ] 逐项确认 Requirement 验收检查清单
  - [ ] 检查模块间交互正确性

## 风险与回滚（Risks & Rollback）

- 风险：
- 回滚策略：

## Open Questions

- [ ] ...

## 执行记录（Worklog）

- YYYY-MM-DD: 完成 xxx；验证方式：xxx；结果：PASS/FAIL（附简短原因）
```

- **任务粒度**：计划要能直接驱动 `/work` 顺序执行（避免"大而空"的任务）
- **开发顺序与依赖关系**：
  - 明确任务的输入、输出、依赖关系
  - 确定开发顺序（先依赖项，后依赖方）
  - 列出需要创建/修改的文件清单
- **测试用例规划**（中等以上复杂度建议）：
  - 在 Plan 中明确需要编写哪些测试用例（功能测试、边界条件测试、错误处理测试、集成测试）
  - 测试用例文档路径：`docs/test-cases/{功能名称}-test-cases.md`（如适用）
- **即时验证策略**：
  - 在 Plan 中明确每个任务的验证方式（即时测试 vs 批量测试）
  - **即时测试范围**（核心逻辑必须即时测试）：
    - 核心业务逻辑：✅ 即时测试
    - 工具函数/Hooks：✅ 即时测试
    - API 端点：✅ 即时测试
    - UI 组件：⏳ 可延迟批量测试
- **文档同步计划**：
  - 明确需要更新的文档（技术文档、设计文档、README、测试文档）
  - 在 Plan 中列出文档更新清单
- **索引更新**：以 `skill-index-manager.mdc` 为准（Status = `planned`，Links 补充 plan 路径）

---

## 输出要求

- 必须实际写入/更新文件
- 最后用 3-6 行说明：计划文件路径、下一步建议 `/work <REQ-xxx>`
