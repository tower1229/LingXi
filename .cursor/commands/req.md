# /req - Requirement 文档生成/更新

## 命令用途

将一个模糊需求变成**可执行、可验收**的 Requirement 文档，并维护 `ai/requirements/INDEX.md` 索引。

## 依赖的技能型 rules（Skill）

- `.cursor/rules/skill-index-manager.mdc`
- `.cursor/rules/skill-context-engineering.mdc`
- `.cursor/rules/skill-experience-index.mdc`（自动检索与加载历史经验）

## 使用方式

```
/req <需求描述或标题> [可选：REQ-xxx]
```

示例：

```
/req 用户登录与会话管理
/req 新增导出报表功能 REQ-003
```

---

## 产物（必须落盘）

- `ai/requirements/in-progress/<REQ-xxx>.md`
- `ai/requirements/INDEX.md`

## 执行要点（入口 + 路由）

### 第一步：经验检索（强制执行）

**⚠️ 必须执行：** 在命令执行的第一步就必须执行经验检索，不可跳过。

调用 `skill-experience-index.mdc`，根据需求描述自动检索匹配的历史经验，并主动提醒用户相关风险与背景文档。

**执行步骤：**
1. 读取 `ai/context/experience/INDEX.md`
2. 匹配所有 Status = `active` 的经验
3. 根据需求描述进行语义匹配
4. 在对话中输出匹配结果（高风险警告、背景文档路径、相关服务、代码模式）

### 第二步：项目上下文分析

在理解用户需求前，先主动获取项目背景信息：

- 查看 `package.json`、`README.md` 等，了解项目类型、技术栈
- 浏览项目目录结构，理解现有模块划分
- 查看相关代码文件，理解现有实现方式和设计模式
- 识别与新需求相关的现有模块、组件、接口
- 了解项目使用的框架、库版本
- 初步判断需求的技术可行性和需要引入的新依赖

### 第三步：需求类型与复杂度分析

在生成 Requirement 前，先判断需求类型和复杂度，以选择合适的模板结构。

#### 3.1 需求类型识别

| 需求类型       | 特征                                              | 示例                                             |
| -------------- | ------------------------------------------------- | ------------------------------------------------ |
| **纯前端需求** | 只涉及 UI/交互/前端状态，不涉及后端逻辑或数据变更 | "优化移动端展示"、"添加按钮动画"、"调整页面布局" |
| **纯后端需求** | 只涉及 API/服务/数据库，不涉及前端界面            | "优化查询性能"、"调整配额逻辑"、"新增数据迁移"   |
| **全栈需求**   | 同时涉及前端和后端，需要前后端协作                | "实现用户认证"、"新增分享功能"、"实现 AI 分析"   |
| **简单功能**   | 单一、明确、范围小的功能点                        | "修改按钮文案"、"调整错误提示"、"优化加载状态"   |

#### 3.2 复杂度评估

根据功能范围、技术难度、影响范围、依赖关系评估：

- **简单**：单一功能点，影响范围小，无复杂依赖
- **中等**：涉及多个模块，需要前后端协作，有一定技术难度
- **复杂**：架构级变更，影响全局，依赖多个系统

#### 3.3 模板选择决策

根据需求类型和复杂度，选择对应的 Requirement 模板章节：

| 需求类型 | 复杂度    | 包含章节                                                          |
| -------- | --------- | ----------------------------------------------------------------- |
| 纯前端   | 简单      | 概述、目标、用户故事、UI 交互规范、验收清单                       |
| 纯前端   | 中等/复杂 | 概述、目标、用户故事、功能需求、UI 交互规范、依赖与集成、验收清单 |
| 纯后端   | 简单      | 概述、目标、用户故事、验收清单                                    |
| 纯后端   | 中等/复杂 | 概述、目标、用户故事、功能需求、依赖与集成、验收清单              |
| 全栈     | 任意      | 完整模板（所有章节）                                              |
| 简单功能 | 任意      | 简化模板（概述、目标、功能需求、验收清单）                        |

**决策规则：**

1. **前端需求** → 不包含：API 规范、数据模型、数据库设计（这些放到 Plan 阶段）
2. **后端需求** → 不包含：UI 交互规范、前端状态管理、交互设计（这些放到 Plan 阶段）
3. **简单功能** → 只包含核心章节，省略详细设计
4. **全栈需求** → 包含所有章节（但实现方案仍放到 Plan）

### 第四步：评估需求完整性

基于项目上下文和需求类型，评估用户需求描述是否充分：

- **必要信息**（缺失则必须询问）：功能目标、目标用户（前端需求必须）、核心场景（前端需求必须）
- **重要信息**（模糊则建议澄清）：成功标准、优先级、特殊约束
- **可选信息**（缺失可用合理默认值）：风险评估（复杂需求必须）、边界情况处理（中等以上复杂度必须）

### 第五步：补充第一方信息（仅在必要时）

如果需求描述已足够完整，直接进入下一步。

如果信息不足，**一次性**列出所有需要补充的问题，并结合项目上下文给出合理的默认建议。

### 第六步：外部参考调研（需求层面，中等以上复杂度建议执行）

> **目的**：联网调研类似需求在现实世界中的最佳实践，用于完善需求定义（边界、成功标准、非目标、业务风险），**不是技术方案对比**（技术方案对比放到 Plan 阶段）。

**调研范围（按需选择）：**

- **竞品/同类产品**：功能边界、交互细节、默认策略、边界处理、商业化策略
- **行业最佳实践**：用户期望、成功标准、常见问题、合规要求
- **类似场景的成熟方案**：开源项目、知名产品的功能设计思路

**产出要求（聚焦需求定义，不涉及技术实现）：**

- **竞品功能对比**（中等以上复杂度建议）：
  - 竞品有哪些相关功能？
  - 哪些功能是行业标准（我们是否要做）？
  - 哪些功能是竞品有但我们明确不做的（非目标）？
- **成功标准参考**（中等以上复杂度建议）：
  - 行业平均水平是什么？
  - 用户满意度指标是什么？
  - 我们的目标是什么？
- **业务风险识别**（复杂需求必须）：
  - 类似需求在现实中遇到的常见问题
  - 用户反馈中的高频痛点
  - 合规/安全方面的注意事项
- **引用与链接**：列出关键来源

**注意：**

- **简单功能**：可省略外部参考调研，或仅做简要说明
- **不要涉及技术方案**：技术选型、架构模式、实现方式对比放到 Plan 阶段
- **聚焦需求定义**：帮助完善"做什么、为什么、验收标准"，而不是"怎么做"

### 第七步：信息汇总与需求定稿

在输出 Requirement 前，把信息聚合为可执行需求：

- **需求澄清结论**：目标/范围/成功标准/约束的最终表述
- **关键决策点**：功能边界、非目标、优先级（复杂需求必须）
- **风险与对策**：按"发生概率 × 影响"排序，给出缓解措施（中等以上复杂度必须）

### 第八步：ID 生成与落盘

- **ID 生成**：若未指定 `REQ-xxx`，读取 `ai/requirements/INDEX.md` 生成下一个连续 ID
- **落盘结构**：根据第三步的模板选择决策，创建/更新 `ai/requirements/in-progress/<REQ-xxx>.md`，使用以下结构（保持简洁、可验收；**不写实现方案**）：

```markdown
# <REQ-xxx>: <Title>

| 属性     | 值                        |
| -------- | ------------------------- |
| 版本     | 1.0                       |
| 状态     | 草稿                      |
| 创建日期 | {DATE}                    |
| 需求类型 | [前端/后端/全栈/简单功能] |
| 复杂度   | [简单/中等/复杂]          |

---

## 1. 概述

### 1.1 背景

[业务背景和动机]

### 1.2 问题描述

[要解决的问题]

### 1.3 解决方案概述

[方案整体思路，不涉及技术实现细节]

---

## 2. 目标与指标

### 2.1 目标

| 编号 | 目标     | 优先级   |
| ---- | -------- | -------- |
| G1   | [目标 1] | 必须实现 |
| G2   | [目标 2] | 应该实现 |

### 2.2 非目标

- [本次不做的事情]

### 2.3 成功标准

| 标准     | 描述   | 验证方式 |
| -------- | ------ | -------- |
| [标准 1] | [描述] | [方式]   |

---

## 3. 用户分析

> **注意**：纯后端需求可省略此章节。

### 3.1 目标用户

| 用户类型 | 特征   | 核心需求 |
| -------- | ------ | -------- |
| [用户 1] | [描述] | [需求]   |

### 3.2 用户旅程

1. **入口** → [用户从哪里开始]
2. **操作** → [用户执行什么动作]
3. **结果** → [用户得到什么反馈]

---

## 4. 用户故事

### US-1: {故事标题}

**作为** [用户类型]
**我想要** [执行的操作]
**以便** [获得的价值]

**验收标准：**

- [ ] [标准 1]
- [ ] [标准 2]

**优先级：** [必须/应该/可以]

---

## 5. 功能需求

> **注意**：简单功能可省略此章节，直接在用户故事中描述。

| 编号 | 需求描述 | 优先级   | 备注 |
| ---- | -------- | -------- | ---- |
| F1   | [需求 1] | 必须实现 |      |
| F2   | [需求 2] | 应该实现 |      |

### F1: {功能名称}

- **描述：** [详细描述]
- **输入：** [输入内容]
- **输出：** [输出内容]
- **异常处理：** [边界情况]

---

## 6. UI 交互规范

> **注意**：纯后端需求不包含此章节。

> **重要**：每个可交互元素必须明确三态规则，避免前端实现遗漏。

### 6.1 UI 状态矩阵

对于每个按钮/控件，必须明确以下三个状态：

| 元素名称   | 可见条件              | 可用条件           | 文案/样式变化规则                      |
| ---------- | --------------------- | ------------------ | -------------------------------------- |
| [按钮名称] | [什么用户/状态下可见] | [什么条件下可点击] | [不同状态下的文案/样式]                |
| 示例       | 仅 Pro 用户可见       | 未达每日限制时可用 | 可用时显示"执行"，限制时显示"明天可用" |

### 6.2 状态流转图
```

[初始状态] → [触发条件] → [目标状态]
↓
[异常分支] → [错误状态] → [恢复操作] → [初始状态]

```

### 6.3 加载与反馈

| 操作       | 加载态表现       | 成功反馈         | 失败反馈         |
| ---------- | ---------------- | ---------------- | ---------------- |
| [操作名称] | [loading 样式]   | [toast/UI 变化]  | [错误提示]       |

---

## 7. 依赖与集成

> **注意**：简单功能或无依赖时可省略此章节。

### 7.1 PRD 依赖关系

> **重要**：明确与其他 Requirement 的交互点，避免跨功能遗漏。

| 依赖 REQ | 交互点               | 本 REQ 职责         | 依赖方职责         |
| -------- | -------------------- | ------------------- | ------------------ |
| REQ-XX   | [共享的数据/接口/UI] | [本 REQ 需要做什么] | [依赖方需要做什么] |

### 7.2 现有系统分析

- **相关现有模块：** [列出相关的现有代码模块]
- **可复用组件：** [可以复用的现有组件/服务]
- **需要修改的部分：** [需要调整的现有功能]

### 7.3 技术依赖

| 依赖项   | 类型      | 说明       |
| -------- | --------- | ---------- |
| [依赖 1] | 现有/新增 | [影响说明] |

---

## 8. 验收检查清单

> **重要**：开发完成后必须逐项检查，避免实现遗漏。

### 8.1 后端检查项

> **注意**：纯前端需求可省略此部分。

- [ ] 所有功能需求已实现
- [ ] 权限检查正确（用户类型、配额限制）
- [ ] 错误处理符合规范
- [ ] 数据变更已迁移（如涉及）

### 8.2 前端检查项

> **注意**：纯后端需求可省略此部分。

- [ ] 所有 UI 元素的三态（可见/可用/文案）已正确实现
- [ ] 不同用户类型看到的 UI 符合预期
- [ ] 操作后正确刷新相关数据（mutate/revalidate）
- [ ] 加载状态、成功反馈、错误提示已实现
- [ ] 限制状态下的 UI 表现正确（禁用 + 提示）

### 8.3 集成检查项

- [ ] 与依赖 REQ 的交互点已正确对接
- [ ] 数据流完整（API → Hook → 组件 → UI，如涉及）

---

## 9. 风险评估

> **注意**：简单功能可省略此章节。

| 风险     | 可能性   | 影响     | 应对措施 |
| -------- | -------- | -------- | -------- |
| [风险 1] | 高/中/低 | 高/中/低 | [措施]   |

---

## 10. 待确认问题

- [ ] ...

---

## 11. 外部参考与行业实践

> **注意**：简单功能或无外部参考时可省略此章节。

### 11.1 竞品功能对比

> **目的**：明确需求边界，识别非目标。

| 竞品/产品 | 相关功能 | 我们的决策 | 理由 |
| --------- | -------- | ---------- | ---- |
| [竞品 1]  | [功能 A]  | 做/不做    | [理由] |
| [竞品 2]  | [功能 B]  | 做/不做    | [理由] |

### 11.2 成功标准参考

> **目的**：基于行业实践定义可验证的成功标准。

| 指标     | 行业平均水平 | 我们的目标 | 验证方式 |
| -------- | ------------ | ---------- | -------- |
| [指标 1] | [参考值]     | [目标值]   | [方式]   |

### 11.3 业务风险参考

> **目的**：识别类似需求在现实中遇到的常见问题。

| 风险场景           | 常见问题               | 我们的应对措施 |
| ------------------ | ---------------------- | -------------- |
| [场景 1]           | [问题描述]             | [措施]         |
| 用户反馈高频痛点   | [痛点描述]             | [措施]         |
| 合规/安全注意事项  | [注意事项]             | [措施]         |

### 11.4 引用与链接

- [来源 1]：[链接/描述]
- [来源 2]：[链接/描述]

---

## 12. 变更记录

| 版本 | 日期   | 变更内容 |
| ---- | ------ | -------- |
| 1.0  | {DATE} | 初稿     |
```

### 简化模板示例（简单功能）

简单功能（如"修改按钮文案"、"调整错误提示"）可使用以下简化结构：

```markdown
# <REQ-xxx>: <Title>

| 属性     | 值       |
| -------- | -------- |
| 版本     | 1.0      |
| 状态     | 草稿     |
| 创建日期 | {DATE}   |
| 需求类型 | 简单功能 |
| 复杂度   | 简单     |

---

## 1. 概述

### 1.1 背景

[简要说明背景]

### 1.2 问题描述

[要解决的问题]

### 1.3 解决方案概述

[简要方案]

---

## 2. 目标与指标

### 2.1 目标

| 编号 | 目标     | 优先级   |
| ---- | -------- | -------- |
| G1   | [目标 1] | 必须实现 |

### 2.2 成功标准

| 标准     | 描述   | 验证方式 |
| -------- | ------ | -------- |
| [标准 1] | [描述] | [方式]   |

---

## 3. 用户故事

### US-1: {故事标题}

**作为** [用户类型]
**我想要** [执行的操作]
**以便** [获得的价值]

**验收标准：**

- [ ] [标准 1]
- [ ] [标准 2]

**实现说明：**
[简要说明实现方式，如涉及 UI 则说明具体位置和文案]

---

## 4. 验收检查清单

- [ ] [检查项 1]
- [ ] [检查项 2]

---

## 5. 外部参考（可选）

> **注意**：简单功能通常不需要外部参考。

### 5.1 竞品功能对比

| 竞品/产品 | 相关功能 | 我们的决策 | 理由   |
| --------- | -------- | ---------- | ------ |
| [竞品 1]  | [功能 A] | 做/不做    | [理由] |

### 5.2 引用与链接

- [来源 1]：[链接/描述]

---

## 6. 变更记录

| 版本 | 日期   | 变更内容 |
| ---- | ------ | -------- |
| 1.0  | {DATE} | 初稿     |
```

- **验收标准约束**：必须可验证（允许测试/脚本/手工步骤），禁止"体验良好"这类主观描述
- **质量检查要点**：确保以下关键点已覆盖（避免实现遗漏）：
  - **前端需求/全栈需求**：
    - 每个按钮/控件都有明确的三态定义（可见/可用/文案）
    - 操作后的数据刷新明确（哪些缓存需要更新）
    - 用户旅程清晰（入口 → 操作 → 结果）
  - **后端需求/全栈需求**：
    - 所有错误场景有对应的错误码
    - 权限和配额限制有明确的检查逻辑
    - 返回的字段能支持 UI 的所有状态展示（在 Plan 阶段会详细设计 API）
  - **中等以上复杂度**：
    - 依赖其他 REQ 的交互点有明确说明
    - 涉及多页面的功能有统一的状态来源
    - 共享数据的变更通知机制明确
- **禁止事项**：
  - **不要写实现方案**：API 规范、数据模型、技术可行性、技术方案对比（这些放到 Plan 阶段）
  - **不要写代码细节**：只描述"做什么"，不描述"怎么做"
- **索引更新**：以 `skill-index-manager.mdc` 为准（Status = `in-progress`，Links 至少包含 requirement 路径）

---

## 输出要求

- 必须实际写入/更新文件（不是只在聊天里输出）
- 在 Requirement 头部明确标注需求类型和复杂度（用于后续 Plan 阶段选择技术方案）
- 最后用 3-6 行简短说明：生成了哪些文件、需求类型与复杂度、接下来建议执行什么命令（通常是 `/plan REQ-xxx`）
